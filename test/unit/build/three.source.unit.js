(function (factory) {
	typeof define === 'function' && define.amd ? define(factory) :
	factory();
}((function () { 'use strict';

	QUnit.module( "Source", () => {

	// This easy console wrapper introduces the logging level to console for
	// preventing console outputs caused when we purposely test the code path
	// including console outputs.
	//
	// Example: Prevent the console warnings caused by Color.setStyle().
	//   const c = new Color();
	//   console.level = CONSOLE_LEVEL.ERROR;
	//   c.setStyle( 'rgba(255,0,0,0.5)' );
	//   console.level = CONSOLE_LEVEL.DEFAULT;
	//
	// See https://github.com/mrdoob/three.js/issues/20760#issuecomment-735190998

	const CONSOLE_LEVEL = {
		OFF : 0,
		ERROR : 1,
		WARN : 2,
		LOG : 3,
		INFO : 4,
		DEBUG : 5,
		ALL: 6,
		DEFAULT: 6
	};

	console.level = CONSOLE_LEVEL.DEFAULT;

	// Save the original methods
	console._error = console.error;
	console._warn = console.warn;
	console._log = console.log;
	console._info = console.info;
	console._debug = console.debug;

	// Wrap console methods
	console.error = function () {

		if ( this.level >= CONSOLE_LEVEL.ERROR ) this._error.apply( this, arguments );

	};

	console.warn = function () {

		if ( this.level >= CONSOLE_LEVEL.WARN ) this._warn.apply( this, arguments );

	};

	console.log = function () {

		if ( this.level >= CONSOLE_LEVEL.LOG ) this._log.apply( this, arguments );

	};

	console.info = function () {

		if ( this.level >= CONSOLE_LEVEL.INFO ) this._info.apply( this, arguments );

	};

	console.debug = function () {

		if ( this.level >= CONSOLE_LEVEL.DEBUG ) this._debug.apply( this, arguments );

	};

	// Smart comparison of three.js objects.
	// Identifies significant differences between two objects.
	// Performs deep comparison.
	// Comparison stops after the first difference is found.
	// Provides an explanation for the failure.
	function SmartComparer() {

		// Diagnostic message, when comparison fails.
		var message;

		return {

			areEqual: areEqual,

			getDiagnostic: function () {

				return message;

			}

		};


		// val1 - first value to compare (typically the actual value)
		// val2 - other value to compare (typically the expected value)
		function areEqual( val1, val2 ) {

			// Values are strictly equal.
			if ( val1 === val2 ) return true;

			// Null or undefined values.
			/* jshint eqnull:true */
			if ( val1 == null || val2 == null ) {

				if ( val1 != val2 ) {

					return makeFail( 'One value is undefined or null', val1, val2 );

				}

				// Both null / undefined.
				return true;

			}

			// Don't compare functions.
			if ( isFunction( val1 ) && isFunction( val2 ) ) return true;

			// Array comparison.
			var arrCmp = compareArrays( val1, val2 );
			if ( arrCmp !== undefined ) return arrCmp;

			// Has custom equality comparer.
			if ( val1.equals ) {

				if ( val1.equals( val2 ) ) return true;

				return makeFail( 'Comparison with .equals method returned false' );

			}

			// Object comparison.
			var objCmp = compareObjects( val1, val2 );
			if ( objCmp !== undefined ) return objCmp;

			// if (JSON.stringify( val1 ) == JSON.stringify( val2 ) ) return true;

			// Object differs (unknown reason).
			return makeFail( 'Values differ', val1, val2 );

		}

		function isFunction( value ) {

			// The use of `Object#toString` avoids issues with the `typeof` operator
			// in Safari 8 which returns 'object' for typed array constructors, and
			// PhantomJS 1.9 which returns 'function' for `NodeList` instances.
			var tag = isObject( value ) ? Object.prototype.toString.call( value ) : '';

			return tag == '[object Function]' || tag == '[object GeneratorFunction]';

		}

		function isObject( value ) {

			// Avoid a V8 JIT bug in Chrome 19-20.
			// See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
			var type = typeof value;

			return !! value && ( type == 'object' || type == 'function' );

		}

		function compareArrays( val1, val2 ) {

			var isArr1 = Array.isArray( val1 );
			var isArr2 = Array.isArray( val2 );

			// Compare type.
			if ( isArr1 !== isArr2 ) return makeFail( 'Values are not both arrays' );

			// Not arrays. Continue.
			if ( ! isArr1 ) return undefined;

			// Compare length.
			var N1 = val1.length;
			var N2 = val2.length;
			if ( N1 !== val2.length ) return makeFail( 'Array length differs', N1, N2 );

			// Compare content at each index.
			for ( var i = 0; i < N1; i ++ ) {

				var cmp = areEqual( val1[ i ], val2[ i ] );
				if ( ! cmp )	return addContext( 'array index "' + i + '"' );

			}

			// Arrays are equal.
			return true;

		}


		function compareObjects( val1, val2 ) {

			var isObj1 = isObject( val1 );
			var isObj2 = isObject( val2 );

			// Compare type.
			if ( isObj1 !== isObj2 ) return makeFail( 'Values are not both objects' );

			// Not objects. Continue.
			if ( ! isObj1 ) return undefined;

			// Compare keys.
			var keys1 = Object.keys( val1 );
			var keys2 = Object.keys( val2 );

			for ( var i = 0, l = keys1.length; i < l; i ++ ) {

				if ( keys2.indexOf( keys1[ i ] ) < 0 ) {

					return makeFail( 'Property "' + keys1[ i ] + '" is unexpected.' );

				}

			}

			for ( var i = 0, l = keys2.length; i < l; i ++ ) {

				if ( keys1.indexOf( keys2[ i ] ) < 0 ) {

					return makeFail( 'Property "' + keys2[ i ] + '" is missing.' );

				}

			}

			// Keys are the same. For each key, compare content until a difference is found.
			var hadDifference = false;

			for ( var i = 0, l = keys1.length; i < l; i ++ ) {

				var key = keys1[ i ];

				if ( key === "uuid" || key === "id" ) {

					continue;

				}

				var prop1 = val1[ key ];
				var prop2 = val2[ key ];

				// Compare property content.
				var eq = areEqual( prop1, prop2 );

				// In case of failure, an message should already be set.
				// Add context to low level message.
				if ( ! eq ) {

					addContext( 'property "' + key + '"' );
					hadDifference = true;

				}

			}

			return ! hadDifference;

		}


		function makeFail( msg, val1, val2 ) {

			message = msg;
			if ( arguments.length > 1 ) message += " (" + val1 + " vs " + val2 + ")";

			return false;

		}

		function addContext( msg ) {

			// There should already be a validation message. Add more context to it.
			message = message || "Error";
			message += ", at " + msg;

			return false;

		}

	}

	const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
	const CullFaceNone = 0;
	const CullFaceBack = 1;
	const CullFaceFront = 2;
	const CullFaceFrontBack = 3;
	const BasicShadowMap = 0;
	const PCFShadowMap = 1;
	const PCFSoftShadowMap = 2;
	const VSMShadowMap = 3;
	const FrontSide = 0;
	const BackSide = 1;
	const DoubleSide = 2;
	const FlatShading = 1;
	const SmoothShading = 2;
	const NoBlending = 0;
	const NormalBlending = 1;
	const AdditiveBlending = 2;
	const SubtractiveBlending = 3;
	const MultiplyBlending = 4;
	const CustomBlending = 5;
	const AddEquation = 100;
	const SubtractEquation = 101;
	const ReverseSubtractEquation = 102;
	const MinEquation = 103;
	const MaxEquation = 104;
	const ZeroFactor = 200;
	const OneFactor = 201;
	const SrcColorFactor = 202;
	const OneMinusSrcColorFactor = 203;
	const SrcAlphaFactor = 204;
	const OneMinusSrcAlphaFactor = 205;
	const DstAlphaFactor = 206;
	const OneMinusDstAlphaFactor = 207;
	const DstColorFactor = 208;
	const OneMinusDstColorFactor = 209;
	const SrcAlphaSaturateFactor = 210;
	const NeverDepth = 0;
	const AlwaysDepth = 1;
	const LessDepth = 2;
	const LessEqualDepth = 3;
	const EqualDepth = 4;
	const GreaterEqualDepth = 5;
	const GreaterDepth = 6;
	const NotEqualDepth = 7;
	const MultiplyOperation = 0;
	const MixOperation = 1;
	const AddOperation = 2;
	const NoToneMapping = 0;
	const LinearToneMapping = 1;
	const ReinhardToneMapping = 2;
	const CineonToneMapping = 3;
	const ACESFilmicToneMapping = 4;
	const CustomToneMapping = 5;

	const UVMapping = 300;
	const CubeReflectionMapping = 301;
	const CubeRefractionMapping = 302;
	const EquirectangularReflectionMapping = 303;
	const EquirectangularRefractionMapping = 304;
	const CubeUVReflectionMapping = 306;
	const CubeUVRefractionMapping = 307;
	const RepeatWrapping = 1000;
	const ClampToEdgeWrapping = 1001;
	const MirroredRepeatWrapping = 1002;
	const NearestFilter = 1003;
	const NearestMipmapNearestFilter = 1004;
	const NearestMipMapNearestFilter = 1004;
	const NearestMipmapLinearFilter = 1005;
	const NearestMipMapLinearFilter = 1005;
	const LinearFilter = 1006;
	const LinearMipmapNearestFilter = 1007;
	const LinearMipMapNearestFilter = 1007;
	const LinearMipmapLinearFilter = 1008;
	const LinearMipMapLinearFilter = 1008;
	const UnsignedByteType = 1009;
	const ByteType = 1010;
	const ShortType = 1011;
	const UnsignedShortType = 1012;
	const IntType = 1013;
	const UnsignedIntType = 1014;
	const FloatType = 1015;
	const HalfFloatType = 1016;
	const UnsignedShort4444Type = 1017;
	const UnsignedShort5551Type = 1018;
	const UnsignedShort565Type = 1019;
	const UnsignedInt248Type = 1020;
	const AlphaFormat = 1021;
	const RGBFormat = 1022;
	const RGBAFormat = 1023;
	const LuminanceFormat = 1024;
	const LuminanceAlphaFormat = 1025;
	const RGBEFormat = RGBAFormat;
	const DepthFormat = 1026;
	const DepthStencilFormat = 1027;
	const RedFormat = 1028;
	const RedIntegerFormat = 1029;
	const RGFormat = 1030;
	const RGIntegerFormat = 1031;
	const RGBIntegerFormat = 1032;
	const RGBAIntegerFormat = 1033;

	const RGB_S3TC_DXT1_Format = 33776;
	const RGBA_S3TC_DXT1_Format = 33777;
	const RGBA_S3TC_DXT3_Format = 33778;
	const RGBA_S3TC_DXT5_Format = 33779;
	const RGB_PVRTC_4BPPV1_Format = 35840;
	const RGB_PVRTC_2BPPV1_Format = 35841;
	const RGBA_PVRTC_4BPPV1_Format = 35842;
	const RGBA_PVRTC_2BPPV1_Format = 35843;
	const RGB_ETC1_Format = 36196;
	const RGB_ETC2_Format = 37492;
	const RGBA_ETC2_EAC_Format = 37496;
	const RGBA_ASTC_4x4_Format = 37808;
	const RGBA_ASTC_5x4_Format = 37809;
	const RGBA_ASTC_5x5_Format = 37810;
	const RGBA_ASTC_6x5_Format = 37811;
	const RGBA_ASTC_6x6_Format = 37812;
	const RGBA_ASTC_8x5_Format = 37813;
	const RGBA_ASTC_8x6_Format = 37814;
	const RGBA_ASTC_8x8_Format = 37815;
	const RGBA_ASTC_10x5_Format = 37816;
	const RGBA_ASTC_10x6_Format = 37817;
	const RGBA_ASTC_10x8_Format = 37818;
	const RGBA_ASTC_10x10_Format = 37819;
	const RGBA_ASTC_12x10_Format = 37820;
	const RGBA_ASTC_12x12_Format = 37821;
	const RGBA_BPTC_Format = 36492;
	const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	const LoopOnce = 2200;
	const LoopRepeat = 2201;
	const LoopPingPong = 2202;
	const InterpolateDiscrete = 2300;
	const InterpolateLinear = 2301;
	const InterpolateSmooth = 2302;
	const ZeroCurvatureEnding = 2400;
	const ZeroSlopeEnding = 2401;
	const WrapAroundEnding = 2402;
	const NormalAnimationBlendMode = 2500;
	const AdditiveAnimationBlendMode = 2501;
	const TrianglesDrawMode = 0;
	const TriangleStripDrawMode = 1;
	const TriangleFanDrawMode = 2;
	const LinearEncoding = 3000;
	const sRGBEncoding = 3001;
	const GammaEncoding = 3007;
	const RGBEEncoding = 3002;
	const LogLuvEncoding = 3003;
	const RGBM7Encoding = 3004;
	const RGBM16Encoding = 3005;
	const RGBDEncoding = 3006;
	const BasicDepthPacking = 3200;
	const RGBADepthPacking = 3201;
	const TangentSpaceNormalMap = 0;
	const ObjectSpaceNormalMap = 1;
	const KeepStencilOp = 7680;
	const AlwaysStencilFunc = 519;

	const StaticDrawUsage = 35044;
	const DynamicDrawUsage = 35048;
	const GLSL3 = '300 es';

	class Vector4 {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

		}

		get width() {

			return this.z;

		}

		set width( value ) {

			this.z = value;

		}

		get height() {

			return this.w;

		}

		set height( value ) {

			this.w = value;

		}

		set( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setW( w ) {

			this.w = w;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z, this.w );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
			this.w *= v.w;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z, w = this.w;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		setAxisAngleFromQuaternion( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			const s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		}

		setAxisAngleFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			let angle, x, y, z; // variables for result
			const epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				const xx = ( m11 + 1 ) / 2;
				const yy = ( m22 + 1 ) / 2;
				const zz = ( m33 + 1 ) / 2;
				const xy = ( m12 + m21 ) / 4;
				const xz = ( m13 + m31 ) / 4;
				const yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				( m13 - m31 ) * ( m13 - m31 ) +
				( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;
			this.w = v1.w + ( v2.w - v1.w ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();
			this.w = Math.random();

			return this;

		}

	}

	Vector4.prototype.isVector4 = true;

	const _lut = [];

	for ( let i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	let _seed = 1234567;

	const MathUtils = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			const d0 = Math.random() * 0xffffffff | 0;
			const d1 = Math.random() * 0xffffffff | 0;
			const d2 = Math.random() * 0xffffffff | 0;
			const d3 = Math.random() * 0xffffffff | 0;
			const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

			// .toUpperCase() here flattens concatenated strings to save heap memory space.
			return uuid.toUpperCase();

		},

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

		damp: function ( x, y, lambda, dt ) {

			return MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );

		},

		// https://www.desmos.com/calculator/vcsjnyz7x4

		pingpong: function ( x, length = 1 ) {

			return length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		// Deterministic pseudo-random float in the interval [ 0, 1 ]

		seededRandom: function ( s ) {

			if ( s !== undefined ) _seed = s % 2147483647;

			// Park-Miller algorithm

			_seed = _seed * 16807 % 2147483647;

			return ( _seed - 1 ) / 2147483646;

		},

		degToRad: function ( degrees ) {

			return degrees * MathUtils.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * MathUtils.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			const cos = Math.cos;
			const sin = Math.sin;

			const c2 = cos( b / 2 );
			const s2 = sin( b / 2 );

			const c13 = cos( ( a + c ) / 2 );
			const s13 = sin( ( a + c ) / 2 );

			const c1_3 = cos( ( a - c ) / 2 );
			const s1_3 = sin( ( a - c ) / 2 );

			const c3_1 = cos( ( c - a ) / 2 );
			const s3_1 = sin( ( c - a ) / 2 );

			switch ( order ) {

				case 'XYX':
					q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
					break;

				case 'YZY':
					q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
					break;

				case 'ZXZ':
					q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
					break;

				case 'XZX':
					q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
					break;

				case 'YXY':
					q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
					break;

				case 'ZYZ':
					q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
					break;

				default:
					console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

			}

		}

	};

	class Quaternion {

		constructor( x = 0, y = 0, z = 0, w = 1 ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

		}

		static slerp( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		}

		static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			let x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( t === 0 ) {

				dst[ dstOffset + 0 ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
				return;

			}

			if ( t === 1 ) {

				dst[ dstOffset + 0 ] = x1;
				dst[ dstOffset + 1 ] = y1;
				dst[ dstOffset + 2 ] = z1;
				dst[ dstOffset + 3 ] = w1;
				return;

			}

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				let s = 1 - t;
				const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					const sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				const tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

		static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

			const x0 = src0[ srcOffset0 ];
			const y0 = src0[ srcOffset0 + 1 ];
			const z0 = src0[ srcOffset0 + 2 ];
			const w0 = src0[ srcOffset0 + 3 ];

			const x1 = src1[ srcOffset1 ];
			const y1 = src1[ srcOffset1 + 1 ];
			const z1 = src1[ srcOffset1 + 2 ];
			const w1 = src1[ srcOffset1 + 3 ];

			dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
			dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
			dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
			dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

			return dst;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get w() {

			return this._w;

		}

		set w( value ) {

			this._w = value;
			this._onChangeCallback();

		}

		set( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._w );

		}

		copy( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		}

		setFromEuler( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			const cos = Math.cos;
			const sin = Math.sin;

			const c1 = cos( x / 2 );
			const c2 = cos( y / 2 );
			const c3 = cos( z / 2 );

			const s1 = sin( x / 2 );
			const s2 = sin( y / 2 );
			const s3 = sin( z / 2 );

			switch ( order ) {

				case 'XYZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'YXZ':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'ZXY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'ZYX':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				case 'YZX':
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
					break;

				case 'XZY':
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
					break;

				default:
					console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromAxisAngle( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			const halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33;

			if ( trace > 0 ) {

				const s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		}

		setFromUnitVectors( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			const EPS = 0.000001;

			let r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		}

		angleTo( q ) {

			return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

		}

		rotateTowards( q, step ) {

			const angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			const t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		}

		identity() {

			return this.set( 0, 0, 0, 1 );

		}

		invert() {

			// quaternion is assumed to have unit length

			return this.conjugate();

		}

		conjugate() {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		}

		dot( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		}

		lengthSq() {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		}

		length() {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		}

		normalize() {

			let l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		}

		multiply( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		}

		premultiply( q ) {

			return this.multiplyQuaternions( q, this );

		}

		multiplyQuaternions( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		}

		slerp( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			const x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				const s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		}

		equals( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		}

		fromArray( array, offset = 0 ) {

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this._x = attribute.getX( index );
			this._y = attribute.getY( index );
			this._z = attribute.getZ( index );
			this._w = attribute.getW( index );

			return this;

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	Quaternion.prototype.isQuaternion = true;

	class Vector3 {

		constructor( x = 0, y = 0, z = 0 ) {

			this.x = x;
			this.y = y;
			this.z = z;

		}

		set( x, y, z ) {

			if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setZ( z ) {

			this.z = z;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y, this.z );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		}

		multiply( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		}

		multiplyVectors( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		}

		applyEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		}

		applyAxisAngle( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		}

		applyNormalMatrix( m ) {

			return this.applyMatrix3( m ).normalize();

		}

		applyMatrix4( m ) {

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		}

		applyQuaternion( q ) {

			const x = this.x, y = this.y, z = this.z;
			const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			const ix = qw * x + qy * z - qz * y;
			const iy = qw * y + qz * x - qx * z;
			const iz = qw * z + qx * y - qy * x;
			const iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		}

		project( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		}

		unproject( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		}

		transformDirection( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			const x = this.x, y = this.y, z = this.z;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		}

		// TODO lengthSquared?

		lengthSq() {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;
			this.z = v1.z + ( v2.z - v1.z ) * alpha;

			return this;

		}

		cross( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		}

		crossVectors( a, b ) {

			const ax = a.x, ay = a.y, az = a.z;
			const bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		}

		projectOnVector( v ) {

			const denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			const scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		}

		projectOnPlane( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		}

		reflect( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

		angleTo( v ) {

			const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			const theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		}

		setFromSpherical( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		}

		setFromSphericalCoords( radius, phi, theta ) {

			const sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		}

		setFromCylindrical( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		}

		setFromCylindricalCoords( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		}

		setFromMatrixPosition( m ) {

			const e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		}

		setFromMatrixScale( m ) {

			const sx = this.setFromMatrixColumn( m, 0 ).length();
			const sy = this.setFromMatrixColumn( m, 1 ).length();
			const sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		}

		setFromMatrixColumn( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		}

		setFromMatrix3Column( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();
			this.z = Math.random();

			return this;

		}

	}

	Vector3.prototype.isVector3 = true;

	const _vector = /*@__PURE__*/ new Vector3();
	const _quaternion = /*@__PURE__*/ new Quaternion();

	class Vector2 {

		constructor( x = 0, y = 0 ) {

			this.x = x;
			this.y = y;

		}

		get width() {

			return this.x;

		}

		set width( value ) {

			this.x = value;

		}

		get height() {

			return this.y;

		}

		set height( value ) {

			this.y = value;

		}

		set( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		}

		setScalar( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		}

		setX( x ) {

			this.x = x;

			return this;

		}

		setY( y ) {

			this.y = y;

			return this;

		}

		setComponent( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		}

		getComponent( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		}

		clone() {

			return new this.constructor( this.x, this.y );

		}

		copy( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		}

		add( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		}

		addScalar( s ) {

			this.x += s;
			this.y += s;

			return this;

		}

		addVectors( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		}

		addScaledVector( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		}

		sub( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		}

		subScalar( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		}

		subVectors( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		}

		multiply( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		}

		multiplyScalar( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		}

		divide( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		}

		divideScalar( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		}

		applyMatrix3( m ) {

			const x = this.x, y = this.y;
			const e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		}

		min( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		}

		max( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		}

		clamp( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		}

		clampScalar( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		}

		clampLength( min, max ) {

			const length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		}

		floor() {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		}

		ceil() {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		}

		round() {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		}

		roundToZero() {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		}

		negate() {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		}

		dot( v ) {

			return this.x * v.x + this.y * v.y;

		}

		cross( v ) {

			return this.x * v.y - this.y * v.x;

		}

		lengthSq() {

			return this.x * this.x + this.y * this.y;

		}

		length() {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		}

		manhattanLength() {

			return Math.abs( this.x ) + Math.abs( this.y );

		}

		normalize() {

			return this.divideScalar( this.length() || 1 );

		}

		angle() {

			// computes the angle in radians with respect to the positive x-axis

			const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		}

		distanceTo( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		}

		distanceToSquared( v ) {

			const dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		}

		manhattanDistanceTo( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		}

		setLength( length ) {

			return this.normalize().multiplyScalar( length );

		}

		lerp( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		}

		lerpVectors( v1, v2, alpha ) {

			this.x = v1.x + ( v2.x - v1.x ) * alpha;
			this.y = v1.y + ( v2.y - v1.y ) * alpha;

			return this;

		}

		equals( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		}

		fromArray( array, offset = 0 ) {

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		}

		fromBufferAttribute( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		}

		rotateAround( center, angle ) {

			const c = Math.cos( angle ), s = Math.sin( angle );

			const x = this.x - center.x;
			const y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

		random() {

			this.x = Math.random();
			this.y = Math.random();

			return this;

		}

	}

	Vector2.prototype.isVector2 = true;

	const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	const _hslA = { h: 0, s: 0, l: 0 };
	const _hslB = { h: 0, s: 0, l: 0 };

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	class Color {

		constructor( r, g, b ) {

			if ( g === undefined && b === undefined ) {

				// r is THREE.Color, hex or string
				return this.set( r );

			}

			return this.setRGB( r, g, b );

		}

		set( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		}

		setScalar( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		}

		setHex( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		}

		setRGB( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		}

		setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = MathUtils.euclideanModulo( h, 1 );
			s = MathUtils.clamp( s, 0, 1 );
			l = MathUtils.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				const q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		}

		setStyle( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			let m;

			if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				let color;
				const name = m[ 1 ];
				const components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 4 ] );

							return this;

						}

						if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 4 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							const h = parseFloat( color[ 1 ] ) / 360;
							const s = parseInt( color[ 2 ], 10 ) / 100;
							const l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 4 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

				// hex color

				const hex = m[ 1 ];
				const size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				return this.setColorName( style );

			}

			return this;

		}

		setColorName( style ) {

			// color keywords
			const hex = _colorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		}

		clone() {

			return new this.constructor( this.r, this.g, this.b );

		}

		copy( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		}

		copyGammaToLinear( color, gammaFactor = 2.0 ) {

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		}

		copyLinearToGamma( color, gammaFactor = 2.0 ) {

			const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		}

		convertGammaToLinear( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		}

		convertLinearToGamma( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		}

		copySRGBToLinear( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		}

		copyLinearToSRGB( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		}

		convertSRGBToLinear() {

			this.copySRGBToLinear( this );

			return this;

		}

		convertLinearToSRGB() {

			this.copyLinearToSRGB( this );

			return this;

		}

		getHex() {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		}

		getHexString() {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		}

		getHSL( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			const r = this.r, g = this.g, b = this.b;

			const max = Math.max( r, g, b );
			const min = Math.min( r, g, b );

			let hue, saturation;
			const lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				const delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		}

		getStyle() {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		}

		offsetHSL( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		}

		add( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		}

		addColors( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		}

		addScalar( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		}

		sub( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		}

		multiply( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		}

		multiplyScalar( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		}

		lerp( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		}

		lerpColors( color1, color2, alpha ) {

			this.r = color1.r + ( color2.r - color1.r ) * alpha;
			this.g = color1.g + ( color2.g - color1.g ) * alpha;
			this.b = color1.b + ( color2.b - color1.b ) * alpha;

			return this;

		}

		lerpHSL( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			const h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
			const s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
			const l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		}

		equals( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		}

		fromArray( array, offset = 0 ) {

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		}

		fromBufferAttribute( attribute, index ) {

			this.r = attribute.getX( index );
			this.g = attribute.getY( index );
			this.b = attribute.getZ( index );

			if ( attribute.normalized === true ) {

				// assuming Uint8Array

				this.r /= 255;
				this.g /= 255;
				this.b /= 255;

			}

			return this;

		}

		toJSON() {

			return this.getHex();

		}

	}

	Color.NAMES = _colorKeywords;

	Color.prototype.isColor = true;
	Color.prototype.r = 1;
	Color.prototype.g = 1;
	Color.prototype.b = 1;

	const _vector$1 = new Vector3();
	const _vector2 = new Vector2();

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = colors.length; i < l; i ++ ) {

				let color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			const array = this.array;
			let offset = 0;

			for ( let i = 0, l = vectors.length; i < l; i ++ ) {

				let vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		applyMatrix3: function ( m ) {

			if ( this.itemSize === 2 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector2.fromBufferAttribute( this, i );
					_vector2.applyMatrix3( m );

					this.setXY( i, _vector2.x, _vector2.y );

				}

			} else if ( this.itemSize === 3 ) {

				for ( let i = 0, l = this.count; i < l; i ++ ) {

					_vector$1.fromBufferAttribute( this, i );
					_vector$1.applyMatrix3( m );

					this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

				}

			}

			return this;

		},

		applyMatrix4: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$1.x = this.getX( i );
				_vector$1.y = this.getY( i );
				_vector$1.z = this.getZ( i );

				_vector$1.applyMatrix4( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		},

		applyNormalMatrix: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$1.x = this.getX( i );
				_vector$1.y = this.getY( i );
				_vector$1.z = this.getZ( i );

				_vector$1.applyNormalMatrix( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		},

		transformDirection: function ( m ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$1.x = this.getX( i );
				_vector$1.y = this.getY( i );
				_vector$1.z = this.getZ( i );

				_vector$1.transformDirection( m );

				this.setXYZ( i, _vector$1.x, _vector$1.y, _vector$1.z );

			}

			return this;

		},

		set: function ( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		},

		toJSON: function () {

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call( this.array ),
				normalized: this.normalized
			};

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

	function Float16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
	Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	class Matrix4 {

		constructor() {

			this.elements = [

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		clone() {

			return new Matrix4().fromArray( this.elements );

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		}

		copyPosition( m ) {

			const te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		}

		setFromMatrix3( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 3 ], me[ 6 ], 0,
				me[ 1 ], me[ 4 ], me[ 7 ], 0,
				me[ 2 ], me[ 5 ], me[ 8 ], 0,
				0, 0, 0, 1

			);

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		}

		makeBasis( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		}

		extractRotation( m ) {

			// this method does not support reflection matrices

			const te = this.elements;
			const me = m.elements;

			const scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
			const scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
			const scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromEuler( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			const te = this.elements;

			const x = euler.x, y = euler.y, z = euler.z;
			const a = Math.cos( x ), b = Math.sin( x );
			const c = Math.cos( y ), d = Math.sin( y );
			const e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				const ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				const ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		}

		makeRotationFromQuaternion( q ) {

			return this.compose( _zero, q, _one );

		}

		lookAt( eye, target, up ) {

			const te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		}

		multiply( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		}

		transpose() {

			const te = this.elements;
			let tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		}

		setPosition( x, y, z ) {

			const te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		}

		invert() {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
				n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
				n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
				n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		}

		scale( v ) {

			const te = this.elements;
			const x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		}

		getMaxScaleOnAxis() {

			const te = this.elements;

			const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		}

		makeTranslation( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationX( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationY( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		}

		makeRotationZ( theta ) {

			const c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeRotationAxis( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			const c = Math.cos( angle );
			const s = Math.sin( angle );
			const t = 1 - c;
			const x = axis.x, y = axis.y, z = axis.z;
			const tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeScale( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		}

		makeShear( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		}

		compose( position, quaternion, scale ) {

			const te = this.elements;

			const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			const x2 = x + x,	y2 = y + y, z2 = z + z;
			const xx = x * x2, xy = x * y2, xz = x * z2;
			const yy = y * y2, yz = y * z2, zz = z * z2;
			const wx = w * x2, wy = w * y2, wz = w * z2;

			const sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		}

		decompose( position, quaternion, scale ) {

			const te = this.elements;

			let sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			const sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			const sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			const det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			const invSX = 1 / sx;
			const invSY = 1 / sy;
			const invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		}

		makePerspective( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			const te = this.elements;
			const x = 2 * near / ( right - left );
			const y = 2 * near / ( top - bottom );

			const a = ( right + left ) / ( right - left );
			const b = ( top + bottom ) / ( top - bottom );
			const c = - ( far + near ) / ( far - near );
			const d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		}

		makeOrthographic( left, right, top, bottom, near, far ) {

			const te = this.elements;
			const w = 1.0 / ( right - left );
			const h = 1.0 / ( top - bottom );
			const p = 1.0 / ( far - near );

			const x = ( right + left ) * w;
			const y = ( top + bottom ) * h;
			const z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	}

	Matrix4.prototype.isMatrix4 = true;

	const _v1 = /*@__PURE__*/ new Vector3();
	const _m1 = /*@__PURE__*/ new Matrix4();
	const _zero = /*@__PURE__*/ new Vector3( 0, 0, 0 );
	const _one = /*@__PURE__*/ new Vector3( 1, 1, 1 );
	const _x = /*@__PURE__*/ new Vector3();
	const _y = /*@__PURE__*/ new Vector3();
	const _z = /*@__PURE__*/ new Vector3();

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			const listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			const listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				const index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			const listeners = this._listeners;
			const listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				// Make a copy, in case listeners are removed while iterating.
				const array = listenerArray.slice( 0 );

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	const _matrix = /*@__PURE__*/ new Matrix4();
	const _quaternion$1 = /*@__PURE__*/ new Quaternion();

	class Euler {

		constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order;

		}

		get x() {

			return this._x;

		}

		set x( value ) {

			this._x = value;
			this._onChangeCallback();

		}

		get y() {

			return this._y;

		}

		set y( value ) {

			this._y = value;
			this._onChangeCallback();

		}

		get z() {

			return this._z;

		}

		set z( value ) {

			this._z = value;
			this._onChangeCallback();

		}

		get order() {

			return this._order;

		}

		set order( value ) {

			this._order = value;
			this._onChangeCallback();

		}

		set( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		}

		clone() {

			return new this.constructor( this._x, this._y, this._z, this._order );

		}

		copy( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		}

		setFromRotationMatrix( m, order, update ) {

			const clamp = MathUtils.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			const te = m.elements;
			const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			switch ( order ) {

				case 'XYZ':

					this._y = Math.asin( clamp( m13, - 1, 1 ) );

					if ( Math.abs( m13 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );

					} else {

						this._x = Math.atan2( m32, m22 );
						this._z = 0;

					}

					break;

				case 'YXZ':

					this._x = Math.asin( - clamp( m23, - 1, 1 ) );

					if ( Math.abs( m23 ) < 0.9999999 ) {

						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );

					} else {

						this._y = Math.atan2( - m31, m11 );
						this._z = 0;

					}

					break;

				case 'ZXY':

					this._x = Math.asin( clamp( m32, - 1, 1 ) );

					if ( Math.abs( m32 ) < 0.9999999 ) {

						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );

					} else {

						this._y = 0;
						this._z = Math.atan2( m21, m11 );

					}

					break;

				case 'ZYX':

					this._y = Math.asin( - clamp( m31, - 1, 1 ) );

					if ( Math.abs( m31 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );

					} else {

						this._x = 0;
						this._z = Math.atan2( - m12, m22 );

					}

					break;

				case 'YZX':

					this._z = Math.asin( clamp( m21, - 1, 1 ) );

					if ( Math.abs( m21 ) < 0.9999999 ) {

						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );

					} else {

						this._x = 0;
						this._y = Math.atan2( m13, m33 );

					}

					break;

				case 'XZY':

					this._z = Math.asin( - clamp( m12, - 1, 1 ) );

					if ( Math.abs( m12 ) < 0.9999999 ) {

						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );

					} else {

						this._x = Math.atan2( - m23, m33 );
						this._y = 0;

					}

					break;

				default:

					console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		}

		setFromQuaternion( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		}

		setFromVector3( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		}

		reorder( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		}

		equals( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		}

		fromArray( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		}

		toArray( array = [], offset = 0 ) {

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		}

		toVector3( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		}

		_onChange( callback ) {

			this._onChangeCallback = callback;

			return this;

		}

		_onChangeCallback() {}

	}

	Euler.prototype.isEuler = true;

	Euler.DefaultOrder = 'XYZ';
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	class Layers {

		constructor() {

			this.mask = 1 | 0;

		}

		set( channel ) {

			this.mask = 1 << channel | 0;

		}

		enable( channel ) {

			this.mask |= 1 << channel | 0;

		}

		enableAll() {

			this.mask = 0xffffffff | 0;

		}

		toggle( channel ) {

			this.mask ^= 1 << channel | 0;

		}

		disable( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		}

		disableAll() {

			this.mask = 0;

		}

		test( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	}

	class Matrix3 {

		constructor() {

			this.elements = [

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			];

			if ( arguments.length > 0 ) {

				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

			}

		}

		set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			const te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		}

		identity() {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		}

		copy( m ) {

			const te = this.elements;
			const me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		}

		extractBasis( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		}

		setFromMatrix4( m ) {

			const me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		}

		multiply( m ) {

			return this.multiplyMatrices( this, m );

		}

		premultiply( m ) {

			return this.multiplyMatrices( m, this );

		}

		multiplyMatrices( a, b ) {

			const ae = a.elements;
			const be = b.elements;
			const te = this.elements;

			const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		}

		multiplyScalar( s ) {

			const te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		}

		determinant() {

			const te = this.elements;

			const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		}

		invert() {

			const te = this.elements,

				n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
				n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
				n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

			const detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		}

		transpose() {

			let tmp;
			const m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		}

		getNormalMatrix( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).invert().transpose();

		}

		transposeIntoArray( r ) {

			const m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		}

		setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

			const c = Math.cos( rotation );
			const s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

			return this;

		}

		scale( sx, sy ) {

			const te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		}

		rotate( theta ) {

			const c = Math.cos( theta );
			const s = Math.sin( theta );

			const te = this.elements;

			const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		}

		translate( tx, ty ) {

			const te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		}

		equals( matrix ) {

			const te = this.elements;
			const me = matrix.elements;

			for ( let i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		}

		fromArray( array, offset = 0 ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

		clone() {

			return new this.constructor().fromArray( this.elements );

		}

	}

	Matrix3.prototype.isMatrix3 = true;

	let _object3DId = 0;

	const _v1$1 = new Vector3();
	const _q1 = new Quaternion();
	const _m1$1 = new Matrix4();
	const _target = new Vector3();

	const _position = new Vector3();
	const _scale = new Vector3();
	const _quaternion$2 = new Quaternion();

	const _xAxis = new Vector3( 1, 0, 0 );
	const _yAxis = new Vector3( 0, 1, 0 );
	const _zAxis = new Vector3( 0, 0, 1 );

	const _addedEvent = { type: 'added' };
	const _removedEvent = { type: 'removed' };

	function Object3D() {

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		const position = new Vector3();
		const rotation = new Euler();
		const quaternion = new Quaternion();
		const scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.animations = [];

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix4: function ( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function ( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		},

		rotateOnWorldAxis: function ( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		},

		rotateX: function ( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		},

		rotateY: function ( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		},

		rotateZ: function ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		},

		translateOnAxis: function ( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$1.multiplyScalar( distance ) );

			return this;

		},

		translateX: function ( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		},

		translateY: function ( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		},

		translateZ: function ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		},

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function ( vector ) {

			return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

		},

		lookAt: function ( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			const parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || this.isLight ) {

				_m1$1.lookAt( _position, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.invert() );

			}

		},

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
				return this;

			}

			if ( object && object.isObject3D ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( let i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			const index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		},

		clear: function () {

			for ( let i = 0; i < this.children.length; i ++ ) {

				const object = this.children[ i ];

				object.parent = null;

				object.dispatchEvent( _removedEvent );

			}

			this.children.length = 0;

			return this;


		},

		attach: function ( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			this.updateWorldMatrix( true, false );

			_m1$1.copy( this.matrixWorld ).invert();

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			this.add( object );

			object.updateWorldMatrix( false, true );

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( let i = 0, l = this.children.length; i < l; i ++ ) {

				const child = this.children[ i ];
				const object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
				target = new Quaternion();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, target, _scale );

			return target;

		},

		getWorldScale: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			this.matrixWorld.decompose( _position, _quaternion$2, target );

			return target;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			const parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			const parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				const children = this.children;

				for ( let i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			const output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {},
					skeletons: {},
					animations: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			const object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			// object specific properties

			if ( this.isInstancedMesh ) {

				object.type = 'InstancedMesh';
				object.count = this.count;
				object.instanceMatrix = this.instanceMatrix.toJSON();

			}

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || this.isLine || this.isPoints ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				const parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					const shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( let i = 0, l = shapes.length; i < l; i ++ ) {

							const shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.isSkinnedMesh ) {

				object.bindMode = this.bindMode;
				object.bindMatrix = this.bindMatrix.toArray();

				if ( this.skeleton !== undefined ) {

					serialize( meta.skeletons, this.skeleton );

					object.skeleton = this.skeleton.uuid;

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					const uuids = [];

					for ( let i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( let i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			//

			if ( this.animations.length > 0 ) {

				object.animations = [];

				for ( let i = 0; i < this.animations.length; i ++ ) {

					const animation = this.animations[ i ];

					object.animations.push( serialize( meta.animations, animation ) );

				}

			}

			if ( isRootObject ) {

				const geometries = extractFromCache( meta.geometries );
				const materials = extractFromCache( meta.materials );
				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );
				const shapes = extractFromCache( meta.shapes );
				const skeletons = extractFromCache( meta.skeletons );
				const animations = extractFromCache( meta.animations );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
				if ( skeletons.length > 0 ) output.skeletons = skeletons;
				if ( animations.length > 0 ) output.animations = animations;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				const values = [];
				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive = true ) {

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.rotation.order = source.rotation.order;
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( let i = 0; i < source.children.length; i ++ ) {

					const child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	class Group extends Object3D {

		constructor() {

			super();

			this.type = 'Group';

		}

	}

	Group.prototype.isGroup = true;

	class Box3 {

		constructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromArray( array ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const x = array[ i ];
				const y = array[ i + 1 ];
				const z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromBufferAttribute( attribute ) {

			let minX = + Infinity;
			let minY = + Infinity;
			let minZ = + Infinity;

			let maxX = - Infinity;
			let maxY = - Infinity;
			let maxZ = - Infinity;

			for ( let i = 0, l = attribute.count; i < l; i ++ ) {

				const x = attribute.getX( i );
				const y = attribute.getY( i );
				const z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$2.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		setFromObject( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		expandByObject( object ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			const geometry = object.geometry;

			if ( geometry !== undefined ) {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box.copy( geometry.boundingBox );
				_box.applyMatrix4( object.matrixWorld );

				this.union( _box );

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ] );

			}

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		}

		intersectsBox( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		}

		intersectsSphere( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$2 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$2.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		intersectsPlane( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			let min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		}

		intersectsTriangle( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0.subVectors( triangle.a, _center );
			_v1$2.subVectors( triangle.b, _center );
			_v2.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$2, _v0 );
			_f1.subVectors( _v2, _v1$2 );
			_f2.subVectors( _v0, _v2 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			let axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0, _v1$2, _v2, _extents );

		}

		clampPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$2.copy( point ).clamp( this.min, this.max );

			return clampedPoint.sub( point ).length();

		}

		getBoundingSphere( target ) {

			if ( target === undefined ) {

				console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
				//target = new Sphere(); // removed to avoid cyclic dependency

			}

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$2 ).length() * 0.5;

			return target;

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	Box3.prototype.isBox3 = true;

	const _points = [
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3(),
		/*@__PURE__*/ new Vector3()
	];

	const _vector$2 = /*@__PURE__*/ new Vector3();

	const _box = /*@__PURE__*/ new Box3();

	// triangle centered vertices

	const _v0 = /*@__PURE__*/ new Vector3();
	const _v1$2 = /*@__PURE__*/ new Vector3();
	const _v2 = /*@__PURE__*/ new Vector3();

	// triangle edge vectors

	const _f0 = /*@__PURE__*/ new Vector3();
	const _f1 = /*@__PURE__*/ new Vector3();
	const _f2 = /*@__PURE__*/ new Vector3();

	const _center = /*@__PURE__*/ new Vector3();
	const _extents = /*@__PURE__*/ new Vector3();
	const _triangleNormal = /*@__PURE__*/ new Vector3();
	const _testAxis = /*@__PURE__*/ new Vector3();

	function satForAxes( axes, v0, v1, v2, extents ) {

		for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the seperating axis
			const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the seperating axis
			const p0 = v0.dot( _testAxis );
			const p1 = v1.dot( _testAxis );
			const p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;

			}

		}

		return true;

	}

	const _box$1 = /*@__PURE__*/ new Box3();

	class Sphere {

		constructor( center = new Vector3(), radius = - 1 ) {

			this.center = center;
			this.radius = radius;

		}

		set( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		}

		setFromPoints( points, optionalCenter ) {

			const center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$1.setFromPoints( points ).getCenter( center );

			}

			let maxRadiusSq = 0;

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		}

		copy( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		}

		isEmpty() {

			return ( this.radius < 0 );

		}

		makeEmpty() {

			this.center.set( 0, 0, 0 );
			this.radius = - 1;

			return this;

		}

		containsPoint( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		}

		distanceToPoint( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		}

		intersectsSphere( sphere ) {

			const radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		}

		intersectsBox( box ) {

			return box.intersectsSphere( this );

		}

		intersectsPlane( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		}

		clampPoint( point, target ) {

			const deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		}

		getBoundingBox( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			if ( this.isEmpty() ) {

				// Empty sphere produces empty bounding box
				target.makeEmpty();
				return target;

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		}

		applyMatrix4( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		}

		translate( offset ) {

			this.center.add( offset );

			return this;

		}

		equals( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector$3 = /*@__PURE__*/ new Vector3();
	const _segCenter = /*@__PURE__*/ new Vector3();
	const _segDir = /*@__PURE__*/ new Vector3();
	const _diff = /*@__PURE__*/ new Vector3();

	const _edge1 = /*@__PURE__*/ new Vector3();
	const _edge2 = /*@__PURE__*/ new Vector3();
	const _normal = /*@__PURE__*/ new Vector3();

	class Ray {

		constructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {

			this.origin = origin;
			this.direction = direction;

		}

		set( origin, direction ) {

			this.origin.copy( origin );
			this.direction.copy( direction );

			return this;

		}

		copy( ray ) {

			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );

			return this;

		}

		at( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

		}

		lookAt( v ) {

			this.direction.copy( v ).sub( this.origin ).normalize();

			return this;

		}

		recast( t ) {

			this.origin.copy( this.at( t, _vector$3 ) );

			return this;

		}

		closestPointToPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			target.subVectors( point, this.origin );

			const directionDistance = target.dot( this.direction );

			if ( directionDistance < 0 ) {

				return target.copy( this.origin );

			}

			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		}

		distanceToPoint( point ) {

			return Math.sqrt( this.distanceSqToPoint( point ) );

		}

		distanceSqToPoint( point ) {

			const directionDistance = _vector$3.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			_vector$3.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return _vector$3.distanceToSquared( point );

		}

		distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			_segDir.copy( v1 ).sub( v0 ).normalize();
			_diff.copy( this.origin ).sub( _segCenter );

			const segExtent = v0.distanceTo( v1 ) * 0.5;
			const a01 = - this.direction.dot( _segDir );
			const b0 = _diff.dot( this.direction );
			const b1 = - _diff.dot( _segDir );
			const c = _diff.lengthSq();
			const det = Math.abs( 1 - a01 * a01 );
			let s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							const invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

			}

			return sqrDist;

		}

		intersectSphere( sphere, target ) {

			_vector$3.subVectors( sphere.center, this.origin );
			const tca = _vector$3.dot( this.direction );
			const d2 = _vector$3.dot( _vector$3 ) - tca * tca;
			const radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			const thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			const t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			const t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, target );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, target );

		}

		intersectsSphere( sphere ) {

			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

		}

		distanceToPlane( plane ) {

			const denominator = plane.normal.dot( this.direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {

					return 0;

				}

				// Null is preferable to undefined since undefined means.... it is undefined

				return null;

			}

			const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

			// Return if the ray never intersects the plane

			return t >= 0 ? t : null;

		}

		intersectPlane( plane, target ) {

			const t = this.distanceToPlane( plane );

			if ( t === null ) {

				return null;

			}

			return this.at( t, target );

		}

		intersectsPlane( plane ) {

			// check if the ray lies on the plane first

			const distToPoint = plane.distanceToPoint( this.origin );

			if ( distToPoint === 0 ) {

				return true;

			}

			const denominator = plane.normal.dot( this.direction );

			if ( denominator * distToPoint < 0 ) {

				return true;

			}

			// ray origin is behind the plane (and is pointing behind it)

			return false;

		}

		intersectBox( box, target ) {

			let tmin, tmax, tymin, tymax, tzmin, tzmax;

			const invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;

			const origin = this.origin;

			if ( invdirx >= 0 ) {

				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;

			} else {

				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;

			}

			if ( invdiry >= 0 ) {

				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;

			} else {

				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;

			}

			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN

			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

			if ( invdirz >= 0 ) {

				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;

			} else {

				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;

			}

			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

			//return point closest to the ray (positive side)

			if ( tmax < 0 ) return null;

			return this.at( tmin >= 0 ? tmin : tmax, target );

		}

		intersectsBox( box ) {

			return this.intersectBox( box, _vector$3 ) !== null;

		}

		intersectTriangle( a, b, c, backfaceCulling, target ) {

			// Compute the offset origin, edges, and normal.

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			_edge1.subVectors( b, a );
			_edge2.subVectors( c, a );
			_normal.crossVectors( _edge1, _edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			let DdN = this.direction.dot( _normal );
			let sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			_diff.subVectors( this.origin, a );
			const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			const QdN = - sign * _diff.dot( _normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, target );

		}

		applyMatrix4( matrix4 ) {

			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );

			return this;

		}

		equals( ray ) {

			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _vector1 = /*@__PURE__*/ new Vector3();
	const _vector2$1 = /*@__PURE__*/ new Vector3();
	const _normalMatrix = /*@__PURE__*/ new Matrix3();

	class Plane {

		constructor( normal = new Vector3( 1, 0, 0 ), constant = 0 ) {

			// normal is assumed to be normalized

			this.normal = normal;
			this.constant = constant;

		}

		set( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		}

		setComponents( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		}

		setFromNormalAndCoplanarPoint( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		}

		setFromCoplanarPoints( a, b, c ) {

			const normal = _vector1.subVectors( c, b ).cross( _vector2$1.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		}

		copy( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		}

		normalize() {

			// Note: will lead to a divide by zero if the plane is invalid.

			const inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		}

		negate() {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		}

		distanceToPoint( point ) {

			return this.normal.dot( point ) + this.constant;

		}

		distanceToSphere( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		}

		projectPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		}

		intersectLine( line, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			const direction = line.delta( _vector1 );

			const denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		}

		intersectsLine( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			const startSign = this.distanceToPoint( line.start );
			const endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		}

		intersectsBox( box ) {

			return box.intersectsPlane( this );

		}

		intersectsSphere( sphere ) {

			return sphere.intersectsPlane( this );

		}

		coplanarPoint( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		}

		applyMatrix4( matrix, optionalNormalMatrix ) {

			const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		}

		translate( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		}

		equals( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	Plane.prototype.isPlane = true;

	const _v0$1 = /*@__PURE__*/ new Vector3();
	const _v1$3 = /*@__PURE__*/ new Vector3();
	const _v2$1 = /*@__PURE__*/ new Vector3();
	const _v3 = /*@__PURE__*/ new Vector3();

	const _vab = /*@__PURE__*/ new Vector3();
	const _vac = /*@__PURE__*/ new Vector3();
	const _vbc = /*@__PURE__*/ new Vector3();
	const _vap = /*@__PURE__*/ new Vector3();
	const _vbp = /*@__PURE__*/ new Vector3();
	const _vcp = /*@__PURE__*/ new Vector3();

	class Triangle {

		constructor( a = new Vector3(), b = new Vector3(), c = new Vector3() ) {

			this.a = a;
			this.b = b;
			this.c = c;

		}

		static getNormal( a, b, c, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getNormal() target is now required' );
				target = new Vector3();

			}

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			const targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		}

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		static getBarycoord( point, a, b, c, target ) {

			_v0$1.subVectors( c, a );
			_v1$3.subVectors( b, a );
			_v2$1.subVectors( point, a );

			const dot00 = _v0$1.dot( _v0$1 );
			const dot01 = _v0$1.dot( _v1$3 );
			const dot02 = _v0$1.dot( _v2$1 );
			const dot11 = _v1$3.dot( _v1$3 );
			const dot12 = _v1$3.dot( _v2$1 );

			const denom = ( dot00 * dot11 - dot01 * dot01 );

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
				target = new Vector3();

			}

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			const invDenom = 1 / denom;
			const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		}

		static containsPoint( point, a, b, c ) {

			this.getBarycoord( point, a, b, c, _v3 );

			return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

		}

		static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3 );

			target.set( 0, 0 );
			target.addScaledVector( uv1, _v3.x );
			target.addScaledVector( uv2, _v3.y );
			target.addScaledVector( uv3, _v3.z );

			return target;

		}

		static isFrontFacing( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1$3.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

		}

		set( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		}

		setFromPointsAndIndices( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		}

		getArea() {

			_v0$1.subVectors( this.c, this.b );
			_v1$3.subVectors( this.a, this.b );

			return _v0$1.cross( _v1$3 ).length() * 0.5;

		}

		getMidpoint( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		}

		getNormal( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		}

		getPlane( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Plane();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		}

		getBarycoord( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		}

		getUV( point, uv1, uv2, uv3, target ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		}

		containsPoint( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		}

		isFrontFacing( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		}

		intersectsBox( box ) {

			return box.intersectsTriangle( this );

		}

		closestPointToPoint( p, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			const a = this.a, b = this.b, c = this.c;
			let v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			const d1 = _vab.dot( _vap );
			const d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			const d3 = _vab.dot( _vbp );
			const d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			const vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			const d5 = _vab.dot( _vcp );
			const d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			const vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			const va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			const denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		}

		equals( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	}

	let materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

		customProgramCacheKey: function () {

			return this.onBeforeCompile.toString();

		},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( const key in values ) {

				const newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				const currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			const isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			const data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

				data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

				data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

			}

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

			if ( this.lightMap && this.lightMap.isTexture ) {

				data.lightMap = this.lightMap.toJSON( meta ).uuid;
				data.lightMapIntensity = this.lightMapIntensity;

			}

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.envMap && this.envMap.isTexture ) {

				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
				data.refractionRatio = this.refractionRatio;

				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

			}

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.morphNormals === true ) data.morphNormals = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.flatShading === true ) data.flatShading = this.flatShading;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				const values = [];

				for ( const key in cache ) {

					const data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				const textures = extractFromCache( meta.textures );
				const images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;

			this.blending = source.blending;
			this.side = source.side;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			const srcPlanes = source.clippingPlanes;
			let dstPlanes = null;

			if ( srcPlanes !== null ) {

				const n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( let i = 0; i !== n; ++ i ) {

					dstPlanes[ i ] = srcPlanes[ i ].clone();

				}

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	Object.defineProperty( Material.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */

	class MeshBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshBasicMaterial';

			this.color = new Color( 0xffffff ); // emissive

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			return this;

		}

	}

	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

	function arrayMin( array ) {

		if ( array.length === 0 ) return Infinity;

		let min = array[ 0 ];

		for ( let i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] < min ) min = array[ i ];

		}

		return min;

	}

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		let max = array[ 0 ];

		for ( let i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	const TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: Uint8ClampedArray,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};

	function getTypedArray( type, buffer ) {

		return new TYPED_ARRAYS[ type ]( buffer );

	}

	let _id = 0;

	const _m1$2 = new Matrix4();
	const _obj = new Object3D();
	const _offset = new Vector3();
	const _box$2 = new Box3();
	const _boxMorphTargets = new Box3();
	const _vector$4 = new Vector3();

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: _id ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

			return this;

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		setAttribute: function ( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		},

		deleteAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		hasAttribute: function ( name ) {

			return this.attributes[ name ] !== undefined;

		},

		addGroup: function ( start, count, materialIndex = 0 ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix4: function ( matrix ) {

			const position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			const normal = this.attributes.normal;

			if ( normal !== undefined ) {

				const normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			const tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function ( angle ) {

			// rotate geometry around world x-axis

			_m1$2.makeRotationX( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateY: function ( angle ) {

			// rotate geometry around world y-axis

			_m1$2.makeRotationY( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateZ: function ( angle ) {

			// rotate geometry around world z-axis

			_m1$2.makeRotationZ( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		translate: function ( x, y, z ) {

			// translate geometry

			_m1$2.makeTranslation( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		scale: function ( x, y, z ) {

			// scale geometry

			_m1$2.makeScale( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		lookAt: function ( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		},

		setFromPoints: function ( points ) {

			const position = [];

			for ( let i = 0, l = points.length; i < l; i ++ ) {

				const point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingBox.set(
					new Vector3( - Infinity, - Infinity, - Infinity ),
					new Vector3( + Infinity, + Infinity, + Infinity )
				);

				return;

			}

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_box$2.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( this.boundingBox.min, _box$2.min );
							this.boundingBox.expandByPoint( _vector$4 );

							_vector$4.addVectors( this.boundingBox.max, _box$2.max );
							this.boundingBox.expandByPoint( _vector$4 );

						} else {

							this.boundingBox.expandByPoint( _box$2.min );
							this.boundingBox.expandByPoint( _box$2.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			const position = this.attributes.position;
			const morphAttributesPosition = this.morphAttributes.position;

			if ( position && position.isGLBufferAttribute ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

				this.boundingSphere.set( new Vector3(), Infinity );

				return;

			}

			if ( position ) {

				// first, find the center of the bounding sphere

				const center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
							_box$2.expandByPoint( _vector$4 );

							_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
							_box$2.expandByPoint( _vector$4 );

						} else {

							_box$2.expandByPoint( _boxMorphTargets.min );
							_box$2.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$2.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				let maxRadiusSq = 0;

				for ( let i = 0, il = position.count; i < il; i ++ ) {

					_vector$4.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						const morphAttribute = morphAttributesPosition[ i ];
						const morphTargetsRelative = this.morphTargetsRelative;

						for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$4.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$4.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		},

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeTangents: function () {

			const index = this.index;
			const attributes = this.attributes;

			// based on http://www.terathon.com/code/tangent.html
			// (per vertex tangents)

			if ( index === null ||
				 attributes.position === undefined ||
				 attributes.normal === undefined ||
				 attributes.uv === undefined ) {

				console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
				return;

			}

			const indices = index.array;
			const positions = attributes.position.array;
			const normals = attributes.normal.array;
			const uvs = attributes.uv.array;

			const nVertices = positions.length / 3;

			if ( attributes.tangent === undefined ) {

				this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

			}

			const tangents = attributes.tangent.array;

			const tan1 = [], tan2 = [];

			for ( let i = 0; i < nVertices; i ++ ) {

				tan1[ i ] = new Vector3();
				tan2[ i ] = new Vector3();

			}

			const vA = new Vector3(),
				vB = new Vector3(),
				vC = new Vector3(),

				uvA = new Vector2(),
				uvB = new Vector2(),
				uvC = new Vector2(),

				sdir = new Vector3(),
				tdir = new Vector3();

			function handleTriangle( a, b, c ) {

				vA.fromArray( positions, a * 3 );
				vB.fromArray( positions, b * 3 );
				vC.fromArray( positions, c * 3 );

				uvA.fromArray( uvs, a * 2 );
				uvB.fromArray( uvs, b * 2 );
				uvC.fromArray( uvs, c * 2 );

				vB.sub( vA );
				vC.sub( vA );

				uvB.sub( uvA );
				uvC.sub( uvA );

				const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

				// silently ignore degenerate uv triangles having coincident or colinear vertices

				if ( ! isFinite( r ) ) return;

				sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
				tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

				tan1[ a ].add( sdir );
				tan1[ b ].add( sdir );
				tan1[ c ].add( sdir );

				tan2[ a ].add( tdir );
				tan2[ b ].add( tdir );
				tan2[ c ].add( tdir );

			}

			let groups = this.groups;

			if ( groups.length === 0 ) {

				groups = [ {
					start: 0,
					count: indices.length
				} ];

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleTriangle(
						indices[ j + 0 ],
						indices[ j + 1 ],
						indices[ j + 2 ]
					);

				}

			}

			const tmp = new Vector3(), tmp2 = new Vector3();
			const n = new Vector3(), n2 = new Vector3();

			function handleVertex( v ) {

				n.fromArray( normals, v * 3 );
				n2.copy( n );

				const t = tan1[ v ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( n2, t );
				const test = tmp2.dot( tan2[ v ] );
				const w = ( test < 0.0 ) ? - 1.0 : 1.0;

				tangents[ v * 4 ] = tmp.x;
				tangents[ v * 4 + 1 ] = tmp.y;
				tangents[ v * 4 + 2 ] = tmp.z;
				tangents[ v * 4 + 3 ] = w;

			}

			for ( let i = 0, il = groups.length; i < il; ++ i ) {

				const group = groups[ i ];

				const start = group.start;
				const count = group.count;

				for ( let j = start, jl = start + count; j < jl; j += 3 ) {

					handleVertex( indices[ j + 0 ] );
					handleVertex( indices[ j + 1 ] );
					handleVertex( indices[ j + 2 ] );

				}

			}

		},

		computeVertexNormals: function () {

			const index = this.index;
			const positionAttribute = this.getAttribute( 'position' );

			if ( positionAttribute !== undefined ) {

				let normalAttribute = this.getAttribute( 'normal' );

				if ( normalAttribute === undefined ) {

					normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
					this.setAttribute( 'normal', normalAttribute );

				} else {

					// reset existing normals to zero

					for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

						normalAttribute.setXYZ( i, 0, 0, 0 );

					}

				}

				const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
				const cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					for ( let i = 0, il = index.count; i < il; i += 3 ) {

						const vA = index.getX( i + 0 );
						const vB = index.getX( i + 1 );
						const vC = index.getX( i + 2 );

						pA.fromBufferAttribute( positionAttribute, vA );
						pB.fromBufferAttribute( positionAttribute, vB );
						pC.fromBufferAttribute( positionAttribute, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						nA.fromBufferAttribute( normalAttribute, vA );
						nB.fromBufferAttribute( normalAttribute, vB );
						nC.fromBufferAttribute( normalAttribute, vC );

						nA.add( cb );
						nB.add( cb );
						nC.add( cb );

						normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
						normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
						normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

						pA.fromBufferAttribute( positionAttribute, i + 0 );
						pB.fromBufferAttribute( positionAttribute, i + 1 );
						pC.fromBufferAttribute( positionAttribute, i + 2 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
						normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

					}

				}

				this.normalizeNormals();

				normalAttribute.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				const attribute1 = attributes[ key ];
				const attributeArray1 = attribute1.array;

				const attribute2 = geometry.attributes[ key ];
				const attributeArray2 = attribute2.array;

				const attributeOffset = attribute2.itemSize * offset;
				const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			const normals = this.attributes.normal;

			for ( let i = 0, il = normals.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( normals, i );

				_vector$4.normalize();

				normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

			}

		},

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				const array = attribute.array;
				const itemSize = attribute.itemSize;
				const normalized = attribute.normalized;

				const array2 = new array.constructor( indices.length * itemSize );

				let index = 0, index2 = 0;

				for ( let i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( let j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize, normalized );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
				return this;

			}

			const geometry2 = new BufferGeometry();

			const indices = this.index.array;
			const attributes = this.attributes;

			// attributes

			for ( const name in attributes ) {

				const attribute = attributes[ name ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			const morphAttributes = this.morphAttributes;

			for ( const name in morphAttributes ) {

				const morphArray = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

					const attribute = morphAttribute[ i ];

					const newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			const groups = this.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				const parameters = this.parameters;

				for ( const key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			const index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			const attributes = this.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				const attributeData = attribute.toJSON( data.data );

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				data.data.attributes[ key ] = attributeData;

			}

			const morphAttributes = {};
			let hasMorphAttributes = false;

			for ( const key in this.morphAttributes ) {

				const attributeArray = this.morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];

					const attributeData = attribute.toJSON( data.data );

					if ( attribute.name !== '' ) attributeData.name = attribute.name;

					array.push( attributeData );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			const groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			const boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 const parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 const values = [];

			 for ( const key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 const geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// used for storing cloned, shared data

			const data = {};

			// name

			this.name = source.name;

			// index

			const index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone( data ) );

			}

			// attributes

			const attributes = source.attributes;

			for ( const name in attributes ) {

				const attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone( data ) );

			}

			// morph attributes

			const morphAttributes = source.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = [];
				const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone( data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			const groups = source.groups;

			for ( let i = 0, l = groups.length; i < l; i ++ ) {

				const group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			const boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			const boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	const _inverseMatrix = new Matrix4();
	const _ray = new Ray();
	const _sphere = new Sphere();

	const _vA = new Vector3();
	const _vB = new Vector3();
	const _vC = new Vector3();

	const _tempA = new Vector3();
	const _tempB = new Vector3();
	const _tempC = new Vector3();

	const _morphA = new Vector3();
	const _morphB = new Vector3();
	const _morphC = new Vector3();

	const _uvA = new Vector2();
	const _uvB = new Vector2();
	const _uvC = new Vector2();

	const _intersectionPoint = new Vector3();
	const _intersectionPointWorld = new Vector3();

	function Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const material = this.material;
			const matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

			//

			_inverseMatrix.copy( matrixWorld ).invert();
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			let intersection;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const position = geometry.attributes.position;
				const morphPosition = geometry.morphAttributes.position;
				const morphTargetsRelative = geometry.morphTargetsRelative;
				const uv = geometry.attributes.uv;
				const uv2 = geometry.attributes.uv2;
				const groups = geometry.groups;
				const drawRange = geometry.drawRange;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = index.getX( j );
								const b = index.getX( j + 1 );
								const c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = index.getX( i );
							const b = index.getX( i + 1 );
							const c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( let i = 0, il = groups.length; i < il; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							const start = Math.max( group.start, drawRange.start );
							const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( let j = start, jl = end; j < jl; j += 3 ) {

								const a = j;
								const b = j + 1;
								const c = j + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						const start = Math.max( 0, drawRange.start );
						const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( let i = start, il = end; i < il; i += 3 ) {

							const a = i;
							const b = i + 1;
							const c = i + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	} );

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		let intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA.fromBufferAttribute( position, a );
		_vB.fromBufferAttribute( position, b );
		_vC.fromBufferAttribute( position, c );

		const morphInfluences = object.morphTargetInfluences;

		if ( material.morphTargets && morphPosition && morphInfluences ) {

			_morphA.set( 0, 0, 0 );
			_morphB.set( 0, 0, 0 );
			_morphC.set( 0, 0, 0 );

			for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

				const influence = morphInfluences[ i ];
				const morphAttribute = morphPosition[ i ];

				if ( influence === 0 ) continue;

				_tempA.fromBufferAttribute( morphAttribute, a );
				_tempB.fromBufferAttribute( morphAttribute, b );
				_tempC.fromBufferAttribute( morphAttribute, c );

				if ( morphTargetsRelative ) {

					_morphA.addScaledVector( _tempA, influence );
					_morphB.addScaledVector( _tempB, influence );
					_morphC.addScaledVector( _tempC, influence );

				} else {

					_morphA.addScaledVector( _tempA.sub( _vA ), influence );
					_morphB.addScaledVector( _tempB.sub( _vB ), influence );
					_morphC.addScaledVector( _tempC.sub( _vC ), influence );

				}

			}

			_vA.add( _morphA );
			_vB.add( _morphB );
			_vC.add( _morphC );

		}

		if ( object.isSkinnedMesh && material.skinning ) {

			object.boneTransform( a, _vA );
			object.boneTransform( b, _vB );
			object.boneTransform( c, _vC );

		}

		const intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA.fromBufferAttribute( uv, a );
				_uvB.fromBufferAttribute( uv, b );
				_uvC.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			if ( uv2 ) {

				_uvA.fromBufferAttribute( uv2, a );
				_uvB.fromBufferAttribute( uv2, b );
				_uvC.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			const face = {
				a: a,
				b: a,
				c: c,
				normal: new Vector3(),
				materialIndex: 0
			};

			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	const _instanceLocalMatrix = new Matrix4();
	const _instanceWorldMatrix = new Matrix4();

	const _instanceIntersects = [];

	const _mesh = new Mesh();

	function InstancedMesh( geometry, material, count ) {

		Mesh.call( this, geometry, material );

		this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
		this.instanceColor = null;

		this.count = count;

		this.frustumCulled = false;

	}

	InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: InstancedMesh,

		isInstancedMesh: true,

		copy: function ( source ) {

			Mesh.prototype.copy.call( this, source );

			this.instanceMatrix.copy( source.instanceMatrix );

			if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

			this.count = source.count;

			return this;

		},

		getColorAt: function ( index, color ) {

			color.fromArray( this.instanceColor.array, index * 3 );

		},

		getMatrixAt: function ( index, matrix ) {

			matrix.fromArray( this.instanceMatrix.array, index * 16 );

		},

		raycast: function ( raycaster, intersects ) {

			const matrixWorld = this.matrixWorld;
			const raycastTimes = this.count;

			_mesh.geometry = this.geometry;
			_mesh.material = this.material;

			if ( _mesh.material === undefined ) return;

			for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

				// calculate the world matrix for each instance

				this.getMatrixAt( instanceId, _instanceLocalMatrix );

				_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

				// the mesh represents this single instance

				_mesh.matrixWorld = _instanceWorldMatrix;

				_mesh.raycast( raycaster, _instanceIntersects );

				// process the result of raycast

				for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

					const intersect = _instanceIntersects[ i ];
					intersect.instanceId = instanceId;
					intersect.object = this;
					intersects.push( intersect );

				}

				_instanceIntersects.length = 0;

			}

		},

		setColorAt: function ( index, color ) {

			if ( this.instanceColor === null ) {

				this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

			}

			color.toArray( this.instanceColor.array, index * 3 );

		},

		setMatrixAt: function ( index, matrix ) {

			matrix.toArray( this.instanceMatrix.array, index * 16 );

		},

		updateMorphTargets: function () {

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

		this.uuid = MathUtils.generateUUID();

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( let i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset = 0 ) {

			this.array.set( value, offset );

			return this;

		},

		clone: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

			}

			const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

			const ib = new InterleavedBuffer( array, this.stride );
			ib.setUsage( this.usage );

			return ib;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		toJSON: function ( data ) {

			if ( data.arrayBuffers === undefined ) {

				data.arrayBuffers = {};

			}

			// generate UUID for array buffer if necessary

			if ( this.array.buffer._uuid === undefined ) {

				this.array.buffer._uuid = MathUtils.generateUUID();

			}

			if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

				data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

			}

			//

			return {
				uuid: this.uuid,
				buffer: this.array.buffer._uuid,
				type: this.array.constructor.name,
				stride: this.stride
			};

		}

	} );

	const _vector$5 = new Vector3();

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.name = '';

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		},

		needsUpdate: {

			set: function ( value ) {

				this.data.needsUpdate = value;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		applyMatrix4: function ( m ) {

			for ( let i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$5.x = this.getX( i );
				_vector$5.y = this.getY( i );
				_vector$5.z = this.getZ( i );

				_vector$5.applyMatrix4( m );

				this.setXYZ( i, _vector$5.x, _vector$5.y, _vector$5.z );

			}

			return this;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		},

		clone: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

			} else {

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

				}

				return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

			}

		},

		toJSON: function ( data ) {

			if ( data === undefined ) {

				console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

				const array = [];

				for ( let i = 0; i < this.count; i ++ ) {

					const index = i * this.data.stride + this.offset;

					for ( let j = 0; j < this.itemSize; j ++ ) {

						array.push( this.data.array[ index + j ] );

					}

				}

				// deinterleave data and save it as an ordinary buffer attribute for now

				return {
					itemSize: this.itemSize,
					type: this.array.constructor.name,
					array: array,
					normalized: this.normalized
				};

			} else {

				// save as true interlaved attribtue

				if ( data.interleavedBuffers === undefined ) {

					data.interleavedBuffers = {};

				}

				if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

					data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

				}

				return {
					isInterleavedBufferAttribute: true,
					itemSize: this.itemSize,
					data: this.data.uuid,
					offset: this.offset,
					normalized: this.normalized
				};

			}

		}

	} );

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */

	class SpriteMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'SpriteMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.rotation = 0;

			this.sizeAttenuation = true;

			this.transparent = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.rotation = source.rotation;

			this.sizeAttenuation = source.sizeAttenuation;

			return this;

		}

	}

	SpriteMaterial.prototype.isSpriteMaterial = true;

	let _geometry;

	const _intersectPoint = /*@__PURE__*/ new Vector3();
	const _worldScale = /*@__PURE__*/ new Vector3();
	const _mvPosition = /*@__PURE__*/ new Vector3();

	const _alignedPosition = /*@__PURE__*/ new Vector2();
	const _rotatedPosition = /*@__PURE__*/ new Vector2();
	const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

	const _vA$1 = /*@__PURE__*/ new Vector3();
	const _vB$1 = /*@__PURE__*/ new Vector3();
	const _vC$1 = /*@__PURE__*/ new Vector3();

	const _uvA$1 = /*@__PURE__*/ new Vector2();
	const _uvB$1 = /*@__PURE__*/ new Vector2();
	const _uvC$1 = /*@__PURE__*/ new Vector2();

	class Sprite extends Object3D {

		constructor( material ) {

			super();

			this.type = 'Sprite';

			if ( _geometry === undefined ) {

				_geometry = new BufferGeometry();

				const float32Array = new Float32Array( [
					- 0.5, - 0.5, 0, 0, 0,
					0.5, - 0.5, 0, 1, 0,
					0.5, 0.5, 0, 1, 1,
					- 0.5, 0.5, 0, 0, 1
				] );

				const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

				_geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
				_geometry.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
				_geometry.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

			}

			this.geometry = _geometry;
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();

			this.center = new Vector2( 0.5, 0.5 );

		}

		raycast( raycaster, intersects ) {

			if ( raycaster.camera === null ) {

				console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

			}

			_worldScale.setFromMatrixScale( this.matrixWorld );

			_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
			this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

			_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

			if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

				_worldScale.multiplyScalar( - _mvPosition.z );

			}

			const rotation = this.material.rotation;
			let sin, cos;

			if ( rotation !== 0 ) {

				cos = Math.cos( rotation );
				sin = Math.sin( rotation );

			}

			const center = this.center;

			transformVertex( _vA$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vB$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			transformVertex( _vC$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

			_uvA$1.set( 0, 0 );
			_uvB$1.set( 1, 0 );
			_uvC$1.set( 1, 1 );

			// check first triangle
			let intersect = raycaster.ray.intersectTriangle( _vA$1, _vB$1, _vC$1, false, _intersectPoint );

			if ( intersect === null ) {

				// check second triangle
				transformVertex( _vB$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
				_uvB$1.set( 0, 1 );

				intersect = raycaster.ray.intersectTriangle( _vA$1, _vC$1, _vB$1, false, _intersectPoint );
				if ( intersect === null ) {

					return;

				}

			}

			const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				point: _intersectPoint.clone(),
				uv: Triangle.getUV( _intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
				face: null,
				object: this

			} );

		}

		copy( source ) {

			super.copy( source );

			if ( source.center !== undefined ) this.center.copy( source.center );

			this.material = source.material;

			return this;

		}

	}

	Sprite.prototype.isSprite = true;

	function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

		// compute position in camera space
		_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

		// to check if rotation is not zero
		if ( sin !== undefined ) {

			_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
			_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

		} else {

			_rotatedPosition.copy( _alignedPosition );

		}


		vertexPosition.copy( mvPosition );
		vertexPosition.x += _rotatedPosition.x;
		vertexPosition.y += _rotatedPosition.y;

		// transform to world space
		vertexPosition.applyMatrix4( _viewWorldMatrix );

	}

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */

	class PointsMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'PointsMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;

			this.alphaMap = null;

			this.size = 1;
			this.sizeAttenuation = true;

			this.morphTargets = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;

			this.morphTargets = source.morphTargets;

			return this;

		}

	}

	PointsMaterial.prototype.isPointsMaterial = true;

	const _inverseMatrix$1 = new Matrix4();
	const _ray$1 = new Ray();
	const _sphere$1 = new Sphere();
	const _position$1 = new Vector3();

	function Points( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

		Object3D.call( this );

		this.type = 'Points';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Points,

		isPoints: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere );
			_sphere$1.applyMatrix4( matrixWorld );
			_sphere$1.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$1 ) === false ) return;

			//

			_inverseMatrix$1.copy( matrixWorld ).invert();
			_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const indices = index.array;

					for ( let i = 0, il = indices.length; i < il; i ++ ) {

						const a = indices[ i ];

						_position$1.fromBufferAttribute( positionAttribute, a );

						testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				} else {

					for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

						_position$1.fromBufferAttribute( positionAttribute, i );

						testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

					}

				}

			} else {

				console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

		const rayPointDistanceSq = _ray$1.distanceSqToPoint( point );

		if ( rayPointDistanceSq < localThresholdSq ) {

			const intersectPoint = new Vector3();

			_ray$1.closestPointToPoint( point, intersectPoint );
			intersectPoint.applyMatrix4( matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( intersectPoint );

			if ( distance < raycaster.near || distance > raycaster.far ) return;

			intersects.push( {

				distance: distance,
				distanceToRay: Math.sqrt( rayPointDistanceSq ),
				point: intersectPoint,
				index: index,
				face: null,
				object: object

			} );

		}

	}

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */

	class LineBasicMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'LineBasicMaterial';

			this.color = new Color( 0xffffff );

			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';

			this.morphTargets = false;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;

			this.morphTargets = source.morphTargets;

			return this;

		}

	}

	LineBasicMaterial.prototype.isLineBasicMaterial = true;

	const _start = new Vector3();
	const _end = new Vector3();
	const _inverseMatrix$2 = new Matrix4();
	const _ray$2 = new Ray();
	const _sphere$2 = new Sphere();

	function Line( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

		Object3D.call( this );

		this.type = 'Line';

		this.geometry = geometry;
		this.material = material;

		this.updateMorphTargets();

	}

	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Line,

		isLine: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			this.material = source.material;
			this.geometry = source.geometry;

			return this;

		},

		computeLineDistances: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [ 0 ];

					for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

						_start.fromBufferAttribute( positionAttribute, i - 1 );
						_end.fromBufferAttribute( positionAttribute, i );

						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += _start.distanceTo( _end );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		},

		raycast: function ( raycaster, intersects ) {

			const geometry = this.geometry;
			const matrixWorld = this.matrixWorld;
			const threshold = raycaster.params.Line.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$2.copy( geometry.boundingSphere );
			_sphere$2.applyMatrix4( matrixWorld );
			_sphere$2.radius += threshold;

			if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

			//

			_inverseMatrix$2.copy( matrixWorld ).invert();
			_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

			const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			const localThresholdSq = localThreshold * localThreshold;

			const vStart = new Vector3();
			const vEnd = new Vector3();
			const interSegment = new Vector3();
			const interRay = new Vector3();
			const step = this.isLineSegments ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				const index = geometry.index;
				const attributes = geometry.attributes;
				const positionAttribute = attributes.position;

				if ( index !== null ) {

					const indices = index.array;

					for ( let i = 0, l = indices.length - 1; i < l; i += step ) {

						const a = indices[ i ];
						const b = indices[ i + 1 ];

						vStart.fromBufferAttribute( positionAttribute, a );
						vEnd.fromBufferAttribute( positionAttribute, b );

						const distSq = _ray$2.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( let i = 0, l = positionAttribute.count - 1; i < l; i += step ) {

						vStart.fromBufferAttribute( positionAttribute, i );
						vEnd.fromBufferAttribute( positionAttribute, i + 1 );

						const distSq = _ray$2.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > localThresholdSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						const distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		},

		updateMorphTargets: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				const morphAttributes = geometry.morphAttributes;
				const keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					const morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							const name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				const morphTargets = geometry.morphTargets;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		}

	} );

	class LineLoop extends Line {

		constructor( geometry, material ) {

			super( geometry, material );

			this.type = 'LineLoop';

		}

	}

	LineLoop.prototype.isLineLoop = true;

	const _start$1 = new Vector3();
	const _end$1 = new Vector3();

	function LineSegments( geometry, material ) {

		Line.call( this, geometry, material );

		this.type = 'LineSegments';

	}

	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

		constructor: LineSegments,

		isLineSegments: true,

		computeLineDistances: function () {

			const geometry = this.geometry;

			if ( geometry.isBufferGeometry ) {

				// we assume non-indexed geometry

				if ( geometry.index === null ) {

					const positionAttribute = geometry.attributes.position;
					const lineDistances = [];

					for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

						_start$1.fromBufferAttribute( positionAttribute, i );
						_end$1.fromBufferAttribute( positionAttribute, i + 1 );

						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

					}

					geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

				} else {

					console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

				}

			} else if ( geometry.isGeometry ) {

				console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

			return this;

		}

	} );

	const _v1$4 = /*@__PURE__*/ new Vector3();
	const _v2$2 = /*@__PURE__*/ new Vector3();

	class LOD extends Object3D {

		constructor() {

			super();

			this._currentLevel = 0;

			this.type = 'LOD';

			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				},
				isLOD: {
					value: true,
				}
			} );

			this.autoUpdate = true;

		}

		copy( source ) {

			super.copy( source, false );

			const levels = source.levels;

			for ( let i = 0, l = levels.length; i < l; i ++ ) {

				const level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			this.autoUpdate = source.autoUpdate;

			return this;

		}

		addLevel( object, distance = 0 ) {

			distance = Math.abs( distance );

			const levels = this.levels;

			let l;

			for ( l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

			return this;

		}

		getCurrentLevel() {

			return this._currentLevel;

		}

		getObjectForDistance( distance ) {

			const levels = this.levels;

			if ( levels.length > 0 ) {

				let i, l;

				for ( i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance < levels[ i ].distance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			}

			return null;

		}

		raycast( raycaster, intersects ) {

			const levels = this.levels;

			if ( levels.length > 0 ) {

				_v1$4.setFromMatrixPosition( this.matrixWorld );

				const distance = raycaster.ray.origin.distanceTo( _v1$4 );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			}

		}

		update( camera ) {

			const levels = this.levels;

			if ( levels.length > 1 ) {

				_v1$4.setFromMatrixPosition( camera.matrixWorld );
				_v2$2.setFromMatrixPosition( this.matrixWorld );

				const distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

				levels[ 0 ].object.visible = true;

				let i, l;

				for ( i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				this._currentLevel = i - 1;

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.autoUpdate === false ) data.object.autoUpdate = false;

			data.object.levels = [];

			const levels = this.levels;

			for ( let i = 0, l = levels.length; i < l; i ++ ) {

				const level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	}

	const _basePosition = new Vector3();

	const _skinIndex = new Vector4();
	const _skinWeight = new Vector4();

	const _vector$6 = new Vector3();
	const _matrix$1 = new Matrix4();

	function SkinnedMesh( geometry, material ) {

		Mesh.call( this, geometry, material );

		this.type = 'SkinnedMesh';

		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();

	}

	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

		constructor: SkinnedMesh,

		isSkinnedMesh: true,

		copy: function ( source ) {

			Mesh.prototype.copy.call( this, source );

			this.bindMode = source.bindMode;
			this.bindMatrix.copy( source.bindMatrix );
			this.bindMatrixInverse.copy( source.bindMatrixInverse );

			this.skeleton = source.skeleton;

			return this;

		},

		bind: function ( skeleton, bindMatrix ) {

			this.skeleton = skeleton;

			if ( bindMatrix === undefined ) {

				this.updateMatrixWorld( true );

				this.skeleton.calculateInverses();

				bindMatrix = this.matrixWorld;

			}

			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.copy( bindMatrix ).invert();

		},

		pose: function () {

			this.skeleton.pose();

		},

		normalizeSkinWeights: function () {

			const vector = new Vector4();

			const skinWeight = this.geometry.attributes.skinWeight;

			for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

				vector.x = skinWeight.getX( i );
				vector.y = skinWeight.getY( i );
				vector.z = skinWeight.getZ( i );
				vector.w = skinWeight.getW( i );

				const scale = 1.0 / vector.manhattanLength();

				if ( scale !== Infinity ) {

					vector.multiplyScalar( scale );

				} else {

					vector.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

			}

		},

		updateMatrixWorld: function ( force ) {

			Mesh.prototype.updateMatrixWorld.call( this, force );

			if ( this.bindMode === 'attached' ) {

				this.bindMatrixInverse.copy( this.matrixWorld ).invert();

			} else if ( this.bindMode === 'detached' ) {

				this.bindMatrixInverse.copy( this.bindMatrix ).invert();

			} else {

				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

			}

		},

		boneTransform: function ( index, target ) {

			const skeleton = this.skeleton;
			const geometry = this.geometry;

			_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( let i = 0; i < 4; i ++ ) {

				const weight = _skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					const boneIndex = _skinIndex.getComponent( i );

					_matrix$1.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( _vector$6.copy( _basePosition ).applyMatrix4( _matrix$1 ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		}

	} );

	function Bone() {

		Object3D.call( this );

		this.type = 'Bone';

	}

	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Bone,

		isBone: true

	} );

	const _offsetMatrix = /*@__PURE__*/ new Matrix4();
	const _identityMatrix = /*@__PURE__*/ new Matrix4();

	class Skeleton {

		constructor( bones = [], boneInverses = [] ) {

			this.uuid = MathUtils.generateUUID();

			this.bones = bones.slice( 0 );
			this.boneInverses = boneInverses;
			this.boneMatrices = null;

			this.boneTexture = null;
			this.boneTextureSize = 0;

			this.frame = - 1;

			this.init();

		}

		init() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			this.boneMatrices = new Float32Array( bones.length * 16 );

			// calculate inverse bone matrices if necessary

			if ( boneInverses.length === 0 ) {

				this.calculateInverses();

			} else {

				// handle special case

				if ( bones.length !== boneInverses.length ) {

					console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

					this.boneInverses = [];

					for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

						this.boneInverses.push( new Matrix4() );

					}

				}

			}

		}

		calculateInverses() {

			this.boneInverses.length = 0;

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const inverse = new Matrix4();

				if ( this.bones[ i ] ) {

					inverse.copy( this.bones[ i ].matrixWorld ).invert();

				}

				this.boneInverses.push( inverse );

			}

		}

		pose() {

			// recover the bind-time world matrices

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

				}

			}

			// compute the local matrices, positions, rotations and scales

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone ) {

					if ( bone.parent && bone.parent.isBone ) {

						bone.matrix.copy( bone.parent.matrixWorld ).invert();
						bone.matrix.multiply( bone.matrixWorld );

					} else {

						bone.matrix.copy( bone.matrixWorld );

					}

					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

				}

			}

		}

		update() {

			const bones = this.bones;
			const boneInverses = this.boneInverses;
			const boneMatrices = this.boneMatrices;
			const boneTexture = this.boneTexture;

			// flatten bone matrices to array

			for ( let i = 0, il = bones.length; i < il; i ++ ) {

				// compute the offset between the current and the original transform

				const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

				_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
				_offsetMatrix.toArray( boneMatrices, i * 16 );

			}

			if ( boneTexture !== null ) {

				boneTexture.needsUpdate = true;

			}

		}

		clone() {

			return new Skeleton( this.bones, this.boneInverses );

		}

		getBoneByName( name ) {

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				const bone = this.bones[ i ];

				if ( bone.name === name ) {

					return bone;

				}

			}

			return undefined;

		}

		dispose( ) {

			if ( this.boneTexture !== null ) {

				this.boneTexture.dispose();

				this.boneTexture = null;

			}

		}

		fromJSON( json, bones ) {

			this.uuid = json.uuid;

			for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

				const uuid = json.bones[ i ];
				let bone = bones[ uuid ];

				if ( bone === undefined ) {

					console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
					bone = new Bone();

				}

				this.bones.push( bone );
				this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

			}

			this.init();

			return this;

		}

		toJSON() {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Skeleton',
					generator: 'Skeleton.toJSON'
				},
				bones: [],
				boneInverses: []
			};

			data.uuid = this.uuid;

			const bones = this.bones;
			const boneInverses = this.boneInverses;

			for ( let i = 0, l = bones.length; i < l; i ++ ) {

				const bone = bones[ i ];
				data.bones.push( bone.uuid );

				const boneInverse = boneInverses[ i ];
				data.boneInverses.push( boneInverse.toArray() );

			}

			return data;

		}

	}

	/**
	 * Extensible curve object.
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions = 5 ) {

			const points = [];

			for ( let d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			const lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			const cache = [];
			let current, last = this.getPoint( 0 );
			let sum = 0;

			cache.push( 0 );

			for ( let p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			const arcLengths = this.getLengths();

			let i = 0;
			const il = arcLengths.length;

			let targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			let low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			const lengthBefore = arcLengths[ i ];
			const lengthAfter = arcLengths[ i + 1 ];

			const segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			const t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t, optionalTarget ) {

			const delta = 0.0001;
			let t1 = t - delta;
			let t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			const pt1 = this.getPoint( t1 );
			const pt2 = this.getPoint( t2 );

			const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );

			tangent.copy( pt2 ).sub( pt1 ).normalize();

			return tangent;

		},

		getTangentAt: function ( u, optionalTarget ) {

			const t = this.getUtoTmapping( u );
			return this.getTangent( t, optionalTarget );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			const normal = new Vector3();

			const tangents = [];
			const normals = [];
			const binormals = [];

			const vec = new Vector3();
			const mat = new Matrix4();

			// compute the tangent vectors for each segment on the curve

			for ( let i = 0; i <= segments; i ++ ) {

				const u = i / segments;

				tangents[ i ] = this.getTangentAt( u, new Vector3() );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			let min = Number.MAX_VALUE;
			const tx = Math.abs( tangents[ 0 ].x );
			const ty = Math.abs( tangents[ 0 ].y );
			const tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( let i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					const theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				let theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( let i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			const data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	class EllipseCurve extends Curve {

		constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

			super();

			this.type = 'EllipseCurve';

			this.aX = aX;
			this.aY = aY;

			this.xRadius = xRadius;
			this.yRadius = yRadius;

			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;

			this.aClockwise = aClockwise;

			this.aRotation = aRotation;

		}

		getPoint( t, optionalTarget ) {

			const point = optionalTarget || new Vector2();

			const twoPi = Math.PI * 2;
			let deltaAngle = this.aEndAngle - this.aStartAngle;
			const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

			if ( deltaAngle < Number.EPSILON ) {

				if ( samePoints ) {

					deltaAngle = 0;

				} else {

					deltaAngle = twoPi;

				}

			}

			if ( this.aClockwise === true && ! samePoints ) {

				if ( deltaAngle === twoPi ) {

					deltaAngle = - twoPi;

				} else {

					deltaAngle = deltaAngle - twoPi;

				}

			}

			const angle = this.aStartAngle + t * deltaAngle;
			let x = this.aX + this.xRadius * Math.cos( angle );
			let y = this.aY + this.yRadius * Math.sin( angle );

			if ( this.aRotation !== 0 ) {

				const cos = Math.cos( this.aRotation );
				const sin = Math.sin( this.aRotation );

				const tx = x - this.aX;
				const ty = y - this.aY;

				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;

			}

			return point.set( x, y );

		}

		copy( source ) {

			super.copy( source );

			this.aX = source.aX;
			this.aY = source.aY;

			this.xRadius = source.xRadius;
			this.yRadius = source.yRadius;

			this.aStartAngle = source.aStartAngle;
			this.aEndAngle = source.aEndAngle;

			this.aClockwise = source.aClockwise;

			this.aRotation = source.aRotation;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.aX = this.aX;
			data.aY = this.aY;

			data.xRadius = this.xRadius;
			data.yRadius = this.yRadius;

			data.aStartAngle = this.aStartAngle;
			data.aEndAngle = this.aEndAngle;

			data.aClockwise = this.aClockwise;

			data.aRotation = this.aRotation;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.aX = json.aX;
			this.aY = json.aY;

			this.xRadius = json.xRadius;
			this.yRadius = json.yRadius;

			this.aStartAngle = json.aStartAngle;
			this.aEndAngle = json.aEndAngle;

			this.aClockwise = json.aClockwise;

			this.aRotation = json.aRotation;

			return this;

		}

	}

	EllipseCurve.prototype.isEllipseCurve = true;

	class ArcCurve extends EllipseCurve {

		constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			this.type = 'ArcCurve';

		}

	}

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				const t2 = t * t;
				const t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	const tmp = new Vector3();
	const px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	class CatmullRomCurve3 extends Curve {

		constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

			super();

			this.type = 'CatmullRomCurve3';

			this.points = points;
			this.closed = closed;
			this.curveType = curveType;
			this.tension = tension;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const points = this.points;
			const l = points.length;

			const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
			let intPoint = Math.floor( p );
			let weight = p - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			let p0, p3; // 4 points (p1 & p2 defined below)

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			const p1 = points[ intPoint % l ];
			const p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
				let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.curveType === 'catmullrom' ) {

				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

			}

			point.set(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			this.closed = source.closed;
			this.curveType = source.curveType;
			this.tension = source.tension;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			data.closed = this.closed;
			data.curveType = this.curveType;
			data.tension = this.tension;

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector3().fromArray( point ) );

			}

			this.closed = json.closed;
			this.curveType = json.curveType;
			this.tension = json.tension;

			return this;

		}

	}

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	/**
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		const v0 = ( p2 - p0 ) * 0.5;
		const v1 = ( p3 - p1 ) * 0.5;
		const t2 = t * t;
		const t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		const k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		const k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	class CubicBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

			super();

			this.type = 'CubicBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	class CubicBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {

			super();

			this.type = 'CubicBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

			point.set(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );
			this.v3.copy( source.v3 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();
			data.v3 = this.v3.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );
			this.v3.fromArray( json.v3 );

			return this;

		}

	}

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	class LineCurve extends Curve {

		constructor( v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.type = 'LineCurve';

			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}

		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}

		getTangent( t, optionalTarget ) {

			const tangent = optionalTarget || new Vector2();

			tangent.copy( this.v2 ).sub( this.v1 ).normalize();

			return tangent;

		}

		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	LineCurve.prototype.isLineCurve = true;

	class LineCurve3 extends Curve {

		constructor( v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.type = 'LineCurve3';
			this.isLineCurve3 = true;

			this.v1 = v1;
			this.v2 = v2;

		}
		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			if ( t === 1 ) {

				point.copy( this.v2 );

			} else {

				point.copy( this.v2 ).sub( this.v1 );
				point.multiplyScalar( t ).add( this.v1 );

			}

			return point;

		}
		// Line curve is linear, so we can overwrite default getPointAt
		getPointAt( u, optionalTarget ) {

			return this.getPoint( u, optionalTarget );

		}
		copy( source ) {

			super.copy( source );

			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}
		toJSON() {

			const data = super.toJSON();

			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}
		fromJSON( json ) {

			super.fromJSON( json );

			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	class QuadraticBezierCurve extends Curve {

		constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

			super();

			this.type = 'QuadraticBezierCurve';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	class QuadraticBezierCurve3 extends Curve {

		constructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {

			super();

			this.type = 'QuadraticBezierCurve3';

			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;

		}

		getPoint( t, optionalTarget = new Vector3() ) {

			const point = optionalTarget;

			const v0 = this.v0, v1 = this.v1, v2 = this.v2;

			point.set(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.v0.copy( source.v0 );
			this.v1.copy( source.v1 );
			this.v2.copy( source.v2 );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.v0 = this.v0.toArray();
			data.v1 = this.v1.toArray();
			data.v2 = this.v2.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.v0.fromArray( json.v0 );
			this.v1.fromArray( json.v1 );
			this.v2.fromArray( json.v2 );

			return this;

		}

	}

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	class SplineCurve extends Curve {

		constructor( points = [] ) {

			super();

			this.type = 'SplineCurve';

			this.points = points;

		}

		getPoint( t, optionalTarget = new Vector2() ) {

			const point = optionalTarget;

			const points = this.points;
			const p = ( points.length - 1 ) * t;

			const intPoint = Math.floor( p );
			const weight = p - intPoint;

			const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			const p1 = points[ intPoint ];
			const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

			point.set(
				CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
				CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
			);

			return point;

		}

		copy( source ) {

			super.copy( source );

			this.points = [];

			for ( let i = 0, l = source.points.length; i < l; i ++ ) {

				const point = source.points[ i ];

				this.points.push( point.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.points = [];

			for ( let i = 0, l = this.points.length; i < l; i ++ ) {

				const point = this.points[ i ];
				data.points.push( point.toArray() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.points = [];

			for ( let i = 0, l = json.points.length; i < l; i ++ ) {

				const point = json.points[ i ];
				this.points.push( new Vector2().fromArray( point ) );

			}

			return this;

		}

	}

	SplineCurve.prototype.isSplineCurve = true;

	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	class CurvePath extends Curve {

		constructor() {

			super();

			this.type = 'CurvePath';

			this.curves = [];
			this.autoClose = false; // Automatically closes the path

		}

		add( curve ) {

			this.curves.push( curve );

		}

		closePath() {

			// Add a line curve if start and end of lines are not connected
			const startPoint = this.curves[ 0 ].getPoint( 0 );
			const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		}

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint( t ) {

			const d = t * this.getLength();
			const curveLengths = this.getCurveLengths();
			let i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					const diff = curveLengths[ i ] - d;
					const curve = this.curves[ i ];

					const segmentLength = curve.getLength();
					const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		}

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength() {

			const lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		}

		// cacheLengths must be recalculated.
		updateArcLengths() {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		}

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths() {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			const lengths = [];
			let sums = 0;

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		}

		getSpacedPoints( divisions = 40 ) {

			const points = [];

			for ( let i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		getPoints( divisions = 12 ) {

			const points = [];
			let last;

			for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

				const curve = curves[ i ];
				const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				const pts = curve.getPoints( resolution );

				for ( let j = 0; j < pts.length; j ++ ) {

					const point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		}

		copy( source ) {

			super.copy( source );

			this.curves = [];

			for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

				const curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

				const curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

				const curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	}

	class Path extends CurvePath {

		constructor( points ) {

			super();
			this.type = 'Path';

			this.currentPoint = new Vector2();

			if ( points ) {

				this.setFromPoints( points );

			}

		}

		setFromPoints( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( let i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

			return this;

		}

		moveTo( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			return this;

		}

		lineTo( x, y ) {

			const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

			return this;

		}

		quadraticCurveTo( aCPx, aCPy, aX, aY ) {

			const curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			const curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		}

		splineThru( pts /*Array of Vector*/ ) {

			const npts = [ this.currentPoint.clone() ].concat( pts );

			const curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

			return this;

		}

		arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			return this;

		}

		ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const x0 = this.currentPoint.x;
			const y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			return this;

		}

		absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				const firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			const lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

			return this;

		}

		copy( source ) {

			super.copy( source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.currentPoint = this.currentPoint.toArray();

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	}

	class Shape extends Path {

		constructor( points ) {

			super( points );

			this.uuid = MathUtils.generateUUID();

			this.type = 'Shape';

			this.holes = [];

		}

		getPointsHoles( divisions ) {

			const holesPts = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		}

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		}

		copy( source ) {

			super.copy( source );

			this.holes = [];

			for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

				const hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		}

		toJSON() {

			const data = super.toJSON();

			data.uuid = this.uuid;
			data.holes = [];

			for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

				const hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		}

		fromJSON( json ) {

			super.fromJSON( json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

				const hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	}

	class Fog {

		constructor( color, near, far ) {

			this.name = '';

			this.color = new Color( color );

			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;

		}

		clone() {

			return new Fog( this.color, this.near, this.far );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};

		}

	}

	Fog.prototype.isFog = true;

	class FogExp2 {

		constructor( color, density ) {

			this.name = '';

			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;

		}

		clone() {

			return new FogExp2( this.color, this.density );

		}

		toJSON( /* meta */ ) {

			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};

		}

	}

	FogExp2.prototype.isFogExp2 = true;

	class Light extends Object3D {

		constructor( color, intensity = 1 ) {

			super();

			this.type = 'Light';

			this.color = new Color( color );
			this.intensity = intensity;

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.intensity = source.intensity;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;

			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

			return data;

		}

	}

	Light.prototype.isLight = true;

	class HemisphereLight extends Light {

		constructor( skyColor, groundColor, intensity ) {

			super( skyColor, intensity );

			this.type = 'HemisphereLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.groundColor = new Color( groundColor );

		}

		copy( source ) {

			Light.prototype.copy.call( this, source );

			this.groundColor.copy( source.groundColor );

			return this;

		}

	}

	HemisphereLight.prototype.isHemisphereLight = true;

	const _sphere$3 = /*@__PURE__*/ new Sphere();
	const _vector$7 = /*@__PURE__*/ new Vector3();

	class Frustum {

		constructor( p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane() ) {

			this.planes = [ p0, p1, p2, p3, p4, p5 ];

		}

		set( p0, p1, p2, p3, p4, p5 ) {

			const planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		}

		copy( frustum ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		}

		setFromProjectionMatrix( m ) {

			const planes = this.planes;
			const me = m.elements;
			const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		}

		intersectsObject( object ) {

			const geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$3.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( _sphere$3 );

		}

		intersectsSprite( sprite ) {

			_sphere$3.center.set( 0, 0, 0 );
			_sphere$3.radius = 0.7071067811865476;
			_sphere$3.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$3 );

		}

		intersectsSphere( sphere ) {

			const planes = this.planes;
			const center = sphere.center;
			const negRadius = - sphere.radius;

			for ( let i = 0; i < 6; i ++ ) {

				const distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		}

		intersectsBox( box ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				const plane = planes[ i ];

				// corner at max distance

				_vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$7 ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		containsPoint( point ) {

			const planes = this.planes;

			for ( let i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld = /*@__PURE__*/ new Vector3();
	const _lookTarget = /*@__PURE__*/ new Vector3();

	class LightShadow {

		constructor( camera ) {

			this.camera = camera;

			this.bias = 0;
			this.normalBias = 0;
			this.radius = 1;

			this.mapSize = new Vector2( 512, 512 );

			this.map = null;
			this.mapPass = null;
			this.matrix = new Matrix4();

			this.autoUpdate = true;
			this.needsUpdate = false;

			this._frustum = new Frustum();
			this._frameExtents = new Vector2( 1, 1 );

			this._viewportCount = 1;

			this._viewports = [

				new Vector4( 0, 0, 1, 1 )

			];

		}

		getViewportCount() {

			return this._viewportCount;

		}

		getFrustum() {

			return this._frustum;

		}

		updateMatrices( light ) {

			const shadowCamera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _lookTarget );
			shadowCamera.updateMatrixWorld();

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix );

			shadowMatrix.set(
				0.5, 0.0, 0.0, 0.5,
				0.0, 0.5, 0.0, 0.5,
				0.0, 0.0, 0.5, 0.5,
				0.0, 0.0, 0.0, 1.0
			);

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

		}

		getViewport( viewportIndex ) {

			return this._viewports[ viewportIndex ];

		}

		getFrameExtents() {

			return this._frameExtents;

		}

		copy( source ) {

			this.camera = source.camera.clone();

			this.bias = source.bias;
			this.radius = source.radius;

			this.mapSize.copy( source.mapSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		toJSON() {

			const object = {};

			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;

			return object;

		}

	}

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateWorldMatrix( true, false );

			const e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

			this.matrixWorldInverse.copy( this.matrixWorld ).invert();

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov;
		this.zoom = 1;

		this.near = near;
		this.far = far;
		this.focus = 10;

		this.aspect = aspect;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
			const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			const vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return MathUtils.RAD2DEG * 2 * Math.atan(
				Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   const w = 1920;
		 *   const h = 1080;
		 *   const fullWidth = w * 3;
		 *   const fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			const near = this.near;
			let top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
			let height = 2 * top;
			let width = this.aspect * height;
			let left = - 0.5 * width;
			const view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				const fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			const skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		},

		toJSON: function ( meta ) {

			const data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	class SpotLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

			this.focus = 1;

		}

		updateMatrices( light ) {

			const camera = this.camera;

			const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
			const aspect = this.mapSize.width / this.mapSize.height;
			const far = light.distance || camera.far;

			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();

			}

			super.updateMatrices( light );

		}

	}

	SpotLightShadow.prototype.isSpotLightShadow = true;

	class SpotLight extends Light {

		constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

			super( color, intensity );

			this.type = 'SpotLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.distance = distance;
			this.angle = angle;
			this.penumbra = penumbra;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new SpotLightShadow();

		}

		get power() {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * Math.PI;

		}

		set power( power ) {

			// intensity = power per solid angle.
			// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / Math.PI;

		}

		copy( source ) {

			super.copy( source );

			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;

			this.target = source.target.clone();

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	SpotLight.prototype.isSpotLight = true;

	const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
	const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3();
	const _lookTarget$1 = /*@__PURE__*/ new Vector3();

	class PointLightShadow extends LightShadow {

		constructor() {

			super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

			this._frameExtents = new Vector2( 4, 2 );

			this._viewportCount = 6;

			this._viewports = [
				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				new Vector4( 2, 1, 1, 1 ),
				// negative X
				new Vector4( 0, 1, 1, 1 ),
				// positive Z
				new Vector4( 3, 1, 1, 1 ),
				// negative Z
				new Vector4( 1, 1, 1, 1 ),
				// positive Y
				new Vector4( 3, 0, 1, 1 ),
				// negative Y
				new Vector4( 1, 0, 1, 1 )
			];

			this._cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];

			this._cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];

		}

		updateMatrices( light, viewportIndex = 0 ) {

			const camera = this.camera;
			const shadowMatrix = this.matrix;

			_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
			camera.position.copy( _lightPositionWorld$1 );

			_lookTarget$1.copy( camera.position );
			_lookTarget$1.add( this._cubeDirections[ viewportIndex ] );
			camera.up.copy( this._cubeUps[ viewportIndex ] );
			camera.lookAt( _lookTarget$1 );
			camera.updateMatrixWorld();

			shadowMatrix.makeTranslation( - _lightPositionWorld$1.x, - _lightPositionWorld$1.y, - _lightPositionWorld$1.z );

			_projScreenMatrix$1.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

		}

	}

	PointLightShadow.prototype.isPointLightShadow = true;

	class PointLight extends Light {

		constructor( color, intensity, distance = 0, decay = 1 ) {

			super( color, intensity );

			this.type = 'PointLight';

			this.distance = distance;
			this.decay = decay; // for physically correct lights, should be 2.

			this.shadow = new PointLightShadow();

		}

		get power() {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			return this.intensity * 4 * Math.PI;

		}

		set power( power ) {

			// intensity = power per solid angle.
			// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
			this.intensity = power / ( 4 * Math.PI );

		}

		copy( source ) {

			super.copy( source );

			this.distance = source.distance;
			this.decay = source.decay;

			this.shadow = source.shadow.clone();

			return this;

		}

	}

	PointLight.prototype.isPointLight = true;

	class OrthographicCamera extends Camera {

		constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

			super();

			this.type = 'OrthographicCamera';

			this.zoom = 1;
			this.view = null;

			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;

			this.near = near;
			this.far = far;

			this.updateProjectionMatrix();

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		}

		setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		}

		clearViewOffset() {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		}

		updateProjectionMatrix() {

			const dx = ( this.right - this.left ) / ( 2 * this.zoom );
			const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			const cx = ( this.right + this.left ) / 2;
			const cy = ( this.top + this.bottom ) / 2;

			let left = cx - dx;
			let right = cx + dx;
			let top = cy + dy;
			let bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

		}

		toJSON( meta ) {

			const data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	}

	OrthographicCamera.prototype.isOrthographicCamera = true;

	class DirectionalLightShadow extends LightShadow {

		constructor() {

			super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

		}

	}

	DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

	class DirectionalLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.type = 'DirectionalLight';

			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();

			this.target = new Object3D();

			this.shadow = new DirectionalLightShadow();

		}

		copy( source ) {

			super.copy( source );

			this.target = source.target.clone();
			this.shadow = source.shadow.clone();

			return this;

		}

	}

	DirectionalLight.prototype.isDirectionalLight = true;

	class AmbientLight extends Light {

		constructor( color, intensity ) {

			super( color, intensity );

			this.type = 'AmbientLight';

		}

	}

	AmbientLight.prototype.isAmbientLight = true;

	class RectAreaLight extends Light {

		constructor( color, intensity, width = 10, height = 10 ) {

			super( color, intensity );

			this.type = 'RectAreaLight';

			this.width = width;
			this.height = height;

		}

		copy( source ) {

			super.copy( source );

			this.width = source.width;
			this.height = source.height;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.width = this.width;
			data.object.height = this.height;

			return data;

		}

	}

	RectAreaLight.prototype.isRectAreaLight = true;

	/**
	 * Primary reference:
	 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
	 *
	 * Secondary reference:
	 *   https://www.ppsloan.org/publications/StupidSH36.pdf
	 */

	// 3-band SH defined by 9 coefficients

	class SphericalHarmonics3 {

		constructor() {

			this.coefficients = [];

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients.push( new Vector3() );

			}

		}

		set( coefficients ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].copy( coefficients[ i ] );

			}

			return this;

		}

		zero() {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].set( 0, 0, 0 );

			}

			return this;

		}

		// get the radiance in the direction of the normal
		// target is a Vector3
		getAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

			// band 1
			target.addScaledVector( coeff[ 1 ], 0.488603 * y );
			target.addScaledVector( coeff[ 2 ], 0.488603 * z );
			target.addScaledVector( coeff[ 3 ], 0.488603 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
			target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
			target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
			target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
			target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

			return target;

		}

		// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
		// target is a Vector3
		// https://graphics.stanford.edu/papers/envmap/envmap.pdf
		getIrradianceAt( normal, target ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			const coeff = this.coefficients;

			// band 0
			target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); //  * 0.282095

			// band 1
			target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 *  / 3 ) * 0.488603
			target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
			target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

			// band 2
			target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // (  / 4 ) * 1.092548
			target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
			target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // (  / 4 ) * 0.315392 * 3
			target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
			target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // (  / 4 ) * 0.546274

			return target;

		}

		add( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].add( sh.coefficients[ i ] );

			}

			return this;

		}

		addScaledSH( sh, s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

			}

			return this;

		}

		scale( s ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].multiplyScalar( s );

			}

			return this;

		}

		lerp( sh, alpha ) {

			for ( let i = 0; i < 9; i ++ ) {

				this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

			}

			return this;

		}

		equals( sh ) {

			for ( let i = 0; i < 9; i ++ ) {

				if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

					return false;

				}

			}

			return true;

		}

		copy( sh ) {

			return this.set( sh.coefficients );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		fromArray( array, offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

			}

			return this;

		}

		toArray( array = [], offset = 0 ) {

			const coefficients = this.coefficients;

			for ( let i = 0; i < 9; i ++ ) {

				coefficients[ i ].toArray( array, offset + ( i * 3 ) );

			}

			return array;

		}

		// evaluate the basis functions
		// shBasis is an Array[ 9 ]
		static getBasisAt( normal, shBasis ) {

			// normal is assumed to be unit length

			const x = normal.x, y = normal.y, z = normal.z;

			// band 0
			shBasis[ 0 ] = 0.282095;

			// band 1
			shBasis[ 1 ] = 0.488603 * y;
			shBasis[ 2 ] = 0.488603 * z;
			shBasis[ 3 ] = 0.488603 * x;

			// band 2
			shBasis[ 4 ] = 1.092548 * x * y;
			shBasis[ 5 ] = 1.092548 * y * z;
			shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
			shBasis[ 7 ] = 1.092548 * x * z;
			shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

		}

	}

	SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

	class LightProbe extends Light {

		constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

			super( undefined, intensity );

			this.sh = sh;

		}

		copy( source ) {

			super.copy( source );

			this.sh.copy( source.sh );

			return this;

		}

		fromJSON( json ) {

			this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
			this.sh.fromArray( json.sh );

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			data.object.sh = this.sh.toArray();

			return data;

		}

	}

	LightProbe.prototype.isLightProbe = true;

	class Scene extends Object3D {

		constructor() {

			super();

			this.type = 'Scene';

			this.background = null;
			this.environment = null;
			this.fog = null;

			this.overrideMaterial = null;

			this.autoUpdate = true; // checked by the renderer

			if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

				__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

			}

		}

		copy( source, recursive ) {

			super.copy( source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		}

		toJSON( meta ) {

			const data = super.toJSON( meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		}

	}

	Scene.prototype.isScene = true;

	let _canvas;

	const ImageUtils = {

		getDataURL: function ( image ) {

			if ( /^data:/i.test( image.src ) ) {

				return image.src;

			}

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			}

			let canvas;

			if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				const context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	let textureId = 0;

	class Texture extends EventDispatcher {

		constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

			super();

			Object.defineProperty( this, 'id', { value: textureId ++ } );

			this.uuid = MathUtils.generateUUID();

			this.name = '';

			this.image = image;
			this.mipmaps = [];

			this.mapping = mapping;

			this.wrapS = wrapS;
			this.wrapT = wrapT;

			this.magFilter = magFilter;
			this.minFilter = minFilter;

			this.anisotropy = anisotropy;

			this.format = format;
			this.internalFormat = null;
			this.type = type;

			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
			this.center = new Vector2( 0, 0 );
			this.rotation = 0;

			this.matrixAutoUpdate = true;
			this.matrix = new Matrix3();

			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding;

			this.version = 0;
			this.onUpdate = null;

		}

		updateMatrix() {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		}

		toJSON( meta ) {

			const isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			const output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				const image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = MathUtils.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					let url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( let i = 0, l = image.length; i < l; i ++ ) {

							// check cube texture with data textures

							if ( image[ i ].isDataTexture ) {

								url.push( serializeImage( image[ i ].image ) );

							} else {

								url.push( serializeImage( image[ i ] ) );

							}

						}

					} else {

						// process single image

						url = serializeImage( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

		transformUv( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}

						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}

						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

		set needsUpdate( value ) {

			if ( value === true ) this.version ++;

		}

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype.isTexture = true;

	function serializeImage( image ) {

		if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
			( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
			( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

			// default images

			return ImageUtils.getDataURL( image );

		} else {

			if ( image.data ) {

				// images of DataTexture

				return {
					data: Array.prototype.slice.call( image.data ),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				};

			} else {

				console.warn( 'THREE.Texture: Unable to serialize Texture.' );
				return {};

			}

		}

	}

	class CubeTexture extends Texture {

		constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
			format = format !== undefined ? format : RGBFormat;

			super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			// Why CubeTexture._needsFlipEnvMap is necessary:
			//
			// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
			// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
			// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

			// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
			// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
			// when using WebGLCubeRenderTarget.texture as a cube texture.

			this._needsFlipEnvMap = true;

			this.flipY = false;

		}

		get images() {

			return this.image;

		}

		set images( value ) {

			this.image = value;

		}

	}

	CubeTexture.prototype.isCubeTexture = true;

	class DataTexture extends Texture {

		constructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { data: data || null, width: width || 1, height: height || 1 };

			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

			this.generateMipmaps = false;
			this.flipY = false;
			this.unpackAlignment = 1;

			this.needsUpdate = true;

		}

	}

	DataTexture.prototype.isDataTexture = true;

	const Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	function LoadingManager( onLoad, onProgress, onError ) {

		const scope = this;

		let isLoading = false;
		let itemsLoaded = 0;
		let itemsTotal = 0;
		let urlModifier = undefined;
		const handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			const index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

				const regex = handlers[ i ];
				const loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

	const DefaultLoadingManager = new LoadingManager();

	function Loader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.withCredentials = false;
		this.path = '';
		this.resourcePath = '';
		this.requestHeader = {};

	}

	Object.assign( Loader.prototype, {

		load: function ( /* url, onLoad, onProgress, onError */ ) {},

		loadAsync: function ( url, onProgress ) {

			const scope = this;

			return new Promise( function ( resolve, reject ) {

				scope.load( url, resolve, onProgress, reject );

			} );

		},

		parse: function ( /* data */ ) {},

		setCrossOrigin: function ( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setPath: function ( path ) {

			this.path = path;
			return this;

		},

		setResourcePath: function ( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		},

		setRequestHeader: function ( requestHeader ) {

			this.requestHeader = requestHeader;
			return this;

		}

	} );

	class ImageLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	}

	const AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			const n = times.length;
			const result = new Array( n );
			for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			const nValues = values.length;
			const result = new values.constructor( nValues );

			for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				const srcOffset = order[ i ] * stride;

				for ( let j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			let i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			let value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		},

		subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

			const clip = sourceClip.clone();

			clip.name = name;

			const tracks = [];

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				const track = clip.tracks[ i ];
				const valueSize = track.getValueSize();

				const times = [];
				const values = [];

				for ( let j = 0; j < track.times.length; ++ j ) {

					const frame = track.times[ j ] * fps;

					if ( frame < startFrame || frame >= endFrame ) continue;

					times.push( track.times[ j ] );

					for ( let k = 0; k < valueSize; ++ k ) {

						values.push( track.values[ j * valueSize + k ] );

					}

				}

				if ( times.length === 0 ) continue;

				track.times = AnimationUtils.convertArray( times, track.times.constructor );
				track.values = AnimationUtils.convertArray( values, track.values.constructor );

				tracks.push( track );

			}

			clip.tracks = tracks;

			// find minimum .times value across all tracks in the trimmed clip

			let minStartTime = Infinity;

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

					minStartTime = clip.tracks[ i ].times[ 0 ];

				}

			}

			// shift all tracks such that clip begins at t=0

			for ( let i = 0; i < clip.tracks.length; ++ i ) {

				clip.tracks[ i ].shift( - 1 * minStartTime );

			}

			clip.resetDuration();

			return clip;

		},

		makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

			if ( fps <= 0 ) fps = 30;

			const numTracks = referenceClip.tracks.length;
			const referenceTime = referenceFrame / fps;

			// Make each track's values relative to the values at the reference frame
			for ( let i = 0; i < numTracks; ++ i ) {

				const referenceTrack = referenceClip.tracks[ i ];
				const referenceTrackType = referenceTrack.ValueTypeName;

				// Skip this track if it's non-numeric
				if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

				// Find the track in the target clip whose name and type matches the reference track
				const targetTrack = targetClip.tracks.find( function ( track ) {

					return track.name === referenceTrack.name
						&& track.ValueTypeName === referenceTrackType;

				} );

				if ( targetTrack === undefined ) continue;

				let referenceOffset = 0;
				const referenceValueSize = referenceTrack.getValueSize();

				if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					referenceOffset = referenceValueSize / 3;

				}

				let targetOffset = 0;
				const targetValueSize = targetTrack.getValueSize();

				if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

					targetOffset = targetValueSize / 3;

				}

				const lastIndex = referenceTrack.times.length - 1;
				let referenceValue;

				// Find the value to subtract out of the track
				if ( referenceTime <= referenceTrack.times[ 0 ] ) {

					// Reference frame is earlier than the first keyframe, so just use the first keyframe
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

				} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

					// Reference frame is after the last keyframe, so just use the last keyframe
					const startIndex = lastIndex * referenceValueSize + referenceOffset;
					const endIndex = startIndex + referenceValueSize - referenceOffset;
					referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

				} else {

					// Interpolate to the reference value
					const interpolant = referenceTrack.createInterpolant();
					const startIndex = referenceOffset;
					const endIndex = referenceValueSize - referenceOffset;
					interpolant.evaluate( referenceTime );
					referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

				}

				// Conjugate the quaternion
				if ( referenceTrackType === 'quaternion' ) {

					const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
					referenceQuat.toArray( referenceValue );

				}

				// Subtract the reference value from all of the track values

				const numTimes = targetTrack.times.length;
				for ( let j = 0; j < numTimes; ++ j ) {

					const valueStart = j * targetValueSize + targetOffset;

					if ( referenceTrackType === 'quaternion' ) {

						// Multiply the conjugate for quaternion track types
						Quaternion.multiplyQuaternionsFlat(
							targetTrack.values,
							valueStart,
							referenceValue,
							0,
							targetTrack.values,
							valueStart
						);

					} else {

						const valueEnd = targetValueSize - targetOffset * 2;

						// Subtract each value for all other numeric track types
						for ( let k = 0; k < valueEnd; ++ k ) {

							targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

						}

					}

				}

			}

			targetClip.blendMode = AdditiveAnimationBlendMode;

			return targetClip;

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			const pp = this.parameterPositions;
			let i1 = this._cachedIndex,
				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					let right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( let giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							const t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( let giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						const mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	// DECLARE ALIAS AFTER assign prototype
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			const pp = this.parameterPositions;
			let iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			const halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			const sP = - wP * ppp + 2 * wP * pp - wP * p;
			const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			const sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( let i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	class KeyframeTrack {

		constructor( name, times, values, interpolation ) {

			if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
			if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

			this.name = name;

			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

			this.setInterpolation( interpolation || this.DefaultInterpolation );

		}

		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):

		static toJSON( track ) {

			const trackType = track.constructor;

			let json;

			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {

				json = trackType.toJSON( track );

			} else {

				// by default, we assume the data can be serialized as-is
				json = {

					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )

				};

				const interpolation = track.getInterpolation();

				if ( interpolation !== track.DefaultInterpolation ) {

					json.interpolation = interpolation;

				}

			}

			json.type = track.ValueTypeName; // mandatory

			return json;

		}

		InterpolantFactoryMethodDiscrete( result ) {

			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodLinear( result ) {

			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		InterpolantFactoryMethodSmooth( result ) {

			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

		}

		setInterpolation( interpolation ) {

			let factoryMethod;

			switch ( interpolation ) {

				case InterpolateDiscrete:

					factoryMethod = this.InterpolantFactoryMethodDiscrete;

					break;

				case InterpolateLinear:

					factoryMethod = this.InterpolantFactoryMethodLinear;

					break;

				case InterpolateSmooth:

					factoryMethod = this.InterpolantFactoryMethodSmooth;

					break;

			}

			if ( factoryMethod === undefined ) {

				const message = 'unsupported interpolation for ' +
					this.ValueTypeName + ' keyframe track named ' + this.name;

				if ( this.createInterpolant === undefined ) {

					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {

						this.setInterpolation( this.DefaultInterpolation );

					} else {

						throw new Error( message ); // fatal, in this case

					}

				}

				console.warn( 'THREE.KeyframeTrack:', message );
				return this;

			}

			this.createInterpolant = factoryMethod;

			return this;

		}

		getInterpolation() {

			switch ( this.createInterpolant ) {

				case this.InterpolantFactoryMethodDiscrete:

					return InterpolateDiscrete;

				case this.InterpolantFactoryMethodLinear:

					return InterpolateLinear;

				case this.InterpolantFactoryMethodSmooth:

					return InterpolateSmooth;

			}

		}

		getValueSize() {

			return this.values.length / this.times.length;

		}

		// move all keyframes either forwards or backwards in time
		shift( timeOffset ) {

			if ( timeOffset !== 0.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] += timeOffset;

				}

			}

			return this;

		}

		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale( timeScale ) {

			if ( timeScale !== 1.0 ) {

				const times = this.times;

				for ( let i = 0, n = times.length; i !== n; ++ i ) {

					times[ i ] *= timeScale;

				}

			}

			return this;

		}

		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim( startTime, endTime ) {

			const times = this.times,
				nKeys = times.length;

			let from = 0,
				to = nKeys - 1;

			while ( from !== nKeys && times[ from ] < startTime ) {

				++ from;

			}

			while ( to !== - 1 && times[ to ] > endTime ) {

				-- to;

			}

			++ to; // inclusive -> exclusive bound

			if ( from !== 0 || to !== nKeys ) {

				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) {

					to = Math.max( to, 1 );
					from = to - 1;

				}

				const stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

			}

			return this;

		}

		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate() {

			let valid = true;

			const valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {

				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;

			}

			const times = this.times,
				values = this.values,

				nKeys = times.length;

			if ( nKeys === 0 ) {

				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;

			}

			let prevTime = null;

			for ( let i = 0; i !== nKeys; i ++ ) {

				const currTime = times[ i ];

				if ( typeof currTime === 'number' && isNaN( currTime ) ) {

					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;

				}

				if ( prevTime !== null && prevTime > currTime ) {

					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;

				}

				prevTime = currTime;

			}

			if ( values !== undefined ) {

				if ( AnimationUtils.isTypedArray( values ) ) {

					for ( let i = 0, n = values.length; i !== n; ++ i ) {

						const value = values[ i ];

						if ( isNaN( value ) ) {

							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;

						}

					}

				}

			}

			return valid;

		}

		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize() {

			// times or values may be shared with other tracks, so overwriting is unsafe
			const times = AnimationUtils.arraySlice( this.times ),
				values = AnimationUtils.arraySlice( this.values ),
				stride = this.getValueSize(),

				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

				lastIndex = times.length - 1;

			let writeIndex = 1;

			for ( let i = 1; i < lastIndex; ++ i ) {

				let keep = false;

				const time = times[ i ];
				const timeNext = times[ i + 1 ];

				// remove adjacent keyframes scheduled at the same time

				if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

					if ( ! smoothInterpolation ) {

						// remove unnecessary keyframes same as their neighbors

						const offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;

						for ( let j = 0; j !== stride; ++ j ) {

							const value = values[ offset + j ];

							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

								keep = true;
								break;

							}

						}

					} else {

						keep = true;

					}

				}

				// in-place compaction

				if ( keep ) {

					if ( i !== writeIndex ) {

						times[ writeIndex ] = times[ i ];

						const readOffset = i * stride,
							writeOffset = writeIndex * stride;

						for ( let j = 0; j !== stride; ++ j ) {

							values[ writeOffset + j ] = values[ readOffset + j ];

						}

					}

					++ writeIndex;

				}

			}

			// flush last keyframe (compaction looks ahead)

			if ( lastIndex > 0 ) {

				times[ writeIndex ] = times[ lastIndex ];

				for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

					values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

			if ( writeIndex !== times.length ) {

				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

			} else {

				this.times = times;
				this.values = values;

			}

			return this;

		}

		clone() {

			const times = AnimationUtils.arraySlice( this.times, 0 );
			const values = AnimationUtils.arraySlice( this.values, 0 );

			const TypedKeyframeTrack = this.constructor;
			const track = new TypedKeyframeTrack( this.name, times, values );

			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;

			return track;

		}

	}

	KeyframeTrack.prototype.TimeBufferType = Float32Array;
	KeyframeTrack.prototype.ValueBufferType = Float32Array;
	KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

	/**
	 * A Track of Boolean keyframe values.
	 */
	class BooleanKeyframeTrack extends KeyframeTrack {}

	BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
	BooleanKeyframeTrack.prototype.ValueBufferType = Array;
	BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of keyframe values that represent color.
	 */
	class ColorKeyframeTrack extends KeyframeTrack {}

	ColorKeyframeTrack.prototype.ValueTypeName = 'color';

	/**
	 * A Track of numeric keyframe values.
	 */
	class NumberKeyframeTrack extends KeyframeTrack {}

	NumberKeyframeTrack.prototype.ValueTypeName = 'number';

	/**
	 * Spherical linear unit quaternion interpolant.
	 */

	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: QuaternionLinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			const result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				alpha = ( t - t0 ) / ( t1 - t0 );

			let offset = i1 * stride;

			for ( let end = offset + stride; offset !== end; offset += 4 ) {

				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

			}

			return result;

		}

	} );

	/**
	 * A Track of quaternion keyframe values.
	 */
	class QuaternionKeyframeTrack extends KeyframeTrack {

		InterpolantFactoryMethodLinear( result ) {

			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

		}

	}

	QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
	// ValueBufferType is inherited
	QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
	QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track that interpolates Strings
	 */
	class StringKeyframeTrack extends KeyframeTrack {}

	StringKeyframeTrack.prototype.ValueTypeName = 'string';
	StringKeyframeTrack.prototype.ValueBufferType = Array;
	StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
	StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

	/**
	 * A Track of vectored keyframe values.
	 */
	class VectorKeyframeTrack extends KeyframeTrack {}

	VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

	class AnimationClip {

		constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

			this.name = name;
			this.tracks = tracks;
			this.duration = duration;
			this.blendMode = blendMode;

			this.uuid = MathUtils.generateUUID();

			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {

				this.resetDuration();

			}

		}


		static parse( json ) {

			const tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );

			for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

			}

			const clip = new this( json.name, json.duration, tracks, json.blendMode );
			clip.uuid = json.uuid;

			return clip;

		}

		static toJSON( clip ) {

			const tracks = [],
				clipTracks = clip.tracks;

			const json = {

				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid,
				'blendMode': clip.blendMode

			};

			for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

			}

			return json;

		}

		static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

			const numMorphTargets = morphTargetSequence.length;
			const tracks = [];

			for ( let i = 0; i < numMorphTargets; i ++ ) {

				let times = [];
				let values = [];

				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

				values.push( 0, 1, 0 );

				const order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );

				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {

					times.push( numMorphTargets );
					values.push( values[ 0 ] );

				}

				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );

			}

			return new this( name, - 1, tracks );

		}

		static findByName( objectOrClipArray, name ) {

			let clipArray = objectOrClipArray;

			if ( ! Array.isArray( objectOrClipArray ) ) {

				const o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;

			}

			for ( let i = 0; i < clipArray.length; i ++ ) {

				if ( clipArray[ i ].name === name ) {

					return clipArray[ i ];

				}

			}

			return null;

		}

		static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

			const animationToMorphTargets = {};

			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			const pattern = /^([\w-]*?)([\d]+)$/;

			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

				const morphTarget = morphTargets[ i ];
				const parts = morphTarget.name.match( pattern );

				if ( parts && parts.length > 1 ) {

					const name = parts[ 1 ];

					let animationMorphTargets = animationToMorphTargets[ name ];

					if ( ! animationMorphTargets ) {

						animationToMorphTargets[ name ] = animationMorphTargets = [];

					}

					animationMorphTargets.push( morphTarget );

				}

			}

			const clips = [];

			for ( const name in animationToMorphTargets ) {

				clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

			}

			return clips;

		}

		// parse the animation.hierarchy format
		static parseAnimation( animation, bones ) {

			if ( ! animation ) {

				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;

			}

			const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {

					const times = [];
					const values = [];

					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {

						destTracks.push( new trackType( trackName, times, values ) );

					}

				}

			};

			const tracks = [];

			const clipName = animation.name || 'default';
			const fps = animation.fps || 30;
			const blendMode = animation.blendMode;

			// automatic length determination in AnimationClip.
			let duration = animation.length || - 1;

			const hierarchyTracks = animation.hierarchy || [];

			for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

				const animationKeys = hierarchyTracks[ h ].keys;

				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;

				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {

					// figure out all morph targets used in this track
					const morphTargetNames = {};

					let k;

					for ( k = 0; k < animationKeys.length; k ++ ) {

						if ( animationKeys[ k ].morphTargets ) {

							for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

							}

						}

					}

					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( const morphTargetName in morphTargetNames ) {

						const times = [];
						const values = [];

						for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

							const animationKey = animationKeys[ k ];

							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

						}

						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

					}

					duration = morphTargetNames.length * ( fps || 1.0 );

				} else {

					// ...assume skeletal animation

					const boneName = '.bones[' + bones[ h ].name + ']';

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

				}

			}

			if ( tracks.length === 0 ) {

				return null;

			}

			const clip = new this( clipName, duration, tracks, blendMode );

			return clip;

		}

		resetDuration() {

			const tracks = this.tracks;
			let duration = 0;

			for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

				const track = this.tracks[ i ];

				duration = Math.max( duration, track.times[ track.times.length - 1 ] );

			}

			this.duration = duration;

			return this;

		}

		trim() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].trim( 0, this.duration );

			}

			return this;

		}

		validate() {

			let valid = true;

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				valid = valid && this.tracks[ i ].validate();

			}

			return valid;

		}

		optimize() {

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				this.tracks[ i ].optimize();

			}

			return this;

		}

		clone() {

			const tracks = [];

			for ( let i = 0; i < this.tracks.length; i ++ ) {

				tracks.push( this.tracks[ i ].clone() );

			}

			return new this.constructor( this.name, this.duration, tracks, this.blendMode );

		}

		toJSON() {

			return this.constructor.toJSON( this );

		}

	}

	function getTrackTypeForValueTypeName( typeName ) {

		switch ( typeName.toLowerCase() ) {

			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':

				return NumberKeyframeTrack;

			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':

				return VectorKeyframeTrack;

			case 'color':

				return ColorKeyframeTrack;

			case 'quaternion':

				return QuaternionKeyframeTrack;

			case 'bool':
			case 'boolean':

				return BooleanKeyframeTrack;

			case 'string':

				return StringKeyframeTrack;

		}

		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

	}

	function parseKeyframeTrack( json ) {

		if ( json.type === undefined ) {

			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

		}

		const trackType = getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			const times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );

		}

	}

	const loading = {};

	function FileLoader( manager ) {

		Loader.call( this, manager );

	}

	FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: FileLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			const scope = this;

			const cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			const dataUriRegexResult = url.match( dataUriRegex );
			let request;

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				const mimeType = dataUriRegexResult[ 1 ];
				const isBase64 = !! dataUriRegexResult[ 2 ];

				let data = dataUriRegexResult[ 3 ];
				data = decodeURIComponent( data );

				if ( isBase64 ) data = atob( data );

				try {

					let response;
					const responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							const view = new Uint8Array( data.length );

							for ( let i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							const parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					const response = this.response;

					const callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						// Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.
						Cache.add( url, response );

						for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

							const callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

							const callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					const callbacks = loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					const callbacks = loading[ url ];

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					const callbacks = loading[ url ];

					delete loading[ url ];

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( const header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		}

	} );

	/**
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */

	class ShadowMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'ShadowMaterial';

			this.color = new Color( 0x000000 );
			this.transparent = true;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			return this;

		}

	}

	ShadowMaterial.prototype.isShadowMaterial = true;

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		const dst = {};

		for ( const u in src ) {

			dst[ u ] = {};

			for ( const p in src[ u ] ) {

				const property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture || property.isQuaternion ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		const merged = {};

		for ( let u = 0; u < uniforms.length; u ++ ) {

			const tmp = cloneUniforms( uniforms[ u ] );

			for ( const p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = /* glsl */`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`;

	var default_fragment = /* glsl */`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;

	/**
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		this.glslVersion = null;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = Object.assign( {}, source.extensions );

		this.glslVersion = source.glslVersion;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		const data = Material.prototype.toJSON.call( this, meta );

		data.glslVersion = this.glslVersion;
		data.uniforms = {};

		for ( const name in this.uniforms ) {

			const uniform = this.uniforms[ name ];
			const value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		const extensions = {};

		for ( const key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	};

	class RawShaderMaterial extends ShaderMaterial {

		constructor( parameters ) {

			super( parameters );

			this.type = 'RawShaderMaterial';

		}

	}

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	function MeshStandardMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'STANDARD': '' };

		this.type = 'MeshStandardMaterial';

		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 1.0;
		this.metalness = 0.0;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.roughnessMap = null;

		this.metalnessMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.envMapIntensity = 1.0;

		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.vertexTangents = false;

		this.setValues( parameters );

	}

	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

	MeshStandardMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'STANDARD': '' };

		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.roughnessMap = source.roughnessMap;

		this.metalnessMap = source.metalnessMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;

		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		this.vertexTangents = source.vertexTangents;

		return this;

	};

	/**
	 * parameters = {
	 *  clearcoat: <float>,
	 *  clearcoatMap: new THREE.Texture( <Image> ),
	 *  clearcoatRoughness: <float>,
	 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
	 *  clearcoatNormalScale: <Vector2>,
	 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
	 *
	 *  reflectivity: <float>,
	 *  ior: <float>,
	 *
	 *  sheen: <Color>,
	 *
	 *  transmission: <float>,
	 *  transmissionMap: new THREE.Texture( <Image> )
	 * }
	 */

	function MeshPhysicalMaterial( parameters ) {

		MeshStandardMaterial.call( this );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.type = 'MeshPhysicalMaterial';

		this.clearcoat = 0.0;
		this.clearcoatMap = null;
		this.clearcoatRoughness = 0.0;
		this.clearcoatRoughnessMap = null;
		this.clearcoatNormalScale = new Vector2( 1, 1 );
		this.clearcoatNormalMap = null;

		this.reflectivity = 0.5; // maps to F0 = 0.04

		Object.defineProperty( this, 'ior', {
			get: function () {

				return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

			},
			set: function ( ior ) {

				this.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

			}
		} );

		this.sheen = null; // null will disable sheen bsdf

		this.transmission = 0.0;
		this.transmissionMap = null;

		this.setValues( parameters );

	}

	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

	MeshPhysicalMaterial.prototype.copy = function ( source ) {

		MeshStandardMaterial.prototype.copy.call( this, source );

		this.defines = {

			'STANDARD': '',
			'PHYSICAL': ''

		};

		this.clearcoat = source.clearcoat;
		this.clearcoatMap = source.clearcoatMap;
		this.clearcoatRoughness = source.clearcoatRoughness;
		this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
		this.clearcoatNormalMap = source.clearcoatNormalMap;
		this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

		this.reflectivity = source.reflectivity;

		if ( source.sheen ) {

			this.sheen = ( this.sheen || new Color() ).copy( source.sheen );

		} else {

			this.sheen = null;

		}

		this.transmission = source.transmission;
		this.transmissionMap = source.transmissionMap;

		return this;

	};

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.MultiplyOperation,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshPhongMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshPhongMaterial';

			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *  gradientMap: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	class MeshToonMaterial extends Material {

		constructor( parameters ) {

			super();

			this.defines = { 'TOON': '' };

			this.type = 'MeshToonMaterial';

			this.color = new Color( 0xffffff );

			this.map = null;
			this.gradientMap = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;
			this.gradientMap = source.gradientMap;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		}

	}

	MeshToonMaterial.prototype.isMeshToonMaterial = true;

	/**
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>,
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshNormalMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshNormalMaterial';

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	class MeshLambertMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshLambertMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.map = null;

			this.lightMap = null;
			this.lightMapIntensity = 1.0;

			this.aoMap = null;
			this.aoMapIntensity = 1.0;

			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;

			this.specularMap = null;

			this.alphaMap = null;

			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;

			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.color.copy( source.color );

			this.map = source.map;

			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;

			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;

			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;

			this.specularMap = source.specularMap;

			this.alphaMap = source.alphaMap;

			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			return this;

		}

	}

	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

	/**
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	class MeshDepthMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshDepthMaterial';

			this.depthPacking = BasicDepthPacking;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.wireframe = false;
			this.wireframeLinewidth = 1;

			this.fog = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.depthPacking = source.depthPacking;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;

			return this;

		}

	}

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	/**
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */

	class MeshDistanceMaterial extends Material {

		constructor( parameters ) {

			super();

			this.type = 'MeshDistanceMaterial';

			this.referencePosition = new Vector3();
			this.nearDistance = 1;
			this.farDistance = 1000;

			this.skinning = false;
			this.morphTargets = false;

			this.map = null;

			this.alphaMap = null;

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.fog = false;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.referencePosition.copy( source.referencePosition );
			this.nearDistance = source.nearDistance;
			this.farDistance = source.farDistance;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;

			this.map = source.map;

			this.alphaMap = source.alphaMap;

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			return this;

		}

	}

	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 *
	 *  flatShading: <bool>
	 * }
	 */

	class MeshMatcapMaterial extends Material {

		constructor( parameters ) {

			super();

			this.defines = { 'MATCAP': '' };

			this.type = 'MeshMatcapMaterial';

			this.color = new Color( 0xffffff ); // diffuse

			this.matcap = null;

			this.map = null;

			this.bumpMap = null;
			this.bumpScale = 1;

			this.normalMap = null;
			this.normalMapType = TangentSpaceNormalMap;
			this.normalScale = new Vector2( 1, 1 );

			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;

			this.alphaMap = null;

			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;

			this.flatShading = false;

			this.setValues( parameters );

		}


		copy( source ) {

			super.copy( source );

			this.defines = { 'MATCAP': '' };

			this.color.copy( source.color );

			this.matcap = source.matcap;

			this.map = source.map;

			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;

			this.normalMap = source.normalMap;
			this.normalMapType = source.normalMapType;
			this.normalScale.copy( source.normalScale );

			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;

			this.alphaMap = source.alphaMap;

			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;

			this.flatShading = source.flatShading;

			return this;

		}

	}

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	/**
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */

	class LineDashedMaterial extends LineBasicMaterial {

		constructor( parameters ) {

			super();

			this.type = 'LineDashedMaterial';

			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;

			this.setValues( parameters );

		}

		copy( source ) {

			super.copy( source );

			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;

			return this;

		}

	}

	LineDashedMaterial.prototype.isLineDashedMaterial = true;

	var Materials = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});

	class MaterialLoader extends Loader {

		constructor( manager ) {

			super( manager );
			this.textures = {};

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.setRequestHeader( scope.requestHeader );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( JSON.parse( text ) ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		parse( json ) {

			const textures = this.textures;

			function getTexture( name ) {

				if ( textures[ name ] === undefined ) {

					console.warn( 'THREE.MaterialLoader: Undefined texture', name );

				}

				return textures[ name ];

			}

			const material = new Materials[ json.type ]();

			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.sheen !== undefined ) material.sheen = new Color().setHex( json.sheen );
			if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
			if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

			if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
			if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
			if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
			if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
			if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
			if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
			if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
			if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

			if ( json.rotation !== undefined ) material.rotation = json.rotation;

			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;

			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;

			if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

			if ( json.visible !== undefined ) material.visible = json.visible;

			if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

			if ( json.userData !== undefined ) material.userData = json.userData;

			if ( json.vertexColors !== undefined ) {

				if ( typeof json.vertexColors === 'number' ) {

					material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

				} else {

					material.vertexColors = json.vertexColors;

				}

			}

			// Shader Material

			if ( json.uniforms !== undefined ) {

				for ( const name in json.uniforms ) {

					const uniform = json.uniforms[ name ];

					material.uniforms[ name ] = {};

					switch ( uniform.type ) {

						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;

						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;

						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;

						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;

						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;

						case 'm3':
							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
							break;

						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;

						default:
							material.uniforms[ name ].value = uniform.value;

					}

				}

			}

			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

			if ( json.extensions !== undefined ) {

				for ( const key in json.extensions ) {

					material.extensions[ key ] = json.extensions[ key ];

				}

			}

			// Deprecated

			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

			// for PointsMaterial

			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

			// maps

			if ( json.map !== undefined ) material.map = getTexture( json.map );
			if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

			if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {

				let normalScale = json.normalScale;

				if ( Array.isArray( normalScale ) === false ) {

					// Blender exporter used to export a scalar. See #7459

					normalScale = [ normalScale, normalScale ];

				}

				material.normalScale = new Vector2().fromArray( normalScale );

			}

			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
			if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

			if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
			if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
			if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
			if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

			if ( json.transmission !== undefined ) material.transmission = json.transmission;
			if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

			return material;

		}

		setTextures( value ) {

			this.textures = value;
			return this;

		}

	}

	const LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			let s = '';

			for ( let i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent( escape( s ) );

			} catch ( e ) { // see #16358

				return s;

			}

		},

		extractUrlBase: function ( url ) {

			const index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.instanceCount = Infinity;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.instanceCount = source.instanceCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			const data = BufferGeometry.prototype.toJSON.call( this );

			data.instanceCount = this.instanceCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	} );

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		toJSON: function ()	{

			const data = BufferAttribute.prototype.toJSON.call( this );

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	} );

	class BufferGeometryLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.setRequestHeader( scope.requestHeader );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( text ) {

				try {

					onLoad( scope.parse( JSON.parse( text ) ) );

				} catch ( e ) {

					if ( onError ) {

						onError( e );

					} else {

						console.error( e );

					}

					scope.manager.itemError( url );

				}

			}, onProgress, onError );

		}

		parse( json ) {

			const interleavedBufferMap = {};
			const arrayBufferMap = {};

			function getInterleavedBuffer( json, uuid ) {

				if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

				const interleavedBuffers = json.interleavedBuffers;
				const interleavedBuffer = interleavedBuffers[ uuid ];

				const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

				const array = getTypedArray( interleavedBuffer.type, buffer );
				const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
				ib.uuid = interleavedBuffer.uuid;

				interleavedBufferMap[ uuid ] = ib;

				return ib;

			}

			function getArrayBuffer( json, uuid ) {

				if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

				const arrayBuffers = json.arrayBuffers;
				const arrayBuffer = arrayBuffers[ uuid ];

				const ab = new Uint32Array( arrayBuffer ).buffer;

				arrayBufferMap[ uuid ] = ab;

				return ab;

			}

			const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

			const index = json.data.index;

			if ( index !== undefined ) {

				const typedArray = getTypedArray( index.type, index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

			}

			const attributes = json.data.attributes;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];
				let bufferAttribute;

				if ( attribute.isInterleavedBufferAttribute ) {

					const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
					bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

				} else {

					const typedArray = getTypedArray( attribute.type, attribute.array );
					const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
					bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

				}

				if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
				geometry.setAttribute( key, bufferAttribute );

			}

			const morphAttributes = json.data.morphAttributes;

			if ( morphAttributes ) {

				for ( const key in morphAttributes ) {

					const attributeArray = morphAttributes[ key ];

					const array = [];

					for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

						const attribute = attributeArray[ i ];
						let bufferAttribute;

						if ( attribute.isInterleavedBufferAttribute ) {

							const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
							bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

						} else {

							const typedArray = getTypedArray( attribute.type, attribute.array );
							bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

						}

						if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
						array.push( bufferAttribute );

					}

					geometry.morphAttributes[ key ] = array;

				}

			}

			const morphTargetsRelative = json.data.morphTargetsRelative;

			if ( morphTargetsRelative ) {

				geometry.morphTargetsRelative = true;

			}

			const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

			if ( groups !== undefined ) {

				for ( let i = 0, n = groups.length; i !== n; ++ i ) {

					const group = groups[ i ];

					geometry.addGroup( group.start, group.count, group.materialIndex );

				}

			}

			const boundingSphere = json.data.boundingSphere;

			if ( boundingSphere !== undefined ) {

				const center = new Vector3();

				if ( boundingSphere.center !== undefined ) {

					center.fromArray( boundingSphere.center );

				}

				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

			}

			if ( json.name ) geometry.name = json.name;
			if ( json.userData ) geometry.userData = json.userData;

			return geometry;

		}

	}

	class BoxGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			const scope = this;

			// segments

			widthSegments = Math.floor( widthSegments );
			heightSegments = Math.floor( heightSegments );
			depthSegments = Math.floor( depthSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let numberOfVertices = 0;
			let groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				const segmentWidth = width / gridX;
				const segmentHeight = height / gridY;

				const widthHalf = width / 2;
				const heightHalf = height / 2;
				const depthHalf = depth / 2;

				const gridX1 = gridX + 1;
				const gridY1 = gridY + 1;

				let vertexCounter = 0;
				let groupCount = 0;

				const vector = new Vector3();

				// generate vertices, normals and uvs

				for ( let iy = 0; iy < gridY1; iy ++ ) {

					const y = iy * segmentHeight - heightHalf;

					for ( let ix = 0; ix < gridX1; ix ++ ) {

						const x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( let iy = 0; iy < gridY; iy ++ ) {

					for ( let ix = 0; ix < gridX; ix ++ ) {

						const a = numberOfVertices + ix + gridX1 * iy;
						const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

	}

	class CircleGeometry extends BufferGeometry {

		constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'CircleGeometry';

			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			segments = Math.max( 3, segments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const vertex = new Vector3();
			const uv = new Vector2();

			// center point

			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );

			for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

				const segment = thetaStart + s / segments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uvs

				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// indices

			for ( let i = 1; i <= segments; i ++ ) {

				indices.push( i, i + 1, 0 );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class CylinderGeometry extends BufferGeometry {

		constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();
			this.type = 'CylinderGeometry';

			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			const scope = this;

			radialSegments = Math.floor( radialSegments );
			heightSegments = Math.floor( heightSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let index = 0;
			const indexArray = [];
			const halfHeight = height / 2;
			let groupStart = 0;

			// generate geometry

			generateTorso();

			if ( openEnded === false ) {

				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function generateTorso() {

				const normal = new Vector3();
				const vertex = new Vector3();

				let groupCount = 0;

				// this will be used to calculate the normal
				const slope = ( radiusBottom - radiusTop ) / height;

				// generate vertices, normals and uvs

				for ( let y = 0; y <= heightSegments; y ++ ) {

					const indexRow = [];

					const v = y / heightSegments;

					// calculate the radius of the current row

					const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

					for ( let x = 0; x <= radialSegments; x ++ ) {

						const u = x / radialSegments;

						const theta = u * thetaLength + thetaStart;

						const sinTheta = Math.sin( theta );
						const cosTheta = Math.cos( theta );

						// vertex

						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );

						// normal

						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );

						// uv

						uvs.push( u, 1 - v );

						// save index of vertex in respective row

						indexRow.push( index ++ );

					}

					// now save vertices of the row in our index array

					indexArray.push( indexRow );

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					for ( let y = 0; y < heightSegments; y ++ ) {

						// we use the index array to access the correct indices

						const a = indexArray[ y ][ x ];
						const b = indexArray[ y + 1 ][ x ];
						const c = indexArray[ y + 1 ][ x + 1 ];
						const d = indexArray[ y ][ x + 1 ];

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// update group counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, 0 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

			function generateCap( top ) {

				// save the index of the first center vertex
				const centerIndexStart = index;

				const uv = new Vector2();
				const vertex = new Vector3();

				let groupCount = 0;

				const radius = ( top === true ) ? radiusTop : radiusBottom;
				const sign = ( top === true ) ? 1 : - 1;

				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment

				for ( let x = 1; x <= radialSegments; x ++ ) {

					// vertex

					vertices.push( 0, halfHeight * sign, 0 );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uvs.push( 0.5, 0.5 );

					// increase index

					index ++;

				}

				// save the index of the last center vertex
				const centerIndexEnd = index;

				// now we generate the surrounding vertices, normals and uvs

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;
					const theta = u * thetaLength + thetaStart;

					const cosTheta = Math.cos( theta );
					const sinTheta = Math.sin( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, sign, 0 );

					// uv

					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );

					// increase index

					index ++;

				}

				// generate indices

				for ( let x = 0; x < radialSegments; x ++ ) {

					const c = centerIndexStart + x;
					const i = centerIndexEnd + x;

					if ( top === true ) {

						// face top

						indices.push( i, i + 1, c );

					} else {

						// face bottom

						indices.push( i + 1, i, c );

					}

					groupCount += 3;

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

				// calculate new start value for groups

				groupStart += groupCount;

			}

		}

	}

	class ConeGeometry extends CylinderGeometry {

		constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

			this.type = 'ConeGeometry';

			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

		}

	}

	class PolyhedronGeometry extends BufferGeometry {

		constructor( vertices, indices, radius = 1, detail = 0 ) {

			super();

			this.type = 'PolyhedronGeometry';

			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};

			// default buffer data

			const vertexBuffer = [];
			const uvBuffer = [];

			// the subdivision creates the vertex buffer data

			subdivide( detail );

			// all vertices should lie on a conceptual sphere with a given radius

			applyRadius( radius );

			// finally, create the uv data

			generateUVs();

			// build non-indexed geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

			if ( detail === 0 ) {

				this.computeVertexNormals(); // flat normals

			} else {

				this.normalizeNormals(); // smooth normals

			}

			// helper functions

			function subdivide( detail ) {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				// iterate over all faces and apply a subdivison with the given detail value

				for ( let i = 0; i < indices.length; i += 3 ) {

					// get the vertices of the face

					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );

					// perform subdivision

					subdivideFace( a, b, c, detail );

				}

			}

			function subdivideFace( a, b, c, detail ) {

				const cols = detail + 1;

				// we use this multidimensional array as a data structure for creating the subdivision

				const v = [];

				// construct all of the vertices for this subdivision

				for ( let i = 0; i <= cols; i ++ ) {

					v[ i ] = [];

					const aj = a.clone().lerp( c, i / cols );
					const bj = b.clone().lerp( c, i / cols );

					const rows = cols - i;

					for ( let j = 0; j <= rows; j ++ ) {

						if ( j === 0 && i === cols ) {

							v[ i ][ j ] = aj;

						} else {

							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

						}

					}

				}

				// construct all of the faces

				for ( let i = 0; i < cols; i ++ ) {

					for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

						const k = Math.floor( j / 2 );

						if ( j % 2 === 0 ) {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );

						} else {

							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );

						}

					}

				}

			}

			function applyRadius( radius ) {

				const vertex = new Vector3();

				// iterate over the entire buffer and apply the radius to each vertex

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					vertex.normalize().multiplyScalar( radius );

					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;

				}

			}

			function generateUVs() {

				const vertex = new Vector3();

				for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];

					const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					const v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );

				}

				correctUVs();

				correctSeam();

			}

			function correctSeam() {

				// handle case when face straddles the seam, see #3269

				for ( let i = 0; i < uvBuffer.length; i += 6 ) {

					// uv data of a single face

					const x0 = uvBuffer[ i + 0 ];
					const x1 = uvBuffer[ i + 2 ];
					const x2 = uvBuffer[ i + 4 ];

					const max = Math.max( x0, x1, x2 );
					const min = Math.min( x0, x1, x2 );

					// 0.9 is somewhat arbitrary

					if ( max > 0.9 && min < 0.1 ) {

						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

					}

				}

			}

			function pushVertex( vertex ) {

				vertexBuffer.push( vertex.x, vertex.y, vertex.z );

			}

			function getVertexByIndex( index, vertex ) {

				const stride = index * 3;

				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];

			}

			function correctUVs() {

				const a = new Vector3();
				const b = new Vector3();
				const c = new Vector3();

				const centroid = new Vector3();

				const uvA = new Vector2();
				const uvB = new Vector2();
				const uvC = new Vector2();

				for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

					const azi = azimuth( centroid );

					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );

				}

			}

			function correctUV( uv, stride, vector, azimuth ) {

				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

					uvBuffer[ stride ] = uv.x - 1;

				}

				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

				}

			}

			// Angle around the Y axis, counter-clockwise when looking from above.

			function azimuth( vector ) {

				return Math.atan2( vector.z, - vector.x );

			}


			// Angle above the XZ plane.

			function inclination( vector ) {

				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

			}

		}

	}

	class DodecahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const t = ( 1 + Math.sqrt( 5 ) ) / 2;
			const r = 1 / t;

			const vertices = [

				// (1, 1, 1)
				- 1, - 1, - 1,	- 1, - 1, 1,
				- 1, 1, - 1, - 1, 1, 1,
				1, - 1, - 1, 1, - 1, 1,
				1, 1, - 1, 1, 1, 1,

				// (0, 1/, )
				0, - r, - t, 0, - r, t,
				0, r, - t, 0, r, t,

				// (1/, , 0)
				- r, - t, 0, - r, t, 0,
				r, - t, 0, r, t, 0,

				// (, 0, 1/)
				- t, 0, - r, t, 0, - r,
				- t, 0, r, t, 0, r
			];

			const indices = [
				3, 11, 7, 	3, 7, 15, 	3, 15, 13,
				7, 19, 17, 	7, 17, 6, 	7, 6, 15,
				17, 4, 8, 	17, 8, 10, 	17, 10, 6,
				8, 0, 16, 	8, 16, 2, 	8, 2, 10,
				0, 12, 1, 	0, 1, 18, 	0, 18, 16,
				6, 10, 2, 	6, 2, 13, 	6, 13, 15,
				2, 16, 18, 	2, 18, 3, 	2, 3, 13,
				18, 1, 9, 	18, 9, 11, 	18, 11, 3,
				4, 14, 12, 	4, 12, 0, 	4, 0, 8,
				11, 9, 5, 	11, 5, 19, 	11, 19, 7,
				19, 5, 14, 	19, 14, 4, 	19, 4, 17,
				1, 12, 14, 	1, 14, 5, 	1, 5, 9
			];

			super( vertices, indices, radius, detail );

			this.type = 'DodecahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

	}

	const _v0$2 = new Vector3();
	const _v1$5 = new Vector3();
	const _normal$1 = new Vector3();
	const _triangle = new Triangle();

	class EdgesGeometry extends BufferGeometry {

		constructor( geometry, thresholdAngle ) {

			super();

			this.type = 'EdgesGeometry';

			this.parameters = {
				thresholdAngle: thresholdAngle
			};

			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

			if ( geometry.isGeometry === true ) {

				console.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
				return;

			}

			const precisionPoints = 4;
			const precision = Math.pow( 10, precisionPoints );
			const thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );

			const indexAttr = geometry.getIndex();
			const positionAttr = geometry.getAttribute( 'position' );
			const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

			const indexArr = [ 0, 0, 0 ];
			const vertKeys = [ 'a', 'b', 'c' ];
			const hashes = new Array( 3 );

			const edgeData = {};
			const vertices = [];
			for ( let i = 0; i < indexCount; i += 3 ) {

				if ( indexAttr ) {

					indexArr[ 0 ] = indexAttr.getX( i );
					indexArr[ 1 ] = indexAttr.getX( i + 1 );
					indexArr[ 2 ] = indexAttr.getX( i + 2 );

				} else {

					indexArr[ 0 ] = i;
					indexArr[ 1 ] = i + 1;
					indexArr[ 2 ] = i + 2;

				}

				const { a, b, c } = _triangle;
				a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
				b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
				c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
				_triangle.getNormal( _normal$1 );

				// create hashes for the edge from the vertices
				hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
				hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
				hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

				// skip degenerate triangles
				if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

					continue;

				}

				// iterate over every edge
				for ( let j = 0; j < 3; j ++ ) {

					// get the first and next vertex making up the edge
					const jNext = ( j + 1 ) % 3;
					const vecHash0 = hashes[ j ];
					const vecHash1 = hashes[ jNext ];
					const v0 = _triangle[ vertKeys[ j ] ];
					const v1 = _triangle[ vertKeys[ jNext ] ];

					const hash = `${ vecHash0 }_${ vecHash1 }`;
					const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

					if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

						// if we found a sibling edge add it into the vertex array if
						// it meets the angle threshold and delete the edge from the map.
						if ( _normal$1.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

							vertices.push( v0.x, v0.y, v0.z );
							vertices.push( v1.x, v1.y, v1.z );

						}

						edgeData[ reverseHash ] = null;

					} else if ( ! ( hash in edgeData ) ) {

						// if we've already got an edge here then skip adding a new one
						edgeData[ hash ] = {

							index0: indexArr[ j ],
							index1: indexArr[ jNext ],
							normal: _normal$1.clone(),

						};

					}

				}

			}

			// iterate over all remaining, unmatched edges and add them to the vertex array
			for ( const key in edgeData ) {

				if ( edgeData[ key ] ) {

					const { index0, index1 } = edgeData[ key ];
					_v0$2.fromBufferAttribute( positionAttr, index0 );
					_v1$5.fromBufferAttribute( positionAttr, index1 );

					vertices.push( _v0$2.x, _v0$2.y, _v0$2.z );
					vertices.push( _v1$5.x, _v1$5.y, _v1$5.z );

				}

			}

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	/**
	 * Port from https://github.com/mapbox/earcut (v2.2.2)
	 */

	const Earcut = {

		triangulate: function ( data, holeIndices, dim ) {

			dim = dim || 2;

			const hasHoles = holeIndices && holeIndices.length;
			const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
			let outerNode = linkedList( data, 0, outerLen, dim, true );
			const triangles = [];

			if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

			let minX, minY, maxX, maxY, x, y, invSize;

			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
			if ( data.length > 80 * dim ) {

				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];

				for ( let i = dim; i < outerLen; i += dim ) {

					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;

				}

				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;

			}

			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

			return triangles;

		}

	};

	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList( data, start, end, dim, clockwise ) {

		let i, last;

		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		} else {

			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

		}

		if ( last && equals( last, last.next ) ) {

			removeNode( last );
			last = last.next;

		}

		return last;

	}

	// eliminate colinear or duplicate points
	function filterPoints( start, end ) {

		if ( ! start ) return start;
		if ( ! end ) end = start;

		let p = start,
			again;
		do {

			again = false;

			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;

			} else {

				p = p.next;

			}

		} while ( again || p !== end );

		return end;

	}

	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

		if ( ! ear ) return;

		// interlink polygon nodes in z-order
		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

		let stop = ear,
			prev, next;

		// iterate through ears, slicing them one by one
		while ( ear.prev !== ear.next ) {

			prev = ear.prev;
			next = ear.next;

			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );

				removeNode( ear );

				// skipping the next vertex leads to less sliver triangles
				ear = next.next;
				stop = next.next;

				continue;

			}

			ear = next;

			// if we looped through the whole remaining polygon and can't find any more ears
			if ( ear === stop ) {

				// try filtering points and slicing again
				if ( ! pass ) {

					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

					// if this didn't work, try curing all small self-intersections locally

				} else if ( pass === 1 ) {

					ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

					// as a last resort, try splitting the remaining polygon into two

				} else if ( pass === 2 ) {

					splitEarcut( ear, triangles, dim, minX, minY, invSize );

				}

				break;

			}

		}

	}

	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar( ear ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// now make sure we don't have other points inside the potential ear
		let p = ear.next.next;

		while ( p !== ear.prev ) {

			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.next;

		}

		return true;

	}

	function isEarHashed( ear, minX, minY, invSize ) {

		const a = ear.prev,
			b = ear,
			c = ear.next;

		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

		// triangle bbox; min & max are calculated like this for speed
		const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

		// z-order range for the current triangle bbox;
		const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

		let p = ear.prevZ,
			n = ear.nextZ;

		// look for points inside the triangle in both directions
		while ( p && p.z >= minZ && n && n.z <= maxZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		// look for remaining points in decreasing z-order
		while ( p && p.z >= minZ ) {

			if ( p !== ear.prev && p !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
				area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.prevZ;

		}

		// look for remaining points in increasing z-order
		while ( n && n.z <= maxZ ) {

			if ( n !== ear.prev && n !== ear.next &&
				pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
				area( n.prev, n, n.next ) >= 0 ) return false;
			n = n.nextZ;

		}

		return true;

	}

	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections( start, triangles, dim ) {

		let p = start;
		do {

			const a = p.prev,
				b = p.next.next;

			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );

				// remove two nodes involved
				removeNode( p );
				removeNode( p.next );

				p = start = b;

			}

			p = p.next;

		} while ( p !== start );

		return filterPoints( p );

	}

	// try splitting polygon into two and triangulate them independently
	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

		// look for a valid diagonal that divides the polygon into two
		let a = start;
		do {

			let b = a.next.next;
			while ( b !== a.prev ) {

				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

					// split the polygon in two by the diagonal
					let c = splitPolygon( a, b );

					// filter colinear points around the cuts
					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );

					// run earcut on each half
					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;

				}

				b = b.next;

			}

			a = a.next;

		} while ( a !== start );

	}

	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles( data, holeIndices, outerNode, dim ) {

		const queue = [];
		let i, len, start, end, list;

		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );

		}

		queue.sort( compareX );

		// process holes from left to right
		for ( i = 0; i < queue.length; i ++ ) {

			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );

		}

		return outerNode;

	}

	function compareX( a, b ) {

		return a.x - b.x;

	}

	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole( hole, outerNode ) {

		outerNode = findHoleBridge( hole, outerNode );
		if ( outerNode ) {

			const b = splitPolygon( outerNode, hole );

			// filter collinear points around the cuts
			filterPoints( outerNode, outerNode.next );
			filterPoints( b, b.next );

		}

	}

	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge( hole, outerNode ) {

		let p = outerNode;
		const hx = hole.x;
		const hy = hole.y;
		let qx = - Infinity, m;

		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
		do {

			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

				const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
				if ( x <= hx && x > qx ) {

					qx = x;
					if ( x === hx ) {

						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;

					}

					m = p.x < p.next.x ? p : p.next;

				}

			}

			p = p.next;

		} while ( p !== outerNode );

		if ( ! m ) return null;

		if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point

		const stop = m,
			mx = m.x,
			my = m.y;
		let tanMin = Infinity, tan;

		p = m;

		do {

			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
					pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

				if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

					m = p;
					tanMin = tan;

				}

			}

			p = p.next;

		} while ( p !== stop );

		return m;

	}

	// whether sector in vertex m contains sector in vertex p in the same coordinates
	function sectorContainsSector( m, p ) {

		return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

	}

	// interlink polygon nodes in z-order
	function indexCurve( start, minX, minY, invSize ) {

		let p = start;
		do {

			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;

		} while ( p !== start );

		p.prevZ.nextZ = null;
		p.prevZ = null;

		sortLinked( p );

	}

	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked( list ) {

		let i, p, q, e, tail, numMerges, pSize, qSize,
			inSize = 1;

		do {

			p = list;
			list = null;
			tail = null;
			numMerges = 0;

			while ( p ) {

				numMerges ++;
				q = p;
				pSize = 0;
				for ( i = 0; i < inSize; i ++ ) {

					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;

				}

				qSize = inSize;

				while ( pSize > 0 || ( qSize > 0 && q ) ) {

					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

						e = p;
						p = p.nextZ;
						pSize --;

					} else {

						e = q;
						q = q.nextZ;
						qSize --;

					}

					if ( tail ) tail.nextZ = e;
					else list = e;

					e.prevZ = tail;
					tail = e;

				}

				p = q;

			}

			tail.nextZ = null;
			inSize *= 2;

		} while ( numMerges > 1 );

		return list;

	}

	// z-order of a point given coords and inverse of the longer side of data bbox
	function zOrder( x, y, minX, minY, invSize ) {

		// coords are transformed into non-negative 15-bit integer range
		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;

		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;

		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;

		return x | ( y << 1 );

	}

	// find the leftmost node of a polygon ring
	function getLeftmost( start ) {

		let p = start,
			leftmost = start;
		do {

			if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
			p = p.next;

		} while ( p !== start );

		return leftmost;

	}

	// check if a point lies within a convex triangle
	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
				( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
				( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

	}

	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal( a, b ) {

		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
			( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
			( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
			equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

	}

	// signed area of a triangle
	function area( p, q, r ) {

		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

	}

	// check if two points are equal
	function equals( p1, p2 ) {

		return p1.x === p2.x && p1.y === p2.y;

	}

	// check if two segments intersect
	function intersects( p1, q1, p2, q2 ) {

		const o1 = sign( area( p1, q1, p2 ) );
		const o2 = sign( area( p1, q1, q2 ) );
		const o3 = sign( area( p2, q2, p1 ) );
		const o4 = sign( area( p2, q2, q1 ) );

		if ( o1 !== o2 && o3 !== o4 ) return true; // general case

		if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
		if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
		if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
		if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

		return false;

	}

	// for collinear points p, q, r, check if point q lies on segment pr
	function onSegment( p, q, r ) {

		return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

	}

	function sign( num ) {

		return num > 0 ? 1 : num < 0 ? - 1 : 0;

	}

	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon( a, b ) {

		let p = a;
		do {

			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
					intersects( p, p.next, a, b ) ) return true;
			p = p.next;

		} while ( p !== a );

		return false;

	}

	// check if a polygon diagonal is locally inside the polygon
	function locallyInside( a, b ) {

		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

	}

	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside( a, b ) {

		let p = a,
			inside = false;
		const px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
		do {

			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
					( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
				inside = ! inside;
			p = p.next;

		} while ( p !== a );

		return inside;

	}

	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon( a, b ) {

		const a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;

		a.next = b;
		b.prev = a;

		a2.next = an;
		an.prev = a2;

		b2.next = a2;
		a2.prev = b2;

		bp.next = b2;
		b2.prev = bp;

		return b2;

	}

	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode( i, x, y, last ) {

		const p = new Node( i, x, y );

		if ( ! last ) {

			p.prev = p;
			p.next = p;

		} else {

			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;

		}

		return p;

	}

	function removeNode( p ) {

		p.next.prev = p.prev;
		p.prev.next = p.next;

		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

	}

	function Node( i, x, y ) {

		// vertex index in coordinates array
		this.i = i;

		// vertex coordinates
		this.x = x;
		this.y = y;

		// previous and next vertex nodes in a polygon ring
		this.prev = null;
		this.next = null;

		// z-order curve value
		this.z = null;

		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;

		// indicates whether this is a steiner point
		this.steiner = false;

	}

	function signedArea( data, start, end, dim ) {

		let sum = 0;
		for ( let i = start, j = end - dim; i < end; i += dim ) {

			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;

		}

		return sum;

	}

	const ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			const n = contour.length;
			let a = 0.0;

			for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: function ( contour, holes ) {

			const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			const holeIndices = []; // array of hole indices
			const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

			removeDupEndPts( contour );
			addContour( vertices, contour );

			//

			let holeIndex = contour.length;

			holes.forEach( removeDupEndPts );

			for ( let i = 0; i < holes.length; i ++ ) {

				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );

			}

			//

			const triangles = Earcut.triangulate( vertices, holeIndices );

			//

			for ( let i = 0; i < triangles.length; i += 3 ) {

				faces.push( triangles.slice( i, i + 3 ) );

			}

			return faces;

		}

	};

	function removeDupEndPts( points ) {

		const l = points.length;

		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

			points.pop();

		}

	}

	function addContour( vertices, contour ) {

		for ( let i = 0; i < contour.length; i ++ ) {

			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );

		}

	}

	/**
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
	 *  bevelOffset: <float>, // how far from shape outline does bevel start
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */

	class ExtrudeGeometry extends BufferGeometry {

		constructor( shapes, options ) {

			super();

			this.type = 'ExtrudeGeometry';

			this.parameters = {
				shapes: shapes,
				options: options
			};

			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

			const scope = this;

			const verticesArray = [];
			const uvArray = [];

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];
				addShape( shape );

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

			this.computeVertexNormals();

			// functions

			function addShape( shape ) {

				const placeholder = [];

				// options

				const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
				const steps = options.steps !== undefined ? options.steps : 1;
				let depth = options.depth !== undefined ? options.depth : 100;

				let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
				let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
				let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
				let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
				let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

				const extrudePath = options.extrudePath;

				const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

				// deprecated options

				if ( options.amount !== undefined ) {

					console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
					depth = options.amount;

				}

				//

				let extrudePts, extrudeByPath = false;
				let splineTube, binormal, normal, position2;

				if ( extrudePath ) {

					extrudePts = extrudePath.getSpacedPoints( steps );

					extrudeByPath = true;
					bevelEnabled = false; // bevels not supported for path extrusion

					// SETUP TNB variables

					// TODO1 - have a .isClosed in spline?

					splineTube = extrudePath.computeFrenetFrames( steps, false );

					// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

					binormal = new Vector3();
					normal = new Vector3();
					position2 = new Vector3();

				}

				// Safeguards if bevels are not enabled

				if ( ! bevelEnabled ) {

					bevelSegments = 0;
					bevelThickness = 0;
					bevelSize = 0;
					bevelOffset = 0;

				}

				// Variables initialization

				const shapePoints = shape.extractPoints( curveSegments );

				let vertices = shapePoints.shape;
				const holes = shapePoints.holes;

				const reverse = ! ShapeUtils.isClockWise( vertices );

				if ( reverse ) {

					vertices = vertices.reverse();

					// Maybe we should also check if holes are in the opposite direction, just to be safe ...

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];

						if ( ShapeUtils.isClockWise( ahole ) ) {

							holes[ h ] = ahole.reverse();

						}

					}

				}


				const faces = ShapeUtils.triangulateShape( vertices, holes );

				/* Vertices */

				const contour = vertices; // vertices has all points but contour has only points of circumference

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					vertices = vertices.concat( ahole );

				}


				function scalePt2( pt, vec, size ) {

					if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

					return vec.clone().multiplyScalar( size ).add( pt );

				}

				const vlen = vertices.length, flen = faces.length;


				// Find directions for point movement


				function getBevelVec( inPt, inPrev, inNext ) {

					// computes for inPt the corresponding point inPt' on a new contour
					//   shifted by 1 unit (length of normalized vector) to the left
					// if we walk along contour clockwise, this new contour is outside the old one
					//
					// inPt' is the intersection of the two lines parallel to the two
					//  adjacent edges of inPt at a distance of 1 unit on the left side.

					let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

					// good reading for geometry algorithms (here: line-line intersection)
					// http://geomalgorithms.com/a05-_intersect-1.html

					const v_prev_x = inPt.x - inPrev.x,
						v_prev_y = inPt.y - inPrev.y;
					const v_next_x = inNext.x - inPt.x,
						v_next_y = inNext.y - inPt.y;

					const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

					// check for collinear edges
					const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

					if ( Math.abs( collinear0 ) > Number.EPSILON ) {

						// not collinear

						// length of vectors for normalizing

						const v_prev_len = Math.sqrt( v_prev_lensq );
						const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

						// shift adjacent points by unit vectors to the left

						const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
						const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

						const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
						const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

						// scaling factor for v_prev to intersection point

						const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
							( v_prev_x * v_next_y - v_prev_y * v_next_x );

						// vector from inPt to intersection point

						v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
						v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

						// Don't normalize!, otherwise sharp corners become ugly
						//  but prevent crazy spikes
						const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
						if ( v_trans_lensq <= 2 ) {

							return new Vector2( v_trans_x, v_trans_y );

						} else {

							shrink_by = Math.sqrt( v_trans_lensq / 2 );

						}

					} else {

						// handle special case of collinear edges

						let direction_eq = false; // assumes: opposite

						if ( v_prev_x > Number.EPSILON ) {

							if ( v_next_x > Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( v_prev_x < - Number.EPSILON ) {

								if ( v_next_x < - Number.EPSILON ) {

									direction_eq = true;

								}

							} else {

								if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

									direction_eq = true;

								}

							}

						}

						if ( direction_eq ) {

							// console.log("Warning: lines are a straight sequence");
							v_trans_x = - v_prev_y;
							v_trans_y = v_prev_x;
							shrink_by = Math.sqrt( v_prev_lensq );

						} else {

							// console.log("Warning: lines are a straight spike");
							v_trans_x = v_prev_x;
							v_trans_y = v_prev_y;
							shrink_by = Math.sqrt( v_prev_lensq / 2 );

						}

					}

					return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

				}


				const contourMovements = [];

				for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					// console.log('i,j,k', i, j , k)

					contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

				}

				const holesMovements = [];
				let oneHoleMovements, verticesMovements = contourMovements.concat();

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					oneHoleMovements = [];

					for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

						if ( j === il ) j = 0;
						if ( k === il ) k = 0;

						//  (j)---(i)---(k)
						oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

					}

					holesMovements.push( oneHoleMovements );
					verticesMovements = verticesMovements.concat( oneHoleMovements );

				}


				// Loop bevelSegments, 1 for the front, 1 for the back

				for ( let b = 0; b < bevelSegments; b ++ ) {

					//for ( b = bevelSegments; b > 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							v( vert.x, vert.y, - z );

						}

					}

				}

				const bs = bevelSize + bevelOffset;

				// Back facing vertices

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, 0 );

					} else {

						// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

						normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

				// Add stepped vertices...
				// Including front facing vertices

				for ( let s = 1; s <= steps; s ++ ) {

					for ( let i = 0; i < vlen; i ++ ) {

						const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth / steps * s );

						} else {

							// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

							normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
							binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

							position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

							v( position2.x, position2.y, position2.z );

						}

					}

				}


				// Add bevel segments planes

				//for ( b = 1; b <= bevelSegments; b ++ ) {
				for ( let b = bevelSegments - 1; b >= 0; b -- ) {

					const t = b / bevelSegments;
					const z = bevelThickness * Math.cos( t * Math.PI / 2 );
					const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

					// contract shape

					for ( let i = 0, il = contour.length; i < il; i ++ ) {

						const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
						v( vert.x, vert.y, depth + z );

					}

					// expand holes

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						oneHoleMovements = holesMovements[ h ];

						for ( let i = 0, il = ahole.length; i < il; i ++ ) {

							const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

							if ( ! extrudeByPath ) {

								v( vert.x, vert.y, depth + z );

							} else {

								v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

							}

						}

					}

				}

				/* Faces */

				// Top and bottom faces

				buildLidFaces();

				// Sides faces

				buildSideFaces();


				/////  Internal functions

				function buildLidFaces() {

					const start = verticesArray.length / 3;

					if ( bevelEnabled ) {

						let layer = 0; // steps + 1
						let offset = vlen * layer;

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

						}

						layer = steps + bevelSegments * 2;
						offset = vlen * layer;

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

						}

					} else {

						// Bottom faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 2 ], face[ 1 ], face[ 0 ] );

						}

						// Top faces

						for ( let i = 0; i < flen; i ++ ) {

							const face = faces[ i ];
							f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

						}

					}

					scope.addGroup( start, verticesArray.length / 3 - start, 0 );

				}

				// Create faces for the z-sides of the shape

				function buildSideFaces() {

					const start = verticesArray.length / 3;
					let layeroffset = 0;
					sidewalls( contour, layeroffset );
					layeroffset += contour.length;

					for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

						const ahole = holes[ h ];
						sidewalls( ahole, layeroffset );

						//, true
						layeroffset += ahole.length;

					}


					scope.addGroup( start, verticesArray.length / 3 - start, 1 );


				}

				function sidewalls( contour, layeroffset ) {

					let i = contour.length;

					while ( -- i >= 0 ) {

						const j = i;
						let k = i - 1;
						if ( k < 0 ) k = contour.length - 1;

						//console.log('b', i,j, i-1, k,vertices.length);

						for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

							const slen1 = vlen * s;
							const slen2 = vlen * ( s + 1 );

							const a = layeroffset + j + slen1,
								b = layeroffset + k + slen1,
								c = layeroffset + k + slen2,
								d = layeroffset + j + slen2;

							f4( a, b, c, d );

						}

					}

				}

				function v( x, y, z ) {

					placeholder.push( x );
					placeholder.push( y );
					placeholder.push( z );

				}


				function f3( a, b, c ) {

					addVertex( a );
					addVertex( b );
					addVertex( c );

					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );

				}

				function f4( a, b, c, d ) {

					addVertex( a );
					addVertex( b );
					addVertex( d );

					addVertex( b );
					addVertex( c );
					addVertex( d );


					const nextIndex = verticesArray.length / 3;
					const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

					addUV( uvs[ 0 ] );
					addUV( uvs[ 1 ] );
					addUV( uvs[ 3 ] );

					addUV( uvs[ 1 ] );
					addUV( uvs[ 2 ] );
					addUV( uvs[ 3 ] );

				}

				function addVertex( index ) {

					verticesArray.push( placeholder[ index * 3 + 0 ] );
					verticesArray.push( placeholder[ index * 3 + 1 ] );
					verticesArray.push( placeholder[ index * 3 + 2 ] );

				}


				function addUV( vector2 ) {

					uvArray.push( vector2.x );
					uvArray.push( vector2.y );

				}

			}

		}

		toJSON() {

			const data = BufferGeometry.prototype.toJSON.call( this );

			const shapes = this.parameters.shapes;
			const options = this.parameters.options;

			return toJSON( shapes, options, data );

		}

	}

	const WorldUVGenerator = {

		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];

			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];

		},

		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

			const a_x = vertices[ indexA * 3 ];
			const a_y = vertices[ indexA * 3 + 1 ];
			const a_z = vertices[ indexA * 3 + 2 ];
			const b_x = vertices[ indexB * 3 ];
			const b_y = vertices[ indexB * 3 + 1 ];
			const b_z = vertices[ indexB * 3 + 2 ];
			const c_x = vertices[ indexC * 3 ];
			const c_y = vertices[ indexC * 3 + 1 ];
			const c_z = vertices[ indexC * 3 + 2 ];
			const d_x = vertices[ indexD * 3 ];
			const d_y = vertices[ indexD * 3 + 1 ];
			const d_z = vertices[ indexD * 3 + 2 ];

			if ( Math.abs( a_y - b_y ) < 0.01 ) {

				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];

			} else {

				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];

			}

		}

	};

	function toJSON( shapes, options, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

		return data;

	}

	class IcosahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const t = ( 1 + Math.sqrt( 5 ) ) / 2;

			const vertices = [
				- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
				0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
				t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
			];

			const indices = [
				0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
				1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
				3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
				4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
			];

			super( vertices, indices, radius, detail );

			this.type = 'IcosahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

	}

	class LatheGeometry extends BufferGeometry {

		constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

			super();

			this.type = 'LatheGeometry';

			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};

			segments = Math.floor( segments );

			// clamp phiLength so it's in range of [ 0, 2PI ]

			phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );

			// buffers

			const indices = [];
			const vertices = [];
			const uvs = [];

			// helper variables

			const inverseSegments = 1.0 / segments;
			const vertex = new Vector3();
			const uv = new Vector2();

			// generate vertices and uvs

			for ( let i = 0; i <= segments; i ++ ) {

				const phi = phiStart + i * inverseSegments * phiLength;

				const sin = Math.sin( phi );
				const cos = Math.cos( phi );

				for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

					// vertex

					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;

					vertices.push( vertex.x, vertex.y, vertex.z );

					// uv

					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );

					uvs.push( uv.x, uv.y );


				}

			}

			// indices

			for ( let i = 0; i < segments; i ++ ) {

				for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

					const base = j + i * points.length;

					const a = base;
					const b = base + points.length;
					const c = base + points.length + 1;
					const d = base + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// generate normals

			this.computeVertexNormals();

			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).

			if ( phiLength === Math.PI * 2 ) {

				const normals = this.attributes.normal.array;
				const n1 = new Vector3();
				const n2 = new Vector3();
				const n = new Vector3();

				// this is the buffer offset for the last line of vertices

				const base = segments * points.length * 3;

				for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

					// select the normal of the vertex in the first line

					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];

					// select the normal of the vertex in the last line

					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];

					// average normals

					n.addVectors( n1, n2 ).normalize();

					// assign the new values to both normals

					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

				}

			}

		}

	}

	class OctahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const vertices = [
				1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
				0, - 1, 0, 	0, 0, 1,	0, 0, - 1
			];

			const indices = [
				0, 2, 4,	0, 4, 3,	0, 3, 5,
				0, 5, 2,	1, 2, 5,	1, 5, 3,
				1, 3, 4,	1, 4, 2
			];

			super( vertices, indices, radius, detail );

			this.type = 'OctahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

	}

	/**
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
	 */

	function ParametricGeometry( func, slices, stacks ) {

		BufferGeometry.call( this );

		this.type = 'ParametricGeometry';

		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		const EPS = 0.00001;

		const normal = new Vector3();

		const p0 = new Vector3(), p1 = new Vector3();
		const pu = new Vector3(), pv = new Vector3();

		if ( func.length < 3 ) {

			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

		}

		// generate vertices, normals and uvs

		const sliceCount = slices + 1;

		for ( let i = 0; i <= stacks; i ++ ) {

			const v = i / stacks;

			for ( let j = 0; j <= slices; j ++ ) {

				const u = j / slices;

				// vertex

				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );

				// normal

				// approximate tangent vectors via finite differences

				if ( u - EPS >= 0 ) {

					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );

				} else {

					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );

				}

				if ( v - EPS >= 0 ) {

					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );

				} else {

					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );

				}

				// cross product of tangent vectors returns surface normal

				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u, v );

			}

		}

		// generate indices

		for ( let i = 0; i < stacks; i ++ ) {

			for ( let j = 0; j < slices; j ++ ) {

				const a = i * sliceCount + j;
				const b = i * sliceCount + j + 1;
				const c = ( i + 1 ) * sliceCount + j + 1;
				const d = ( i + 1 ) * sliceCount + j;

				// faces one and two

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	ParametricGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;

	class PlaneGeometry extends BufferGeometry {

		constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

			super();
			this.type = 'PlaneGeometry';

			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};

			const width_half = width / 2;
			const height_half = height / 2;

			const gridX = Math.floor( widthSegments );
			const gridY = Math.floor( heightSegments );

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			const segment_width = width / gridX;
			const segment_height = height / gridY;

			//

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segment_height - height_half;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segment_width - width_half;

					vertices.push( x, - y, 0 );

					normals.push( 0, 0, 1 );

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

				}

			}

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = ix + gridX1 * iy;
					const b = ix + gridX1 * ( iy + 1 );
					const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = ( ix + 1 ) + gridX1 * iy;

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class RingGeometry extends BufferGeometry {

		constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

			super();

			this.type = 'RingGeometry';

			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			thetaSegments = Math.max( 3, thetaSegments );
			phiSegments = Math.max( 1, phiSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// some helper variables

			let radius = innerRadius;
			const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			const vertex = new Vector3();
			const uv = new Vector2();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= phiSegments; j ++ ) {

				for ( let i = 0; i <= thetaSegments; i ++ ) {

					// values are generate from the inside of the ring to the outside

					const segment = thetaStart + i / thetaSegments * thetaLength;

					// vertex

					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normals.push( 0, 0, 1 );

					// uv

					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;

					uvs.push( uv.x, uv.y );

				}

				// increase the radius for next row of vertices

				radius += radiusStep;

			}

			// indices

			for ( let j = 0; j < phiSegments; j ++ ) {

				const thetaSegmentLevel = j * ( thetaSegments + 1 );

				for ( let i = 0; i < thetaSegments; i ++ ) {

					const segment = i + thetaSegmentLevel;

					const a = segment;
					const b = segment + thetaSegments + 1;
					const c = segment + thetaSegments + 2;
					const d = segment + 1;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class ShapeGeometry extends BufferGeometry {

		constructor( shapes, curveSegments = 12 ) {

			super();
			this.type = 'ShapeGeometry';

			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			let groupStart = 0;
			let groupCount = 0;

			// allow single and array values for "shapes" parameter

			if ( Array.isArray( shapes ) === false ) {

				addShape( shapes );

			} else {

				for ( let i = 0; i < shapes.length; i ++ ) {

					addShape( shapes[ i ] );

					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

					groupStart += groupCount;
					groupCount = 0;

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


			// helper functions

			function addShape( shape ) {

				const indexOffset = vertices.length / 3;
				const points = shape.extractPoints( curveSegments );

				let shapeVertices = points.shape;
				const shapeHoles = points.holes;

				// check direction of vertices

				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

					shapeVertices = shapeVertices.reverse();

				}

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];

					if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

						shapeHoles[ i ] = shapeHole.reverse();

					}

				}

				const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

				// join vertices of inner and outer paths to a single array

				for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

					const shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );

				}

				// vertices, normals, uvs

				for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

					const vertex = shapeVertices[ i ];

					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs

				}

				// incides

				for ( let i = 0, l = faces.length; i < l; i ++ ) {

					const face = faces[ i ];

					const a = face[ 0 ] + indexOffset;
					const b = face[ 1 ] + indexOffset;
					const c = face[ 2 ] + indexOffset;

					indices.push( a, b, c );
					groupCount += 3;

				}

			}

		}

		toJSON() {

			const data = BufferGeometry.prototype.toJSON.call( this );

			const shapes = this.parameters.shapes;

			return toJSON$1( shapes, data );

		}

	}

	function toJSON$1( shapes, data ) {

		data.shapes = [];

		if ( Array.isArray( shapes ) ) {

			for ( let i = 0, l = shapes.length; i < l; i ++ ) {

				const shape = shapes[ i ];

				data.shapes.push( shape.uuid );

			}

		} else {

			data.shapes.push( shapes.uuid );

		}

		return data;

	}

	class SphereGeometry extends BufferGeometry {

		constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

			super();
			this.type = 'SphereGeometry';

			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};

			widthSegments = Math.max( 3, Math.floor( widthSegments ) );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) );

			const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

			let index = 0;
			const grid = [];

			const vertex = new Vector3();
			const normal = new Vector3();

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// generate vertices, normals and uvs

			for ( let iy = 0; iy <= heightSegments; iy ++ ) {

				const verticesRow = [];

				const v = iy / heightSegments;

				// special case for the poles

				let uOffset = 0;

				if ( iy == 0 && thetaStart == 0 ) {

					uOffset = 0.5 / widthSegments;

				} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

					uOffset = - 0.5 / widthSegments;

				}

				for ( let ix = 0; ix <= widthSegments; ix ++ ) {

					const u = ix / widthSegments;

					// vertex

					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.copy( vertex ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u + uOffset, 1 - v );

					verticesRow.push( index ++ );

				}

				grid.push( verticesRow );

			}

			// indices

			for ( let iy = 0; iy < heightSegments; iy ++ ) {

				for ( let ix = 0; ix < widthSegments; ix ++ ) {

					const a = grid[ iy ][ ix + 1 ];
					const b = grid[ iy ][ ix ];
					const c = grid[ iy + 1 ][ ix ];
					const d = grid[ iy + 1 ][ ix + 1 ];

					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class TetrahedronGeometry extends PolyhedronGeometry {

		constructor( radius = 1, detail = 0 ) {

			const vertices = [
				1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
			];

			const indices = [
				2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
			];

			super( vertices, indices, radius, detail );

			this.type = 'TetrahedronGeometry';

			this.parameters = {
				radius: radius,
				detail: detail
			};

		}

	}

	/**
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
	 *  bevelOffset: <float> // how far from text outline does bevel start
	 * }
	 */

	class TextGeometry extends ExtrudeGeometry {

		constructor( text, parameters = {} ) {

			const font = parameters.font;

			if ( ! ( font && font.isFont ) ) {

				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new BufferGeometry();

			}

			const shapes = font.generateShapes( text, parameters.size );

			// translate parameters to ExtrudeGeometry API

			parameters.depth = parameters.height !== undefined ? parameters.height : 50;

			// defaults

			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

			super( shapes, parameters );

			this.type = 'TextGeometry';

		}

	}

	class TorusGeometry extends BufferGeometry {

		constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

			super();
			this.type = 'TorusGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};

			radialSegments = Math.floor( radialSegments );
			tubularSegments = Math.floor( tubularSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const center = new Vector3();
			const vertex = new Vector3();
			const normal = new Vector3();

			// generate vertices, normals and uvs

			for ( let j = 0; j <= radialSegments; j ++ ) {

				for ( let i = 0; i <= tubularSegments; i ++ ) {

					const u = i / tubularSegments * arc;
					const v = j / radialSegments * Math.PI * 2;

					// vertex

					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( let j = 1; j <= radialSegments; j ++ ) {

				for ( let i = 1; i <= tubularSegments; i ++ ) {

					// indices

					const a = ( tubularSegments + 1 ) * j + i - 1;
					const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					const d = ( tubularSegments + 1 ) * j + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		}

	}

	class TorusKnotGeometry extends BufferGeometry {

		constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

			super();
			this.type = 'TorusKnotGeometry';

			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};

			tubularSegments = Math.floor( tubularSegments );
			radialSegments = Math.floor( radialSegments );

			// buffers

			const indices = [];
			const vertices = [];
			const normals = [];
			const uvs = [];

			// helper variables

			const vertex = new Vector3();
			const normal = new Vector3();

			const P1 = new Vector3();
			const P2 = new Vector3();

			const B = new Vector3();
			const T = new Vector3();
			const N = new Vector3();

			// generate vertices, normals and uvs

			for ( let i = 0; i <= tubularSegments; ++ i ) {

				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

				const u = i / tubularSegments * p * Math.PI * 2;

				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

				// calculate orthonormal basis

				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );

				// normalize B, N. T can be ignored, we don't use it

				B.normalize();
				N.normalize();

				for ( let j = 0; j <= radialSegments; ++ j ) {

					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

					const v = j / radialSegments * Math.PI * 2;
					const cx = - tube * Math.cos( v );
					const cy = tube * Math.sin( v );

					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );

					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

					normal.subVectors( vertex, P1 ).normalize();

					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );

				}

			}

			// generate indices

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					// indices

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// this function calculates the current position on the torus curve

			function calculatePositionOnCurve( u, p, q, radius, position ) {

				const cu = Math.cos( u );
				const su = Math.sin( u );
				const quOverP = q / p * u;
				const cs = Math.cos( quOverP );

				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;

			}

		}

	}

	class TubeGeometry extends BufferGeometry {

		constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

			super();
			this.type = 'TubeGeometry';

			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};

			const frames = path.computeFrenetFrames( tubularSegments, closed );

			// expose internals

			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;

			// helper variables

			const vertex = new Vector3();
			const normal = new Vector3();
			const uv = new Vector2();
			let P = new Vector3();

			// buffer

			const vertices = [];
			const normals = [];
			const uvs = [];
			const indices = [];

			// create buffer data

			generateBufferData();

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			// functions

			function generateBufferData() {

				for ( let i = 0; i < tubularSegments; i ++ ) {

					generateSegment( i );

				}

				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

				generateSegment( ( closed === false ) ? tubularSegments : 0 );

				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries

				generateUVs();

				// finally create faces

				generateIndices();

			}

			function generateSegment( i ) {

				// we use getPointAt to sample evenly distributed points from the given path

				P = path.getPointAt( i / tubularSegments, P );

				// retrieve corresponding normal and binormal

				const N = frames.normals[ i ];
				const B = frames.binormals[ i ];

				// generate normals and vertices for the current segment

				for ( let j = 0; j <= radialSegments; j ++ ) {

					const v = j / radialSegments * Math.PI * 2;

					const sin = Math.sin( v );
					const cos = - Math.cos( v );

					// normal

					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();

					normals.push( normal.x, normal.y, normal.z );

					// vertex

					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;

					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

			function generateIndices() {

				for ( let j = 1; j <= tubularSegments; j ++ ) {

					for ( let i = 1; i <= radialSegments; i ++ ) {

						const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						const b = ( radialSegments + 1 ) * j + ( i - 1 );
						const c = ( radialSegments + 1 ) * j + i;
						const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

					}

				}

			}

			function generateUVs() {

				for ( let i = 0; i <= tubularSegments; i ++ ) {

					for ( let j = 0; j <= radialSegments; j ++ ) {

						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;

						uvs.push( uv.x, uv.y );

					}

				}

			}

		}
		toJSON() {

			const data = BufferGeometry.prototype.toJSON.call( this );

			data.path = this.parameters.path.toJSON();

			return data;

		}

	}

	class WireframeGeometry extends BufferGeometry {

		constructor( geometry ) {

			super();
			this.type = 'WireframeGeometry';

			if ( geometry.isGeometry === true ) {

				console.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
				return;

			}

			// buffer

			const vertices = [];

			// helper variables

			const edge = [ 0, 0 ], edges = {};

			const vertex = new Vector3();

			if ( geometry.index !== null ) {

				// indexed BufferGeometry

				const position = geometry.attributes.position;
				const indices = geometry.index;
				let groups = geometry.groups;

				if ( groups.length === 0 ) {

					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

				}

				// create a data structure that contains all eges without duplicates

				for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

					const group = groups[ o ];

					const start = group.start;
					const count = group.count;

					for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

						for ( let j = 0; j < 3; j ++ ) {

							const edge1 = indices.getX( i + j );
							const edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );

							const key = edge[ 0 ] + ',' + edge[ 1 ];

							if ( edges[ key ] === undefined ) {

								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

							}

						}

					}

				}

				// generate vertices

				for ( const key in edges ) {

					const e = edges[ key ];

					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			} else {

				// non-indexed BufferGeometry

				const position = geometry.attributes.position;

				for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

					for ( let j = 0; j < 3; j ++ ) {

						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

						const index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );

						const index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );

					}

				}

			}

			// build geometry

			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

		}

	}

	var Geometries = /*#__PURE__*/Object.freeze({
		__proto__: null,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronGeometry,
		EdgesGeometry: EdgesGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeGeometry,
		WireframeGeometry: WireframeGeometry
	});

	class ObjectLoader extends Loader {

		constructor( manager ) {

			super( manager );

		}

		load( url, onLoad, onProgress, onError ) {

			const scope = this;

			const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( text ) {

				let json = null;

				try {

					json = JSON.parse( text );

				} catch ( error ) {

					if ( onError !== undefined ) onError( error );

					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

					return;

				}

				const metadata = json.metadata;

				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
					return;

				}

				scope.parse( json, onLoad );

			}, onProgress, onError );

		}

		parse( json, onLoad ) {

			const animations = this.parseAnimations( json.animations );
			const shapes = this.parseShapes( json.shapes );
			const geometries = this.parseGeometries( json.geometries, shapes );

			const images = this.parseImages( json.images, function () {

				if ( onLoad !== undefined ) onLoad( object );

			} );

			const textures = this.parseTextures( json.textures, images );
			const materials = this.parseMaterials( json.materials, textures );

			const object = this.parseObject( json.object, geometries, materials, animations );
			const skeletons = this.parseSkeletons( json.skeletons, object );

			this.bindSkeletons( object, skeletons );

			//

			if ( onLoad !== undefined ) {

				let hasImages = false;

				for ( const uuid in images ) {

					if ( images[ uuid ] instanceof HTMLImageElement ) {

						hasImages = true;
						break;

					}

				}

				if ( hasImages === false ) onLoad( object );

			}

			return object;

		}

		parseShapes( json ) {

			const shapes = {};

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const shape = new Shape().fromJSON( json[ i ] );

					shapes[ shape.uuid ] = shape;

				}

			}

			return shapes;

		}

		parseSkeletons( json, object ) {

			const skeletons = {};
			const bones = {};

			// generate bone lookup table

			object.traverse( function ( child ) {

				if ( child.isBone ) bones[ child.uuid ] = child;

			} );

			// create skeletons

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const skeleton = new Skeleton().fromJSON( json[ i ], bones );

					skeletons[ skeleton.uuid ] = skeleton;

				}

			}

			return skeletons;

		}

		parseGeometries( json, shapes ) {

			const geometries = {};
			let geometryShapes;

			if ( json !== undefined ) {

				const bufferGeometryLoader = new BufferGeometryLoader();

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					let geometry;
					const data = json[ i ];

					switch ( data.type ) {

						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);

							break;

						case 'BoxGeometry':
						case 'BoxBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);

							break;

						case 'CircleGeometry':
						case 'CircleBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'ConeGeometry':
						case 'ConeBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'SphereGeometry':
						case 'SphereBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);

							break;

						case 'RingGeometry':
						case 'RingBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);

							break;

						case 'TorusGeometry':
						case 'TorusBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);

							break;

						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);

							break;

						case 'TubeGeometry':
						case 'TubeBufferGeometry':

							// This only works for built-in curves (e.g. CatmullRomCurve3).
							// User defined curves or instances of CurvePath will not be deserialized.
							geometry = new Geometries[ data.type ](
								new Curves[ data.path.type ]().fromJSON( data.path ),
								data.tubularSegments,
								data.radius,
								data.radialSegments,
								data.closed
							);

							break;

						case 'LatheGeometry':
						case 'LatheBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);

							break;

						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':

							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);

							break;

						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':

							geometryShapes = [];

							for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								const shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);

							break;


						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':

							geometryShapes = [];

							for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

								const shape = shapes[ data.shapes[ j ] ];

								geometryShapes.push( shape );

							}

							const extrudePath = data.options.extrudePath;

							if ( extrudePath !== undefined ) {

								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

							}

							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);

							break;

						case 'BufferGeometry':
						case 'InstancedBufferGeometry':

							geometry = bufferGeometryLoader.parse( data );

							break;

						case 'Geometry':

							console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

							break;

						default:

							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

							continue;

					}

					geometry.uuid = data.uuid;

					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

					geometries[ data.uuid ] = geometry;

				}

			}

			return geometries;

		}

		parseMaterials( json, textures ) {

			const cache = {}; // MultiMaterial
			const materials = {};

			if ( json !== undefined ) {

				const loader = new MaterialLoader();
				loader.setTextures( textures );

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const data = json[ i ];

					if ( data.type === 'MultiMaterial' ) {

						// Deprecated

						const array = [];

						for ( let j = 0; j < data.materials.length; j ++ ) {

							const material = data.materials[ j ];

							if ( cache[ material.uuid ] === undefined ) {

								cache[ material.uuid ] = loader.parse( material );

							}

							array.push( cache[ material.uuid ] );

						}

						materials[ data.uuid ] = array;

					} else {

						if ( cache[ data.uuid ] === undefined ) {

							cache[ data.uuid ] = loader.parse( data );

						}

						materials[ data.uuid ] = cache[ data.uuid ];

					}

				}

			}

			return materials;

		}

		parseAnimations( json ) {

			const animations = {};

			if ( json !== undefined ) {

				for ( let i = 0; i < json.length; i ++ ) {

					const data = json[ i ];

					const clip = AnimationClip.parse( data );

					animations[ clip.uuid ] = clip;

				}

			}

			return animations;

		}

		parseImages( json, onLoad ) {

			const scope = this;
			const images = {};

			let loader;

			function loadImage( url ) {

				scope.manager.itemStart( url );

				return loader.load( url, function () {

					scope.manager.itemEnd( url );

				}, undefined, function () {

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				} );

			}

			function deserializeImage( image ) {

				if ( typeof image === 'string' ) {

					const url = image;

					const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

					return loadImage( path );

				} else {

					if ( image.data ) {

						return {
							data: getTypedArray( image.type, image.data ),
							width: image.width,
							height: image.height
						};

					} else {

						return null;

					}

				}

			}

			if ( json !== undefined && json.length > 0 ) {

				const manager = new LoadingManager( onLoad );

				loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );

				for ( let i = 0, il = json.length; i < il; i ++ ) {

					const image = json[ i ];
					const url = image.url;

					if ( Array.isArray( url ) ) {

						// load array of images e.g CubeTexture

						images[ image.uuid ] = [];

						for ( let j = 0, jl = url.length; j < jl; j ++ ) {

							const currentUrl = url[ j ];

							const deserializedImage = deserializeImage( currentUrl );

							if ( deserializedImage !== null ) {

								if ( deserializedImage instanceof HTMLImageElement ) {

									images[ image.uuid ].push( deserializedImage );

								} else {

									// special case: handle array of data textures for cube textures

									images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

								}

							}

						}

					} else {

						// load single image

						const deserializedImage = deserializeImage( image.url );

						if ( deserializedImage !== null ) {

							images[ image.uuid ] = deserializedImage;

						}

					}

				}

			}

			return images;

		}

		parseTextures( json, images ) {

			function parseConstant( value, type ) {

				if ( typeof value === 'number' ) return value;

				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

				return type[ value ];

			}

			const textures = {};

			if ( json !== undefined ) {

				for ( let i = 0, l = json.length; i < l; i ++ ) {

					const data = json[ i ];

					if ( data.image === undefined ) {

						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

					}

					if ( images[ data.image ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

					}

					let texture;
					const image = images[ data.image ];

					if ( Array.isArray( image ) ) {

						texture = new CubeTexture( image );

						if ( image.length === 6 ) texture.needsUpdate = true;

					} else {

						if ( image && image.data ) {

							texture = new DataTexture( image.data, image.width, image.height );

						} else {

							texture = new Texture( image );

						}

						if ( image ) texture.needsUpdate = true; // textures can have undefined image data

					}

					texture.uuid = data.uuid;

					if ( data.name !== undefined ) texture.name = data.name;

					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;

					if ( data.wrap !== undefined ) {

						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

					}

					if ( data.format !== undefined ) texture.format = data.format;
					if ( data.type !== undefined ) texture.type = data.type;
					if ( data.encoding !== undefined ) texture.encoding = data.encoding;

					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

					if ( data.flipY !== undefined ) texture.flipY = data.flipY;

					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

					textures[ data.uuid ] = texture;

				}

			}

			return textures;

		}

		parseObject( data, geometries, materials, animations ) {

			let object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( Array.isArray( name ) ) {

					const array = [];

					for ( let i = 0, l = name.length; i < l; i ++ ) {

						const uuid = name[ i ];

						if ( materials[ uuid ] === undefined ) {

							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

						}

						array.push( materials[ uuid ] );

					}

					return array;

				}

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			let geometry, material;

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'RectAreaLight':

					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'LightProbe':

					object = new LightProbe().fromJSON( data );

					break;

				case 'SkinnedMesh':

					geometry = getGeometry( data.geometry );
				 	material = getMaterial( data.material );

					object = new SkinnedMesh( geometry, material );

					if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
					if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
					if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

					break;

				case 'Mesh':

					geometry = getGeometry( data.geometry );
					material = getMaterial( data.material );

					object = new Mesh( geometry, material );

					break;

				case 'InstancedMesh':

					geometry = getGeometry( data.geometry );
					material = getMaterial( data.material );
					const count = data.count;
					const instanceMatrix = data.instanceMatrix;

					object = new InstancedMesh( geometry, material, count );
					object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineLoop':

					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				case 'Bone':

					object = new Bone();

					break;

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;

			if ( data.matrix !== undefined ) {

				object.matrix.fromArray( data.matrix );

				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;

			if ( data.children !== undefined ) {

				const children = data.children;

				for ( let i = 0; i < children.length; i ++ ) {

					object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

				}

			}

			if ( data.animations !== undefined ) {

				const objectAnimations = data.animations;

				for ( let i = 0; i < objectAnimations.length; i ++ ) {

					const uuid = objectAnimations[ i ];

					object.animations.push( animations[ uuid ] );

				}

			}

			if ( data.type === 'LOD' ) {

				if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

				const levels = data.levels;

				for ( let l = 0; l < levels.length; l ++ ) {

					const level = levels[ l ];
					const child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		}

		bindSkeletons( object, skeletons ) {

			if ( Object.keys( skeletons ).length === 0 ) return;

			object.traverse( function ( child ) {

				if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

					const skeleton = skeletons[ child.skeleton ];

					if ( skeleton === undefined ) {

						console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

					} else {

						child.bind( skeleton, child.bindMatrix );

					}

				}

			} );

		}

		/* DEPRECATED */

		setTexturePath( value ) {

			console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
			return this.setResourcePath( value );

		}

	}

	const TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};

	const TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};

	const TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};

	//

	QUnit.assert.success = function ( message ) {

		// Equivalent to assert( true, message );
		this.pushResult( {
			result: true,
			actual: undefined,
			expected: undefined,
			message: message
		} );

	};

	QUnit.assert.fail = function ( message ) {

		// Equivalent to assert( false, message );
		this.pushResult( {
			result: false,
			actual: undefined,
			expected: undefined,
			message: message
		} );

	};

	QUnit.assert.numEqual = function ( actual, expected, message ) {

		var diff = Math.abs( actual - expected );
		message = message || ( actual + " should be equal to " + expected );
		this.pushResult( {
			result: diff < 0.1,
			actual: actual,
			expected: expected,
			message: message
		} );

	};

	QUnit.assert.equalKey = function ( obj, ref, key ) {

		var actual = obj[ key ];
		var expected = ref[ key ];
		var message = actual + ' should be equal to ' + expected + ' for key "' + key + '"';
		this.pushResult( {
			result: actual == expected,
			actual: actual,
			expected: expected,
			message: message
		} );

	};

	QUnit.assert.smartEqual = function ( actual, expected, message ) {

		var cmp = new SmartComparer();

		var same = cmp.areEqual( actual, expected );
		var msg = cmp.getDiagnostic() || message;

		this.pushResult( {
			result: same,
			actual: actual,
			expected: expected,
			message: msg
		} );

	};

	//
	//	GEOMETRY TEST HELPERS
	//

	function checkGeometryClone( geom ) {

		// Clone
		var copy = geom.clone();
		QUnit.assert.notEqual( copy.uuid, geom.uuid, "clone uuid should differ from original" );
		QUnit.assert.notEqual( copy.id, geom.id, "clone id should differ from original" );

		var excludedProperties = [ 'parameters', 'widthSegments', 'heightSegments', 'depthSegments' ];

		var differingProp = getDifferingProp( geom, copy, excludedProperties );
		QUnit.assert.ok( differingProp === undefined, 'properties are equal' );

		differingProp = getDifferingProp( copy, geom, excludedProperties );
		QUnit.assert.ok( differingProp === undefined, 'properties are equal' );

		// json round trip with clone
		checkGeometryJsonRoundtrip( copy );

	}

	function getDifferingProp( geometryA, geometryB, excludedProperties ) {

		excludedProperties = excludedProperties || [];

		var geometryKeys = Object.keys( geometryA );
		var cloneKeys = Object.keys( geometryB );

		var differingProp = undefined;

		for ( var i = 0, l = geometryKeys.length; i < l; i ++ ) {

			var key = geometryKeys[ i ];

			if ( excludedProperties.indexOf( key ) >= 0 ) continue;

			if ( cloneKeys.indexOf( key ) < 0 ) {

				differingProp = key;
				break;

			}

		}

		return differingProp;

	}

	// Compare json file with its source geometry.
	function checkGeometryJsonWriting( geom, json ) {

		QUnit.assert.equal( json.metadata.version, "4.5", "check metadata version" );
		QUnit.assert.equalKey( geom, json, 'type' );
		QUnit.assert.equalKey( geom, json, 'uuid' );
		QUnit.assert.equal( json.id, undefined, "should not persist id" );

		var params = geom.parameters;
		if ( ! params ) {

			return;

		}

		// All parameters from geometry should be persisted.
		var keys = Object.keys( params );
		for ( var i = 0, l = keys.length; i < l; i ++ ) {

			QUnit.assert.equalKey( params, json, keys[ i ] );

		}

		// All parameters from json should be transfered to the geometry.
		// json is flat. Ignore first level json properties that are not parameters.
		var notParameters = [ "metadata", "uuid", "type" ];
		var keys = Object.keys( json );
		for ( var i = 0, l = keys.length; i < l; i ++ ) {

			var key = keys[ i ];
			if ( notParameters.indexOf( key ) === - 1 ) QUnit.assert.equalKey( params, json, key );

		}

	}

	// Check parsing and reconstruction of json geometry
	function checkGeometryJsonReading( json, geom ) {

		var wrap = [ json ];

		var loader = new ObjectLoader();
		var output = loader.parseGeometries( wrap );

		QUnit.assert.ok( output[ geom.uuid ], 'geometry matching source uuid not in output' );
		// QUnit.assert.smartEqual( output[ geom.uuid ], geom, 'Reconstruct geometry from ObjectLoader' );

		var differing = getDifferingProp( output[ geom.uuid ], geom, [ 'bones' ] );
		if ( differing ) console.log( differing );

		var excludedProperties = [ 'bones' ];

		var differingProp = getDifferingProp( output[ geom.uuid ], geom, excludedProperties );
		QUnit.assert.ok( differingProp === undefined, 'properties are equal' );

		differingProp = getDifferingProp( geom, output[ geom.uuid ], excludedProperties );
		QUnit.assert.ok( differingProp === undefined, 'properties are equal' );

	}

	// Verify geom -> json -> geom
	function checkGeometryJsonRoundtrip( geom ) {

		var json = geom.toJSON();
		checkGeometryJsonWriting( geom, json );
		checkGeometryJsonReading( json, geom );

	}

	// Look for undefined and NaN values in numerical fieds.
	function checkFinite( geom ) {

		var allVerticesAreFinite = true;

		var vertices = geom.vertices || [];

		for ( var i = 0, l = vertices.length; i < l; i ++ ) {

			var v = geom.vertices[ i ];

			if ( ! ( isFinite( v.x ) || isFinite( v.y ) || isFinite( v.z ) ) ) {

				allVerticesAreFinite = false;
				break;

			}

		}

		// TODO Buffers, normal, etc.

		QUnit.assert.ok( allVerticesAreFinite, "contains only finite coordinates" );

	}

	// Run common geometry tests.
	function runStdGeometryTests( assert, geometries ) {

		for ( var i = 0, l = geometries.length; i < l; i ++ ) {

			var geom = geometries[ i ];

			checkFinite( geom );

			// Clone
			checkGeometryClone( geom );

			// json round trip
			checkGeometryJsonRoundtrip( geom );

		}

	}

	//
	//	LIGHT TEST HELPERS
	//

	// Run common light tests.
	function runStdLightTests( assert, lights ) {

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			// copy and clone
			checkLightCopyClone( assert, light );

			// THREE.Light doesn't get parsed by ObjectLoader as it's only
			// used as an abstract base class - so we skip the JSON tests
			if ( light.type !== "Light" ) {

				// json round trip
				checkLightJsonRoundtrip( assert, light );

			}

		}

	}

	function checkLightCopyClone( assert, light ) {

		// copy
		var newLight = new light.constructor( 0xc0ffee );
		newLight.copy( light );

		QUnit.assert.notEqual( newLight.uuid, light.uuid, "Copied light's UUID differs from original" );
		QUnit.assert.notEqual( newLight.id, light.id, "Copied light's id differs from original" );
		QUnit.assert.smartEqual( newLight, light, "Copied light is equal to original" );

		// real copy?
		newLight.color.setHex( 0xc0ffee );
		QUnit.assert.notStrictEqual(
			newLight.color.getHex(), light.color.getHex(), "Copied light is independent from original"
		);

		// Clone
		var clone = light.clone(); // better get a new var
		QUnit.assert.notEqual( clone.uuid, light.uuid, "Cloned light's UUID differs from original" );
		QUnit.assert.notEqual( clone.id, light.id, "Clone light's id differs from original" );
		QUnit.assert.smartEqual( clone, light, "Clone light is equal to original" );

		// real clone?
		clone.color.setHex( 0xc0ffee );
		QUnit.assert.notStrictEqual(
			clone.color.getHex(), light.color.getHex(), "Clone light is independent from original"
		);

		if ( light.type !== "Light" ) {

			// json round trip with clone
			checkLightJsonRoundtrip( assert, clone );

		}

	}

	// Compare json file with its source Light.
	function checkLightJsonWriting( assert, light, json ) {

		assert.equal( json.metadata.version, "4.5", "check metadata version" );

		var object = json.object;
		assert.equalKey( light, object, 'type' );
		assert.equalKey( light, object, 'uuid' );
		assert.equal( object.id, undefined, "should not persist id" );

	}

	// Check parsing and reconstruction of json Light
	function checkLightJsonReading( assert, json, light ) {

		var loader = new ObjectLoader();
		var outputLight = loader.parse( json );

		assert.smartEqual( outputLight, light, 'Reconstruct Light from ObjectLoader' );

	}

	// Verify light -> json -> light
	function checkLightJsonRoundtrip( assert, light ) {

		var json = light.toJSON();
		checkLightJsonWriting( assert, light, json );
		checkLightJsonReading( assert, json, light );

	}

	/* global QUnit */

	QUnit.module( 'Constants', () => {

		QUnit.test( "default values", ( assert ) => {

			assert.propEqual( MOUSE, { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }, 'MOUSE equal { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }' );
			assert.propEqual( TOUCH, { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, 'TOUCH equal { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }' );
			assert.equal( CullFaceNone, 0, 'CullFaceNone equal 0' );
			assert.equal( CullFaceBack, 1, 'CullFaceBack equal 1' );
			assert.equal( CullFaceFront, 2, 'CullFaceFront is equal to 2' );
			assert.equal( CullFaceFrontBack, 3, 'CullFaceFrontBack is equal to 3' );
			assert.equal( BasicShadowMap, 0, 'BasicShadowMap is equal to 0' );
			assert.equal( PCFShadowMap, 1, 'PCFShadowMap is equal to 1' );
			assert.equal( PCFSoftShadowMap, 2, 'PCFSoftShadowMap is equal to 2' );
			assert.equal( FrontSide, 0, 'FrontSide is equal to 0' );
			assert.equal( BackSide, 1, 'BackSide is equal to 1' );
			assert.equal( DoubleSide, 2, 'DoubleSide is equal to 2' );
			assert.equal( FlatShading, 1, 'FlatShading is equal to 1' );
			assert.equal( SmoothShading, 2, 'SmoothShading is equal to 2' );
			assert.equal( NoBlending, 0, 'NoBlending is equal to 0' );
			assert.equal( NormalBlending, 1, 'NormalBlending is equal to 1' );
			assert.equal( AdditiveBlending, 2, 'AdditiveBlending is equal to 2' );
			assert.equal( SubtractiveBlending, 3, 'SubtractiveBlending is equal to 3' );
			assert.equal( MultiplyBlending, 4, 'MultiplyBlending is equal to 4' );
			assert.equal( CustomBlending, 5, 'CustomBlending is equal to 5' );
			assert.equal( AddEquation, 100, 'AddEquation is equal to 100' );
			assert.equal( SubtractEquation, 101, 'SubtractEquation is equal to 101' );
			assert.equal( ReverseSubtractEquation, 102, 'ReverseSubtractEquation is equal to 102' );
			assert.equal( MinEquation, 103, 'MinEquation is equal to 103' );
			assert.equal( MaxEquation, 104, 'MaxEquation is equal to 104' );
			assert.equal( ZeroFactor, 200, 'ZeroFactor is equal to 200' );
			assert.equal( OneFactor, 201, 'OneFactor is equal to 201' );
			assert.equal( SrcColorFactor, 202, 'SrcColorFactor is equal to 202' );
			assert.equal( OneMinusSrcColorFactor, 203, 'OneMinusSrcColorFactor is equal to 203' );
			assert.equal( SrcAlphaFactor, 204, 'SrcAlphaFactor is equal to 204' );
			assert.equal( OneMinusSrcAlphaFactor, 205, 'OneMinusSrcAlphaFactor is equal to 205' );
			assert.equal( DstAlphaFactor, 206, 'DstAlphaFactor is equal to 206' );
			assert.equal( OneMinusDstAlphaFactor, 207, 'OneMinusDstAlphaFactor is equal to 207' );
			assert.equal( DstColorFactor, 208, 'DstColorFactor is equal to 208' );
			assert.equal( OneMinusDstColorFactor, 209, 'OneMinusDstColorFactor is equal to 209' );
			assert.equal( SrcAlphaSaturateFactor, 210, 'SrcAlphaSaturateFactor is equal to 210' );
			assert.equal( NeverDepth, 0, 'NeverDepth is equal to 0' );
			assert.equal( AlwaysDepth, 1, 'AlwaysDepth is equal to 1' );
			assert.equal( LessDepth, 2, 'LessDepth is equal to 2' );
			assert.equal( LessEqualDepth, 3, 'LessEqualDepth is equal to 3' );
			assert.equal( EqualDepth, 4, 'EqualDepth is equal to 4' );
			assert.equal( GreaterEqualDepth, 5, 'GreaterEqualDepth is equal to 5' );
			assert.equal( GreaterDepth, 6, 'GreaterDepth is equal to 6' );
			assert.equal( NotEqualDepth, 7, 'NotEqualDepth is equal to 7' );
			assert.equal( MultiplyOperation, 0, 'MultiplyOperation is equal to 0' );
			assert.equal( MixOperation, 1, 'MixOperation is equal to 1' );
			assert.equal( AddOperation, 2, 'AddOperation is equal to 2' );
			assert.equal( NoToneMapping, 0, 'NoToneMapping is equal to 0' );
			assert.equal( LinearToneMapping, 1, 'LinearToneMapping is equal to 1' );
			assert.equal( ReinhardToneMapping, 2, 'ReinhardToneMapping is equal to 2' );
			assert.equal( CineonToneMapping, 3, 'CineonToneMapping is equal to 3' );
			assert.equal( ACESFilmicToneMapping, 4, 'ACESFilmicToneMapping is equal to 4' );
			assert.equal( UVMapping, 300, 'UVMapping is equal to 300' );
			assert.equal( CubeReflectionMapping, 301, 'CubeReflectionMapping is equal to 301' );
			assert.equal( CubeRefractionMapping, 302, 'CubeRefractionMapping is equal to 302' );
			assert.equal( EquirectangularReflectionMapping, 303, 'EquirectangularReflectionMapping is equal to 303' );
			assert.equal( EquirectangularRefractionMapping, 304, 'EquirectangularRefractionMapping is equal to 304' );
			assert.equal( CubeUVReflectionMapping, 306, 'CubeUVReflectionMapping is equal to 306' );
			assert.equal( CubeUVRefractionMapping, 307, 'CubeUVRefractionMapping is equal to 307' );
			assert.equal( RepeatWrapping, 1000, 'RepeatWrapping is equal to 1000' );
			assert.equal( ClampToEdgeWrapping, 1001, 'ClampToEdgeWrapping is equal to 1001' );
			assert.equal( MirroredRepeatWrapping, 1002, 'MirroredRepeatWrapping is equal to 1002' );
			assert.equal( NearestFilter, 1003, 'NearestFilter is equal to 1003' );
			assert.equal( NearestMipMapNearestFilter, 1004, 'NearestMipMapNearestFilter is equal to 1004' );
			assert.equal( NearestMipMapLinearFilter, 1005, 'NearestMipMapLinearFilter is equal to 1005' );
			assert.equal( LinearFilter, 1006, 'LinearFilter is equal to 1006' );
			assert.equal( LinearMipMapNearestFilter, 1007, 'LinearMipMapNearestFilter is equal to 1007' );
			assert.equal( LinearMipMapLinearFilter, 1008, 'LinearMipMapLinearFilter is equal to 1008' );
			assert.equal( UnsignedByteType, 1009, 'UnsignedByteType is equal to 1009' );
			assert.equal( ByteType, 1010, 'ByteType is equal to 1010' );
			assert.equal( ShortType, 1011, 'ShortType is equal to 1011' );
			assert.equal( UnsignedShortType, 1012, 'UnsignedShortType is equal to 1012' );
			assert.equal( IntType, 1013, 'IntType is equal to 1013' );
			assert.equal( UnsignedIntType, 1014, 'UnsignedIntType is equal to 1014' );
			assert.equal( FloatType, 1015, 'FloatType is equal to 1015' );
			assert.equal( HalfFloatType, 1016, 'HalfFloatType is equal to 1016' );
			assert.equal( UnsignedShort4444Type, 1017, 'UnsignedShort4444Type is equal to 1017' );
			assert.equal( UnsignedShort5551Type, 1018, 'UnsignedShort5551Type is equal to 1018' );
			assert.equal( UnsignedShort565Type, 1019, 'UnsignedShort565Type is equal to 1019' );
			assert.equal( UnsignedInt248Type, 1020, 'UnsignedInt248Type is equal to 1020' );
			assert.equal( AlphaFormat, 1021, 'AlphaFormat is equal to 1021' );
			assert.equal( RGBFormat, 1022, 'RGBFormat is equal to 1022' );
			assert.equal( RGBAFormat, 1023, 'RGBAFormat is equal to 1023' );
			assert.equal( LuminanceFormat, 1024, 'LuminanceFormat is equal to 1024' );
			assert.equal( LuminanceAlphaFormat, 1025, 'LuminanceAlphaFormat is equal to 1025' );
			assert.equal( RGBEFormat, RGBAFormat, 'RGBEFormat is equal to RGBAFormat' );
			assert.equal( DepthFormat, 1026, 'DepthFormat is equal to 1026' );
			assert.equal( DepthStencilFormat, 1027, 'DepthStencilFormat is equal to 1027' );
			assert.equal( RGB_S3TC_DXT1_Format, 33776, 'RGB_S3TC_DXT1_Format is equal to 33776' );
			assert.equal( RGBA_S3TC_DXT1_Format, 33777, 'RGBA_S3TC_DXT1_Format is equal to 33777' );
			assert.equal( RGBA_S3TC_DXT3_Format, 33778, 'RGBA_S3TC_DXT3_Format is equal to 33778' );
			assert.equal( RGBA_S3TC_DXT5_Format, 33779, 'RGBA_S3TC_DXT5_Format is equal to 33779' );
			assert.equal( RGB_PVRTC_4BPPV1_Format, 35840, 'RGB_PVRTC_4BPPV1_Format is equal to 35840' );
			assert.equal( RGB_PVRTC_2BPPV1_Format, 35841, 'RGB_PVRTC_2BPPV1_Format is equal to 35841' );
			assert.equal( RGBA_PVRTC_4BPPV1_Format, 35842, 'RGBA_PVRTC_4BPPV1_Format is equal to 35842' );
			assert.equal( RGBA_PVRTC_2BPPV1_Format, 35843, 'RGBA_PVRTC_2BPPV1_Format is equal to 35843' );
			assert.equal( RGB_ETC1_Format, 36196, 'RGB_ETC1_Format is equal to 36196' );
			assert.equal( RGBA_ASTC_4x4_Format, 37808, "Constants.RGBA_ASTC_4x4_Format is equal to 37808" );
			assert.equal( RGBA_ASTC_5x4_Format, 37809, "Constants.RGBA_ASTC_5x4_Format is equal to 37809" );
			assert.equal( RGBA_ASTC_5x5_Format, 37810, "Constants.RGBA_ASTC_5x5_Format is equal to 37810" );
			assert.equal( RGBA_ASTC_6x5_Format, 37811, "Constants.RGBA_ASTC_6x5_Format is equal to 37811" );
			assert.equal( RGBA_ASTC_6x6_Format, 37812, "Constants.RGBA_ASTC_6x6_Format is equal to 37812" );
			assert.equal( RGBA_ASTC_8x5_Format, 37813, "Constants.RGBA_ASTC_8x5_Format is equal to 37813" );
			assert.equal( RGBA_ASTC_8x6_Format, 37814, "Constants.RGBA_ASTC_8x6_Format is equal to 37814" );
			assert.equal( RGBA_ASTC_8x8_Format, 37815, "Constants.RGBA_ASTC_8x8_Format is equal to 37815" );
			assert.equal( RGBA_ASTC_10x5_Format, 37816, "Constants.RGBA_ASTC_10x5_Format is equal to 37816" );
			assert.equal( RGBA_ASTC_10x6_Format, 37817, "Constants.RGBA_ASTC_10x6_Format is equal to 37817" );
			assert.equal( RGBA_ASTC_10x8_Format, 37818, "Constants.RGBA_ASTC_10x8_Format is equal to 37818" );
			assert.equal( RGBA_ASTC_10x10_Format, 37819, "Constants.RGBA_ASTC_10x10_Format is equal to 37819" );
			assert.equal( RGBA_ASTC_12x10_Format, 37820, "Constants.RGBA_ASTC_12x10_Format is equal to 37820" );
			assert.equal( RGBA_ASTC_12x12_Format, 37821, "Constants.RGBA_ASTC_12x12_Format is equal to 37821" );
			assert.equal( LoopOnce, 2200, 'LoopOnce is equal to 2200' );
			assert.equal( LoopRepeat, 2201, 'LoopRepeat is equal to 2201' );
			assert.equal( LoopPingPong, 2202, 'LoopPingPong is equal to 2202' );
			assert.equal( InterpolateDiscrete, 2300, 'InterpolateDiscrete is equal to 2300' );
			assert.equal( InterpolateLinear, 2301, 'InterpolateLinear is equal to 2301' );
			assert.equal( InterpolateSmooth, 2302, 'InterpolateSmooth is equal to 2302' );
			assert.equal( ZeroCurvatureEnding, 2400, 'ZeroCurvatureEnding is equal to 2400' );
			assert.equal( ZeroSlopeEnding, 2401, 'ZeroSlopeEnding is equal to 2401' );
			assert.equal( WrapAroundEnding, 2402, 'WrapAroundEnding is equal to 2402' );
			assert.equal( TrianglesDrawMode, 0, 'TrianglesDrawMode is equal to 0' );
			assert.equal( TriangleStripDrawMode, 1, 'TriangleStripDrawMode is equal to 1' );
			assert.equal( TriangleFanDrawMode, 2, 'TriangleFanDrawMode is equal to 2' );
			assert.equal( LinearEncoding, 3000, 'LinearEncoding is equal to 3000' );
			assert.equal( sRGBEncoding, 3001, 'sRGBEncoding is equal to 3001' );
			assert.equal( GammaEncoding, 3007, 'GammaEncoding is equal to 3007' );
			assert.equal( RGBEEncoding, 3002, 'RGBEEncoding is equal to 3002' );
			assert.equal( LogLuvEncoding, 3003, 'LogLuvEncoding is equal to 3003' );
			assert.equal( RGBM7Encoding, 3004, 'RGBM7Encoding is equal to 3004' );
			assert.equal( RGBM16Encoding, 3005, 'RGBM16Encoding is equal to 3005' );
			assert.equal( RGBDEncoding, 3006, 'RGBDEncoding is equal to 3006' );
			assert.equal( BasicDepthPacking, 3200, 'BasicDepthPacking is equal to 3200' );
			assert.equal( RGBADepthPacking, 3201, 'RGBADepthPacking is equal to 3201' );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'utils', () => {

		QUnit.test( 'arrayMin', ( assert ) => {

			assert.equal( arrayMin( [] ), Infinity, 'Empty array return positive infinit' );
			assert.equal( arrayMin( [ 5 ] ), 5, 'Single valued array should return the unique value as minimum' );
			assert.equal( arrayMin( [ 1, 5, 10 ] ), 1, 'The array [ 1, 5, 10 ] return 1' );
			assert.equal( arrayMin( [ 5, 1, 10 ] ), 1, 'The array [ 5, 1, 10 ] return 1' );
			assert.equal( arrayMin( [ 10, 5, 1 ] ), 1, 'The array [ 10, 5, 1 ] return 1' );
			assert.equal( arrayMax( [ - 0, 0 ] ), - 0, 'The array [ - 0, 0 ] return -0' );
			assert.equal( arrayMin( [ - Infinity, 0, Infinity ] ), - Infinity, 'The array [ - Infinity, 0, Infinity ] return -Infinity' );

		} );

		QUnit.test( 'arrayMax', ( assert ) => {

			assert.equal( arrayMax( [] ), - Infinity, 'Empty array return negative infinit' );
			assert.equal( arrayMax( [ 5 ] ), 5, 'Single valued array should return the unique value as maximum' );
			assert.equal( arrayMax( [ 10, 5, 1 ] ), 10, 'The array [ 10, 5, 1 ] return 10' );
			assert.equal( arrayMax( [ 1, 10, 5 ] ), 10, 'The array [ 1, 10, 5 ] return 10' );
			assert.equal( arrayMax( [ 1, 5, 10 ] ), 10, 'The array [ 1, 5, 10 ] return 10' );
			assert.equal( arrayMax( [ - 0, 0 ] ), 0, 'The array [ - 0, 0 ] return 0' );
			assert.equal( arrayMax( [ - Infinity, 0, Infinity ] ), Infinity, 'The array [ - Infinity, 0, Infinity ] return Infinity' );

		} );


	} );

	class AnimationAction {

		constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot;
			this.blendMode = blendMode;

			const tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );

			const interpolantSettings = {
				endingStart: ZeroCurvatureEnding,
				endingEnd: ZeroCurvatureEnding
			};

			for ( let i = 0; i !== nTracks; ++ i ) {

				const interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;

			}

			this._interpolantSettings = interpolantSettings;

			this._interpolants = interpolants; // bound by the mixer

			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );

			this._cacheIndex = null; // for the memory manager
			this._byClipCacheIndex = null; // for the memory manager

			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;

			this.loop = LoopRepeat;
			this._loopCount = - 1;

			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;

			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;

			this.timeScale = 1;
			this._effectiveTimeScale = 1;

			this.weight = 1;
			this._effectiveWeight = 1;

			this.repetitions = Infinity; // no. of repetitions when looping

			this.paused = false; // true -> zero effective time scale
			this.enabled = true; // false -> zero effective weight

			this.clampWhenFinished = false;// keep feeding the last frame?

			this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd = true;// clips for start, loop and end

		}

		// State & Scheduling

		play() {

			this._mixer._activateAction( this );

			return this;

		}

		stop() {

			this._mixer._deactivateAction( this );

			return this.reset();

		}

		reset() {

			this.paused = false;
			this.enabled = true;

			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling

			return this.stopFading().stopWarping();

		}

		isRunning() {

			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

		}

		// return true when play has been called
		isScheduled() {

			return this._mixer._isActiveAction( this );

		}

		startAt( time ) {

			this._startTime = time;

			return this;

		}

		setLoop( mode, repetitions ) {

			this.loop = mode;
			this.repetitions = repetitions;

			return this;

		}

		// Weight

		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight( weight ) {

			this.weight = weight;

			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;

			return this.stopFading();

		}

		// return the weight considering fading and .enabled
		getEffectiveWeight() {

			return this._effectiveWeight;

		}

		fadeIn( duration ) {

			return this._scheduleFading( duration, 0, 1 );

		}

		fadeOut( duration ) {

			return this._scheduleFading( duration, 1, 0 );

		}

		crossFadeFrom( fadeOutAction, duration, warp ) {

			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );

			if ( warp ) {

				const fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,

					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;

				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );

			}

			return this;

		}

		crossFadeTo( fadeInAction, duration, warp ) {

			return fadeInAction.crossFadeFrom( this, duration, warp );

		}

		stopFading() {

			const weightInterpolant = this._weightInterpolant;

			if ( weightInterpolant !== null ) {

				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );

			}

			return this;

		}

		// Time Scale Control

		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale( timeScale ) {

			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;

			return this.stopWarping();

		}

		// return the time scale considering warping and .paused
		getEffectiveTimeScale() {

			return this._effectiveTimeScale;

		}

		setDuration( duration ) {

			this.timeScale = this._clip.duration / duration;

			return this.stopWarping();

		}

		syncWith( action ) {

			this.time = action.time;
			this.timeScale = action.timeScale;

			return this.stopWarping();

		}

		halt( duration ) {

			return this.warp( this._effectiveTimeScale, 0, duration );

		}

		warp( startTimeScale, endTimeScale, duration ) {

			const mixer = this._mixer,
				now = mixer.time,
				timeScale = this.timeScale;

			let interpolant = this._timeScaleInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			times[ 1 ] = now + duration;

			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;

			return this;

		}

		stopWarping() {

			const timeScaleInterpolant = this._timeScaleInterpolant;

			if ( timeScaleInterpolant !== null ) {

				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

			}

			return this;

		}

		// Object Accessors

		getMixer() {

			return this._mixer;

		}

		getClip() {

			return this._clip;

		}

		getRoot() {

			return this._localRoot || this._mixer._root;

		}

		// Interna

		_update( time, deltaTime, timeDirection, accuIndex ) {

			// called by the mixer

			if ( ! this.enabled ) {

				// call ._updateWeight() to update ._effectiveWeight

				this._updateWeight( time );
				return;

			}

			const startTime = this._startTime;

			if ( startTime !== null ) {

				// check for scheduled start of action

				const timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {

					return; // yet to come / don't decide when delta = 0

				}

				// start

				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;

			}

			// apply time scale and advance time

			deltaTime *= this._updateTimeScale( time );
			const clipTime = this._updateTime( deltaTime );

			// note: _updateTime may disable the action resulting in
			// an effective weight of 0

			const weight = this._updateWeight( time );

			if ( weight > 0 ) {

				const interpolants = this._interpolants;
				const propertyMixers = this._propertyBindings;

				switch ( this.blendMode ) {

					case AdditiveAnimationBlendMode:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulateAdditive( weight );

						}

						break;

					case NormalAnimationBlendMode:
					default:

						for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

							interpolants[ j ].evaluate( clipTime );
							propertyMixers[ j ].accumulate( accuIndex, weight );

						}

				}

			}

		}

		_updateWeight( time ) {

			let weight = 0;

			if ( this.enabled ) {

				weight = this.weight;
				const interpolant = this._weightInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					weight *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopFading();

						if ( interpolantValue === 0 ) {

							// faded out, disable
							this.enabled = false;

						}

					}

				}

			}

			this._effectiveWeight = weight;
			return weight;

		}

		_updateTimeScale( time ) {

			let timeScale = 0;

			if ( ! this.paused ) {

				timeScale = this.timeScale;

				const interpolant = this._timeScaleInterpolant;

				if ( interpolant !== null ) {

					const interpolantValue = interpolant.evaluate( time )[ 0 ];

					timeScale *= interpolantValue;

					if ( time > interpolant.parameterPositions[ 1 ] ) {

						this.stopWarping();

						if ( timeScale === 0 ) {

							// motion has halted, pause
							this.paused = true;

						} else {

							// warp done - apply final time scale
							this.timeScale = timeScale;

						}

					}

				}

			}

			this._effectiveTimeScale = timeScale;
			return timeScale;

		}

		_updateTime( deltaTime ) {

			const duration = this._clip.duration;
			const loop = this.loop;

			let time = this.time + deltaTime;
			let loopCount = this._loopCount;

			const pingPong = ( loop === LoopPingPong );

			if ( deltaTime === 0 ) {

				if ( loopCount === - 1 ) return time;

				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

			}

			if ( loop === LoopOnce ) {

				if ( loopCount === - 1 ) {

					// just started

					this._loopCount = 0;
					this._setEndings( true, true, false );

				}

				handle_stop: {

					if ( time >= duration ) {

						time = duration;

					} else if ( time < 0 ) {

						time = 0;

					} else {

						this.time = time;

						break handle_stop;

					}

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );

				}

			} else { // repetitive Repeat or PingPong

				if ( loopCount === - 1 ) {

					// just started

					if ( deltaTime >= 0 ) {

						loopCount = 0;

						this._setEndings( true, this.repetitions === 0, pingPong );

					} else {

						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1

						this._setEndings( this.repetitions === 0, true, pingPong );

					}

				}

				if ( time >= duration || time < 0 ) {

					// wrap around

					const loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;

					loopCount += Math.abs( loopDelta );

					const pending = this.repetitions - loopCount;

					if ( pending <= 0 ) {

						// have to stop (switch state, clamp time, fire event)

						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;

						time = deltaTime > 0 ? duration : 0;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );

					} else {

						// keep running

						if ( pending === 1 ) {

							// entering the last round

							const atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );

						} else {

							this._setEndings( false, false, pingPong );

						}

						this._loopCount = loopCount;

						this.time = time;

						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );

					}

				} else {

					this.time = time;

				}

				if ( pingPong && ( loopCount & 1 ) === 1 ) {

					// invert time for the "pong round"

					return duration - time;

				}

			}

			return time;

		}

		_setEndings( atStart, atEnd, pingPong ) {

			const settings = this._interpolantSettings;

			if ( pingPong ) {

				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;

			} else {

				// assuming for LoopOnce atStart == atEnd == true

				if ( atStart ) {

					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingStart = WrapAroundEnding;

				}

				if ( atEnd ) {

					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

				} else {

					settings.endingEnd 	 = WrapAroundEnding;

				}

			}

		}

		_scheduleFading( duration, weightNow, weightThen ) {

			const mixer = this._mixer, now = mixer.time;
			let interpolant = this._weightInterpolant;

			if ( interpolant === null ) {

				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;

			}

			const times = interpolant.parameterPositions,
				values = interpolant.sampleValues;

			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;

			return this;

		}

	}

	// Characters [].:/ are reserved for track binding syntax.
	const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

	const _trackRe = new RegExp( ''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	);

	const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

	function Composite( targetGroup, path, optionalParsedPath ) {

		const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );

	}

	Object.assign( Composite.prototype, {

		getValue: function ( array, offset ) {

			this.bind(); // bind all binding

			const firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];

			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );

		},

		setValue: function ( array, offset ) {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].setValue( array, offset );

			}

		},

		bind: function () {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].bind();

			}

		},

		unbind: function () {

			const bindings = this._bindings;

			for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

				bindings[ i ].unbind();

			}

		}

	} );


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && root.isAnimationObjectGroup ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: function ( name ) {

			return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

		},

		parseTrackName: function ( trackName ) {

			const matches = _trackRe.exec( trackName );

			if ( ! matches ) {

				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

			}

			const results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ], // required
				propertyIndex: matches[ 6 ]
			};

			const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

			if ( lastDot !== undefined && lastDot !== - 1 ) {

				const objectName = results.nodeName.substring( lastDot + 1 );

				// Object names must be checked against an allowlist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;

				}

			}

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

			}

			return results;

		},

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				const bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				const searchNodeSubtree = function ( children ) {

					for ( let i = 0; i < children.length; i ++ ) {

						const childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						const result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				const subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				const source = this.resolvedProperty;

				for ( let i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					const dest = this.resolvedProperty;

					for ( let i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					const dest = this.resolvedProperty;

					for ( let i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					const dest = this.resolvedProperty;

					for ( let i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			let targetObject = this.node;
			const parsedPath = this.parsedPath;

			const objectName = parsedPath.objectName;
			const propertyName = parsedPath.propertyName;
			let propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				let objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( let i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			const nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				const nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			let versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			let bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === 'morphTargetInfluences' ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

							propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

						}


					} else {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
						return;

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	// DECLARE ALIAS AFTER assign prototype
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	class PropertyMixer {

		constructor( binding, typeName, valueSize ) {

			this.binding = binding;
			this.valueSize = valueSize;

			let mixFunction,
				mixFunctionAdditive,
				setIdentity;

			// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
			//
			// 'add' is used for additive cumulative results
			//
			// 'work' is optional and is only present for quaternion types. It is used
			// to store intermediate quaternion multiplication results

			switch ( typeName ) {

				case 'quaternion':
					mixFunction = this._slerp;
					mixFunctionAdditive = this._slerpAdditive;
					setIdentity = this._setAdditiveIdentityQuaternion;

					this.buffer = new Float64Array( valueSize * 6 );
					this._workIndex = 5;
					break;

				case 'string':
				case 'bool':
					mixFunction = this._select;

					// Use the regular mix function and for additive on these types,
					// additive is not relevant for non-numeric types
					mixFunctionAdditive = this._select;

					setIdentity = this._setAdditiveIdentityOther;

					this.buffer = new Array( valueSize * 5 );
					break;

				default:
					mixFunction = this._lerp;
					mixFunctionAdditive = this._lerpAdditive;
					setIdentity = this._setAdditiveIdentityNumeric;

					this.buffer = new Float64Array( valueSize * 5 );

			}

			this._mixBufferRegion = mixFunction;
			this._mixBufferRegionAdditive = mixFunctionAdditive;
			this._setIdentity = setIdentity;
			this._origIndex = 3;
			this._addIndex = 4;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			this.useCount = 0;
			this.referenceCount = 0;

		}

		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate( accuIndex, weight ) {

			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride;

			let currentWeight = this.cumulativeWeight;

			if ( currentWeight === 0 ) {

				// accuN := incoming * weight

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ offset + i ] = buffer[ i ];

				}

				currentWeight = weight;

			} else {

				// accuN := accuN + incoming * weight

				currentWeight += weight;
				const mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );

			}

			this.cumulativeWeight = currentWeight;

		}

		// accumulate data in the 'incoming' region into 'add'
		accumulateAdditive( weight ) {

			const buffer = this.buffer,
				stride = this.valueSize,
				offset = stride * this._addIndex;

			if ( this.cumulativeWeightAdditive === 0 ) {

				// add = identity

				this._setIdentity();

			}

			// add := add + incoming * weight

			this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
			this.cumulativeWeightAdditive += weight;

		}

		// apply the state of 'accu<i>' to the binding when accus differ
		apply( accuIndex ) {

			const stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,

				weight = this.cumulativeWeight,
				weightAdditive = this.cumulativeWeightAdditive,

				binding = this.binding;

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

			if ( weight < 1 ) {

				// accuN := accuN + original * ( 1 - cumulativeWeight )

				const originalValueOffset = stride * this._origIndex;

				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

			}

			if ( weightAdditive > 0 ) {

				// accuN := accuN + additive accuN

				this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

			}

			for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

				if ( buffer[ i ] !== buffer[ i + stride ] ) {

					// value has changed -> update scene graph

					binding.setValue( buffer, offset );
					break;

				}

			}

		}

		// remember the state of the bound property and copy it to both accus
		saveOriginalState() {

			const binding = this.binding;

			const buffer = this.buffer,
				stride = this.valueSize,

				originalValueOffset = stride * this._origIndex;

			binding.getValue( buffer, originalValueOffset );

			// accu[0..1] := orig -- initially detect changes against the original
			for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

			}

			// Add to identity for additive
			this._setIdentity();

			this.cumulativeWeight = 0;
			this.cumulativeWeightAdditive = 0;

		}

		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState() {

			const originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );

		}

		_setAdditiveIdentityNumeric() {

			const startIndex = this._addIndex * this.valueSize;
			const endIndex = startIndex + this.valueSize;

			for ( let i = startIndex; i < endIndex; i ++ ) {

				this.buffer[ i ] = 0;

			}

		}

		_setAdditiveIdentityQuaternion() {

			this._setAdditiveIdentityNumeric();
			this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

		}

		_setAdditiveIdentityOther() {

			const startIndex = this._origIndex * this.valueSize;
			const targetIndex = this._addIndex * this.valueSize;

			for ( let i = 0; i < this.valueSize; i ++ ) {

				this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

			}

		}


		// mix functions

		_select( buffer, dstOffset, srcOffset, t, stride ) {

			if ( t >= 0.5 ) {

				for ( let i = 0; i !== stride; ++ i ) {

					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

				}

			}

		}

		_slerp( buffer, dstOffset, srcOffset, t ) {

			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

		}

		_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			const workOffset = this._workIndex * stride;

			// Store result in intermediate buffer offset
			Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

			// Slerp to the intermediate result
			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

		}

		_lerp( buffer, dstOffset, srcOffset, t, stride ) {

			const s = 1 - t;

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

			}

		}

		_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

			for ( let i = 0; i !== stride; ++ i ) {

				const j = dstOffset + i;

				buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

			}

		}

	}

	class AnimationMixer extends EventDispatcher {

		constructor( root ) {

			super();

			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
			this.time = 0;
			this.timeScale = 1.0;

		}

		_bindAction( action, prototypeAction ) {

			const root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName;

			let bindingsByName = bindingsByRoot[ rootUuid ];

			if ( bindingsByName === undefined ) {

				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;

			}

			for ( let i = 0; i !== nTracks; ++ i ) {

				const track = tracks[ i ],
					trackName = track.name;

				let binding = bindingsByName[ trackName ];

				if ( binding !== undefined ) {

					bindings[ i ] = binding;

				} else {

					binding = bindings[ i ];

					if ( binding !== undefined ) {

						// existing binding, make sure the cache knows

						if ( binding._cacheIndex === null ) {

							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );

						}

						continue;

					}

					const path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );

					bindings[ i ] = binding;

				}

				interpolants[ i ].resultBuffer = binding.buffer;

			}

		}

		_activateAction( action ) {

			if ( ! this._isActiveAction( action ) ) {

				if ( action._cacheIndex === null ) {

					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind

					const rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];

					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

					this._addInactiveAction( action, clipUuid, rootUuid );

				}

				const bindings = action._propertyBindings;

				// increment reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( binding.useCount ++ === 0 ) {

						this._lendBinding( binding );
						binding.saveOriginalState();

					}

				}

				this._lendAction( action );

			}

		}

		_deactivateAction( action ) {

			if ( this._isActiveAction( action ) ) {

				const bindings = action._propertyBindings;

				// decrement reference counts / sort out state
				for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

					const binding = bindings[ i ];

					if ( -- binding.useCount === 0 ) {

						binding.restoreOriginalState();
						this._takeBackBinding( binding );

					}

				}

				this._takeBackAction( action );

			}

		}

		// Memory manager

		_initMemoryManager() {

			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;

			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }


			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;

			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;

			const scope = this;

			this.stats = {

				actions: {
					get total() {

						return scope._actions.length;

					},
					get inUse() {

						return scope._nActiveActions;

					}
				},
				bindings: {
					get total() {

						return scope._bindings.length;

					},
					get inUse() {

						return scope._nActiveBindings;

					}
				},
				controlInterpolants: {
					get total() {

						return scope._controlInterpolants.length;

					},
					get inUse() {

						return scope._nActiveControlInterpolants;

					}
				}

			};

		}

		// Memory management for AnimationAction objects

		_isActiveAction( action ) {

			const index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;

		}

		_addInactiveAction( action, clipUuid, rootUuid ) {

			const actions = this._actions,
				actionsByClip = this._actionsByClip;

			let actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip === undefined ) {

				actionsForClip = {

					knownActions: [ action ],
					actionByRoot: {}

				};

				action._byClipCacheIndex = 0;

				actionsByClip[ clipUuid ] = actionsForClip;

			} else {

				const knownActions = actionsForClip.knownActions;

				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );

			}

			action._cacheIndex = actions.length;
			actions.push( action );

			actionsForClip.actionByRoot[ rootUuid ] = action;

		}

		_removeInactiveAction( action ) {

			const actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;

			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();

			action._cacheIndex = null;


			const clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,

				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],

				byClipCacheIndex = action._byClipCacheIndex;

			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();

			action._byClipCacheIndex = null;


			const actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;

			delete actionByRoot[ rootUuid ];

			if ( knownActionsForClip.length === 0 ) {

				delete actionsByClip[ clipUuid ];

			}

			this._removeInactiveBindingsForAction( action );

		}

		_removeInactiveBindingsForAction( action ) {

			const bindings = action._propertyBindings;

			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.referenceCount === 0 ) {

					this._removeInactiveBinding( binding );

				}

			}

		}

		_lendAction( action ) {

			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				lastActiveIndex = this._nActiveActions ++,

				firstInactiveAction = actions[ lastActiveIndex ];

			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;

			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;

		}

		_takeBackAction( action ) {

			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a

			const actions = this._actions,
				prevIndex = action._cacheIndex,

				firstInactiveIndex = -- this._nActiveActions,

				lastActiveAction = actions[ firstInactiveIndex ];

			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;

			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;

		}

		// Memory management for PropertyMixer objects

		_addInactiveBinding( binding, rootUuid, trackName ) {

			const bindingsByRoot = this._bindingsByRootAndName,
				bindings = this._bindings;

			let bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName === undefined ) {

				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;

			}

			bindingByName[ trackName ] = binding;

			binding._cacheIndex = bindings.length;
			bindings.push( binding );

		}

		_removeInactiveBinding( binding ) {

			const bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],

				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;

			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();

			delete bindingByName[ trackName ];

			if ( Object.keys( bindingByName ).length === 0 ) {

				delete bindingsByRoot[ rootUuid ];

			}

		}

		_lendBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				lastActiveIndex = this._nActiveBindings ++,

				firstInactiveBinding = bindings[ lastActiveIndex ];

			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;

			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;

		}

		_takeBackBinding( binding ) {

			const bindings = this._bindings,
				prevIndex = binding._cacheIndex,

				firstInactiveIndex = -- this._nActiveBindings,

				lastActiveBinding = bindings[ firstInactiveIndex ];

			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;

			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;

		}


		// Memory management of Interpolants for weight and time scale

		_lendControlInterpolant() {

			const interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++;

			let interpolant = interpolants[ lastActiveIndex ];

			if ( interpolant === undefined ) {

				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );

				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;

			}

			return interpolant;

		}

		_takeBackControlInterpolant( interpolant ) {

			const interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,

				firstInactiveIndex = -- this._nActiveControlInterpolants,

				lastActiveInterpolant = interpolants[ firstInactiveIndex ];

			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;

			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;

		}

		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction( clip, optionalRoot, blendMode ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid;

			let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

			const clipUuid = clipObject !== null ? clipObject.uuid : clip;

			const actionsForClip = this._actionsByClip[ clipUuid ];
			let prototypeAction = null;

			if ( blendMode === undefined ) {

				if ( clipObject !== null ) {

					blendMode = clipObject.blendMode;

				} else {

					blendMode = NormalAnimationBlendMode;

				}

			}

			if ( actionsForClip !== undefined ) {

				const existingAction = actionsForClip.actionByRoot[ rootUuid ];

				if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

					return existingAction;

				}

				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];

				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;

			}

			// clip must be known when specified via string
			if ( clipObject === null ) return null;

			// allocate all resources required to run it
			const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

			this._bindAction( newAction, prototypeAction );

			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );

			return newAction;

		}

		// get an existing action
		existingAction( clip, optionalRoot ) {

			const root = optionalRoot || this._root,
				rootUuid = root.uuid,

				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

				clipUuid = clipObject ? clipObject.uuid : clip,

				actionsForClip = this._actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				return actionsForClip.actionByRoot[ rootUuid ] || null;

			}

			return null;

		}

		// deactivates all previously scheduled actions
		stopAllAction() {

			const actions = this._actions,
				nActions = this._nActiveActions;

			for ( let i = nActions - 1; i >= 0; -- i ) {

				actions[ i ].stop();

			}

			return this;

		}

		// advance the time and update apply the animation
		update( deltaTime ) {

			deltaTime *= this.timeScale;

			const actions = this._actions,
				nActions = this._nActiveActions,

				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),

				accuIndex = this._accuIndex ^= 1;

			// run active actions

			for ( let i = 0; i !== nActions; ++ i ) {

				const action = actions[ i ];

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

			// update scene graph

			const bindings = this._bindings,
				nBindings = this._nActiveBindings;

			for ( let i = 0; i !== nBindings; ++ i ) {

				bindings[ i ].apply( accuIndex );

			}

			return this;

		}

		// Allows you to seek to a specific time in an animation.
		setTime( timeInSeconds ) {

			this.time = 0; // Zero out time attribute for AnimationMixer object;
			for ( let i = 0; i < this._actions.length; i ++ ) {

				this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

			}

			return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

		}

		// return this mixer's root target object
		getRoot() {

			return this._root;

		}

		// free all resources specific to a particular clip
		uncacheClip( clip ) {

			const actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];

			if ( actionsForClip !== undefined ) {

				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away

				const actionsToRemove = actionsForClip.knownActions;

				for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

					const action = actionsToRemove[ i ];

					this._deactivateAction( action );

					const cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];

					action._cacheIndex = null;
					action._byClipCacheIndex = null;

					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();

					this._removeInactiveBindingsForAction( action );

				}

				delete actionsByClip[ clipUuid ];

			}

		}

		// free all resources specific to a particular root target object
		uncacheRoot( root ) {

			const rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;

			for ( const clipUuid in actionsByClip ) {

				const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];

				if ( action !== undefined ) {

					this._deactivateAction( action );
					this._removeInactiveAction( action );

				}

			}

			const bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];

			if ( bindingByName !== undefined ) {

				for ( const trackName in bindingByName ) {

					const binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );

				}

			}

		}

		// remove a targeted clip from the cache
		uncacheAction( clip, optionalRoot ) {

			const action = this.existingAction( clip, optionalRoot );

			if ( action !== null ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

	}

	AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

	/* global QUnit */


	function createAnimation() {

		var root = new Object3D();
		var mixer = new AnimationMixer( root );
		var track = new NumberKeyframeTrack( ".rotation[x]", [ 0, 1000 ], [ 0, 360 ] );
		var clip = new AnimationClip( "clip1", 1000, [ track ] );

		var animationAction = mixer.clipAction( clip );
		return {
			root: root,
			mixer: mixer,
			track: track,
			clip: clip,
			animationAction: animationAction
		};

	}

	function createTwoAnimations() {

		var root = new Object3D();
		var mixer = new AnimationMixer( root );
		var track = new NumberKeyframeTrack( ".rotation[x]", [ 0, 1000 ], [ 0, 360 ] );
		var clip = new AnimationClip( "clip1", 1000, [ track ] );
		var animationAction = mixer.clipAction( clip );

		var track2 = new NumberKeyframeTrack( ".rotation[y]", [ 0, 1000 ], [ 0, 360 ] );
		var clip2 = new AnimationClip( "clip2", 1000, [ track ] );
		var animationAction2 = mixer.clipAction( clip2 );

		return {
			root: root,
			mixer: mixer,
			track: track,
			clip: clip,
			animationAction: animationAction,
			track2: track2,
			clip2: clip2,
			animationAction2: animationAction2
		};

	}


	QUnit.module( 'Animation', () => {

		QUnit.module( 'AnimationAction', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var mixer = new AnimationMixer();
				var clip = new AnimationClip( "nonname", - 1, [] );

				var animationAction = new AnimationAction( mixer, clip );
				assert.ok( animationAction, "animationAction instanciated" );

			} );

			// PUBLIC STUFF
			QUnit.test( "play", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				var animationAction2 = animationAction.play();
				assert.equal( animationAction, animationAction2, "AnimationAction.play can be chained." );

				var UserException = function () {

					this.message = "AnimationMixer must activate AnimationAction on play.";

				};

				mixer._activateAction = function ( action ) {

					if ( action === animationAction ) {

						throw new UserException();

					}

				};

				assert.throws( () => {

					animationAction.play();

				}, new UserException() );

			} );

			QUnit.test( "stop", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				var animationAction2 = animationAction.stop();
				assert.equal( animationAction, animationAction2, "AnimationAction.stop can be chained." );

				var UserException = function () {

					this.message = "AnimationMixer must deactivate AnimationAction on stop.";

				};

				mixer._deactivateAction = function ( action ) {

					if ( action === animationAction ) {

						throw new UserException();

					}

				};

				assert.throws( () => {

					animationAction.stop();

				}, new UserException() );

			} );

			QUnit.test( "reset", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				var animationAction2 = animationAction.stop();
				assert.equal( animationAction, animationAction2, "AnimationAction.reset can be chained." );
				assert.equal( animationAction2.paused, false, "AnimationAction.reset() sets paused false" );
				assert.equal( animationAction2.enabled, true, "AnimationAction.reset() sets enabled true" );
				assert.equal( animationAction2.time, 0, "AnimationAction.reset() resets time." );
				assert.equal( animationAction2._loopCount, - 1, "AnimationAction.reset() resets loopcount." );
				assert.equal( animationAction2._startTime, null, "AnimationAction.reset() removes starttime." );

			} );

			QUnit.test( "isRunning", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				assert.notOk( animationAction.isRunning(), "When an animation is just made, it is not running." );
				animationAction.play();
				assert.ok( animationAction.isRunning(), "When an animation is started, it is running." );
				animationAction.stop();
				assert.notOk( animationAction.isRunning(), "When an animation is stopped, it is not running." );
				animationAction.play();
				animationAction.paused = true;
				assert.notOk( animationAction.isRunning(), "When an animation is paused, it is not running." );
				animationAction.paused = false;
				animationAction.enabled = false;
				assert.notOk( animationAction.isRunning(), "When an animation is not enabled, it is not running." );
				animationAction.enabled = true;
				assert.ok( animationAction.isRunning(), "When an animation is enabled, it is running." );

			} );

			QUnit.test( "isScheduled", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				assert.notOk( animationAction.isScheduled(), "When an animation is just made, it is not scheduled." );
				animationAction.play();
				assert.ok( animationAction.isScheduled(), "When an animation is started, it is scheduled." );
				mixer.update( 1 );
				assert.ok( animationAction.isScheduled(), "When an animation is updated, it is scheduled." );
				animationAction.stop();
				assert.notOk( animationAction.isScheduled(), "When an animation is stopped, it isn't scheduled anymore." );


			} );

			QUnit.test( "startAt", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				animationAction.startAt( 2 );
				animationAction.play();
				assert.notOk( animationAction.isRunning(), "When an animation is started at a specific time, it is not running." );
				assert.ok( animationAction.isScheduled(), "When an animation is started at a specific time, it is scheduled." );
				mixer.update( 1 );
				assert.notOk( animationAction.isRunning(), "When an animation is started at a specific time and the interval is not passed, it is not running." );
				assert.ok( animationAction.isScheduled(), "When an animation is started at a specific time and the interval is not passed, it is scheduled." );
				mixer.update( 1 );
				assert.ok( animationAction.isRunning(), "When an animation is started at a specific time and the interval is passed, it is running." );
				assert.ok( animationAction.isScheduled(), "When an animation is started at a specific time and the interval is passed, it is scheduled." );
				animationAction.stop();
				assert.notOk( animationAction.isRunning(), "When an animation is stopped, it is not running." );
				assert.notOk( animationAction.isScheduled(), "When an animation is stopped, it is not scheduled." );


			} );

			QUnit.test( "setLoop LoopOnce", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				animationAction.setLoop( LoopOnce );
				animationAction.play();
				assert.ok( animationAction.isRunning(), "When an animation is started, it is running." );
				mixer.update( 500 );
				assert.ok( animationAction.isRunning(), "When an animation is in the first loop, it is running." );
				mixer.update( 500 );
				assert.notOk( animationAction.isRunning(), "When an animation is ended, it is not running." );
				mixer.update( 500 );
				assert.notOk( animationAction.isRunning(), "When an animation is ended, it is not running." );

			} );

			QUnit.test( "setLoop LoopRepeat", ( assert ) => {

				var { root, mixer, animationAction } = createAnimation();
				animationAction.setLoop( LoopRepeat, 3 );
				animationAction.play();
				assert.ok( animationAction.isRunning(), "When an animation is started, it is running." );
				mixer.update( 750 );
				assert.equal( root.rotation.x, 270, "When an animation is 3/4 in the first loop, it has changed to 3/4 when LoopRepeat." );
				assert.ok( animationAction.isRunning(), "When an animation is in the first loop, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 270, "When an animation is 3/4 in the second loop, it has changed to 3/4 when LoopRepeat." );
				assert.ok( animationAction.isRunning(), "When an animation is in second loop when in looprepeat 3 times, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 270, "When an animation is 3/4 in the third loop, it has changed to 3/4 when LoopRepeat." );
				assert.ok( animationAction.isRunning(), "When an animation is in third loop when in looprepeat 3 times, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 0, "When an animation ended his third loop when in looprepeat 3 times, it stays on the end result." );
				assert.notOk( animationAction.isRunning(), "When an animation ended his third loop when in looprepeat 3 times, it stays not running anymore." );

			} );

			QUnit.test( "setLoop LoopPingPong", ( assert ) => {

				var { root, mixer, animationAction } = createAnimation();
				animationAction.setLoop( LoopPingPong, 3 );
				animationAction.play();
				assert.ok( animationAction.isRunning(), "When an animation is started, it is running." );
				mixer.update( 750 );
				assert.equal( root.rotation.x, 270, "When an animation is 3/4 in the first loop, it has changed to 3/4 when LoopPingPong." );
				assert.ok( animationAction.isRunning(), "When an animation is in the first loop, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 90, "When an animation is 3/4 in the second loop, it has changed to 1/4 when LoopPingPong." );
				assert.ok( animationAction.isRunning(), "When an animation is in second loop when in looprepeat 3 times, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 270, "When an animation is 3/4 in the third loop, it has changed to 3/4 when LoopPingPong." );
				assert.ok( animationAction.isRunning(), "When an animation is in third loop when in looprepeat 3 times, it is running." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 0, "When an animation ended his fourth loop when in looprepeat 3 times, it stays on the end result." );
				assert.notOk( animationAction.isRunning(), "When an animation ended his fourth loop when in looprepeat 3 times, it stays not running anymore." );

			} );

			QUnit.test( "setEffectiveWeight", ( assert ) => {

				var { animationAction } = createAnimation();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation is created, EffectiveWeight is 1." );
				animationAction.setEffectiveWeight( 0.3 );
				assert.equal( animationAction.getEffectiveWeight(), 0.3, "When EffectiveWeight is set to 0.3 , EffectiveWeight is 0.3." );


				var { animationAction } = createAnimation();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation is created, EffectiveWeight is 1." );
				animationAction.enabled = false;
				animationAction.setEffectiveWeight( 0.3 );
				assert.equal( animationAction.getEffectiveWeight(), 0, "When EffectiveWeight is set to 0.3 when disabled , EffectiveWeight is 0." );


				var { root, mixer, animationAction } = createAnimation();
				animationAction.setEffectiveWeight( 0.5 );
				animationAction.play();
				mixer.update( 500 );
				assert.equal( root.rotation.x, 90, "When an animation has weight 0.5 and runs half through the animation, it has changed to 1/4." );
				mixer.update( 1000 );
				assert.equal( root.rotation.x, 90, "When an animation has weight 0.5 and runs one and half through the animation, it has changed to 1/4." );

			} );

			QUnit.test( "getEffectiveWeight", ( assert ) => {

				var { animationAction } = createAnimation();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation is created, EffectiveWeight is 1." );
				animationAction.setEffectiveWeight( 0.3 );
				assert.equal( animationAction.getEffectiveWeight(), 0.3, "When EffectiveWeight is set to 0.3 , EffectiveWeight is 0.3." );


				var { animationAction } = createAnimation();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation is created, EffectiveWeight is 1." );
				animationAction.enabled = false;
				animationAction.setEffectiveWeight( 0.3 );
				assert.equal( animationAction.getEffectiveWeight(), 0, "When EffectiveWeight is set to 0.3 when disabled , EffectiveWeight is 0." );

			} );

			QUnit.test( "fadeIn", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				animationAction.fadeIn( 1000 );
				animationAction.play();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation fadeIn is started, EffectiveWeight is 1." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.25, "When an animation fadeIn happened 1/4, EffectiveWeight is 0.25." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.5, "When an animation fadeIn is halfway , EffectiveWeight is 0.5." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.75, "When an animation fadeIn is halfway , EffectiveWeight is 0.75." );
				mixer.update( 500 );
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation fadeIn is ended , EffectiveWeight is 1." );

			} );

			QUnit.test( "fadeOut", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				animationAction.fadeOut( 1000 );
				animationAction.play();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation fadeOut is started, EffectiveWeight is 1." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.75, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.5, "When an animation fadeOut is halfway , EffectiveWeight is 0.5." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.25, "When an animation fadeOut is happened 3/4 , EffectiveWeight is 0.25." );
				mixer.update( 500 );
				assert.equal( animationAction.getEffectiveWeight(), 0, "When an animation fadeOut is ended , EffectiveWeight is 0." );

			} );

			QUnit.test( "crossFadeFrom", ( assert ) => {

				var { mixer, animationAction, animationAction2 } = createTwoAnimations();
				animationAction.crossFadeFrom( animationAction2, 1000, false );
				animationAction.play();
				animationAction2.play();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation crossFadeFrom is started, EffectiveWeight is 1." );
				assert.equal( animationAction2.getEffectiveWeight(), 1, "When an animation crossFadeFrom is started, EffectiveWeight is 1." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.25, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.75, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.5, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.5, "When an animation fadeOut is halfway , EffectiveWeight is 0.5." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.75, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.25, "When an animation fadeOut is happened 3/4 , EffectiveWeight is 0.25." );
				mixer.update( 500 );
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0, "When an animation fadeOut is ended , EffectiveWeight is 0." );

			} );

			QUnit.test( "crossFadeTo", ( assert ) => {

				var { mixer, animationAction, animationAction2 } = createTwoAnimations();
				animationAction2.crossFadeTo( animationAction, 1000, false );
				animationAction.play();
				animationAction2.play();
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation crossFadeFrom is started, EffectiveWeight is 1." );
				assert.equal( animationAction2.getEffectiveWeight(), 1, "When an animation crossFadeFrom is started, EffectiveWeight is 1." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.25, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.75, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.5, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.5, "When an animation fadeOut is halfway , EffectiveWeight is 0.5." );
				mixer.update( 250 );
				assert.equal( animationAction.getEffectiveWeight(), 0.75, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0.25, "When an animation fadeOut is happened 3/4 , EffectiveWeight is 0.25." );
				mixer.update( 500 );
				assert.equal( animationAction.getEffectiveWeight(), 1, "When an animation fadeOut happened 1/4, EffectiveWeight is 0.75." );
				assert.equal( animationAction2.getEffectiveWeight(), 0, "When an animation fadeOut is ended , EffectiveWeight is 0." );

			} );

			QUnit.todo( "stopFading", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setEffectiveTimeScale", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getEffectiveTimeScale", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setDuration", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "syncWith", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "halt", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "warp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "stopWarping", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "getMixer", ( assert ) => {

				var { mixer, animationAction } = createAnimation();
				var mixer2 = animationAction.getMixer();
				assert.equal( mixer, mixer2, "mixer should be returned by getMixer." );

			} );

			QUnit.test( "getClip", ( assert ) => {

				var { clip, animationAction } = createAnimation();
				var clip2 = animationAction.getClip();
				assert.equal( clip, clip2, "clip should be returned by getClip." );

			} );

			QUnit.test( "getRoot", ( assert ) => {

				var { root, animationAction } = createAnimation();
				var root2 = animationAction.getRoot();
				assert.equal( root, root2, "root should be returned by getRoot." );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'AnimationClip', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// STATIC STUFF
			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "CreateFromMorphTargetSequence", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "findByName", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "CreateClipsFromMorphTargetSequences", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseAnimation", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "resetDuration", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "trim", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "optimize", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "validate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	const x = 2;
	const y = 3;
	const z = 4;
	const w = 5;

	const negInf2 = new Vector2( - Infinity, - Infinity );
	const posInf2 = new Vector2( Infinity, Infinity );


	const negOne2 = new Vector2( - 1, - 1 );

	const zero2 = new Vector2();
	const one2 = new Vector2( 1, 1 );
	const two2 = new Vector2( 2, 2 );

	const negInf3 = new Vector3( - Infinity, - Infinity, - Infinity );
	const posInf3 = new Vector3( Infinity, Infinity, Infinity );

	const zero3 = new Vector3();
	const one3 = new Vector3( 1, 1, 1 );
	const two3 = new Vector3( 2, 2, 2 );

	const eps = 0.0001;

	/* global QUnit */

	function getClips( pos1, pos2, scale1, scale2, dur ) {

		const clips = [];

		let track = new VectorKeyframeTrack( ".scale", [ 0, dur ], [ scale1.x, scale1.y, scale1.z, scale2.x, scale2.y, scale2.z ] );
		clips.push( new AnimationClip( "scale", dur, [ track ] ) );

		track = new VectorKeyframeTrack( ".position", [ 0, dur ], [ pos1.x, pos1.y, pos1.z, pos2.x, pos2.y, pos2.z ] );
		clips.push( new AnimationClip( "position", dur, [ track ] ) );

		return clips;

	}

	QUnit.module( 'Animation', () => {

		QUnit.module( 'AnimationMixer', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "clipAction", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "existingAction", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "stopAllAction", ( assert ) => {

				const obj = new Object3D();
				const animMixer = new AnimationMixer( obj );
				const clips = getClips( zero3, one3, two3, one3, 1 );
				const actionA = animMixer.clipAction( clips[ 0 ] );
				const actionB = animMixer.clipAction( clips[ 1 ] );

				actionA.play();
				actionB.play();
				animMixer.update( 0.1 );
				animMixer.stopAllAction();

				assert.ok(
					! actionA.isRunning() &&
					! actionB.isRunning(),
					"All actions stopped" );
				assert.ok(
					obj.position.x == 0 &&
					obj.position.y == 0 &&
					obj.position.z == 0,
					"Position reset as expected"
				);
				assert.ok(
					obj.scale.x == 1 &&
					obj.scale.y == 1 &&
					obj.scale.z == 1,
					"Scale reset as expected"
				);

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "getRoot", ( assert ) => {

				const obj = new Object3D();
				const animMixer = new AnimationMixer( obj );
				assert.strictEqual( obj, animMixer.getRoot(), "Get original root object" );

			} );

			QUnit.todo( "uncacheClip", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "uncacheRoot", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "uncacheAction", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 */

	class AnimationObjectGroup {

		constructor() {

			this.uuid = MathUtils.generateUUID();

			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );

			this.nCachedObjects_ = 0; // threshold
			// note: read by PropertyBinding.Composite

			const indices = {};
			this._indicesByUUID = indices; // for bookkeeping

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				indices[ arguments[ i ].uuid ] = i;

			}

			this._paths = []; // inside: string
			this._parsedPaths = []; // inside: { we don't care, here }
			this._bindings = []; // inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; // inside: indices in these arrays

			const scope = this;

			this.stats = {

				objects: {
					get total() {

						return scope._objects.length;

					},
					get inUse() {

						return this.total - scope.nCachedObjects_;

					}
				},
				get bindingsPerObject() {

					return scope._bindings.length;

				}

			};

		}

		add() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length;

			let knownObject = undefined,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid;
				let index = indicesByUUID[ uuid ];

				if ( index === undefined ) {

					// unknown object -> add it to the ACTIVE region

					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

					}

				} else if ( index < nCachedObjects ) {

					knownObject = objects[ index ];

					// move existing object to the ACTIVE region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];

					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ];

						let binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = lastCached;

						if ( binding === undefined ) {

							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist

							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

						}

						bindingsForPath[ firstActiveIndex ] = binding;

					}

				} else if ( objects[ index ] !== knownObject ) {

					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

				} // else the object is already where we want it to be

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		remove() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			let nCachedObjects = this.nCachedObjects_;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined && index >= nCachedObjects ) {

					// move existing object into the CACHED region

					const lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];

					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;

					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];

						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;

					}

				}

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		// remove & forget
		uncache() {

			const objects = this._objects,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;

			let nCachedObjects = this.nCachedObjects_,
				nObjects = objects.length;

			for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

				const object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];

				if ( index !== undefined ) {

					delete indicesByUUID[ uuid ];

					if ( index < nCachedObjects ) {

						// object is cached, shrink the CACHED region

						const firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;

						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( let j = 0, m = nBindings; j !== m; ++ j ) {

							const bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];

							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();

						}

					} else {

						// object is active, just swap with the last and pop

						const lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];

						if ( lastIndex > 0 ) {

							indicesByUUID[ lastObject.uuid ] = index;

						}

						objects[ index ] = lastObject;
						objects.pop();

						// accounting is done, now do the same for all bindings

						for ( let j = 0, m = nBindings; j !== m; ++ j ) {

							const bindingsForPath = bindings[ j ];

							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();

						}

					} // cached or active

				} // if object is known

			} // for arguments

			this.nCachedObjects_ = nCachedObjects;

		}

		// Internal interface used by befriended PropertyBinding.Composite:

		subscribe_( path, parsedPath ) {

			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group

			const indicesByPath = this._bindingsIndicesByPath;
			let index = indicesByPath[ path ];
			const bindings = this._bindings;

			if ( index !== undefined ) return bindings[ index ];

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );

			index = bindings.length;

			indicesByPath[ path ] = index;

			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );

			for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

				const object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

			}

			return bindingsForPath;

		}

		unsubscribe_( path ) {

			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'

			const indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];

			if ( index !== undefined ) {

				const paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];

				indicesByPath[ lastBindingsPath ] = index;

				bindings[ index ] = lastBindings;
				bindings.pop();

				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();

				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();

			}

		}

	}

	AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

	/* global QUnit */

	QUnit.module( "Animation", () => {

		QUnit.module( "AnimationObjectGroup", () => {

			var ObjectA = new Object3D(),
				ObjectB = new Object3D(),
				ObjectC = new Object3D(),

				PathA = 'object.position',
				PathB = 'object.rotation',
				PathC = 'object.scale',

				ParsedPathA = PropertyBinding.parseTrackName( PathA ),
				ParsedPathB = PropertyBinding.parseTrackName( PathB ),
				ParsedPathC = PropertyBinding.parseTrackName( PathC );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isAnimationObjectGroup", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "add", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "remove", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "uncache", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( "smoke test", ( assert ) => {

				var expect = function expect( testIndex, group, bindings, path, cached, roots ) {

					var rootNodes = [], pathsOk = true, nodesOk = true;

					for ( var i = group.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

						if ( bindings[ i ].path !== path ) pathsOk = false;
						rootNodes.push( bindings[ i ].rootNode );

					}

					for ( var i = 0, n = roots.length; i !== n; ++ i ) {

						if ( rootNodes.indexOf( roots[ i ] ) === - 1 ) nodesOk = false;

					}

					assert.ok( pathsOk, QUnit.testIndex + " paths" );
					assert.ok( nodesOk, QUnit.testIndex + " nodes" );
					assert.ok( group.nCachedObjects_ === cached, QUnit.testIndex + " cache size" );
					assert.ok( bindings.length - group.nCachedObjects_ === roots.length, QUnit.testIndex + " object count" );

				};

				// initial state

				var groupA = new AnimationObjectGroup();
				assert.ok( groupA instanceof AnimationObjectGroup, "constructor (w/o args)" );

				var bindingsAA = groupA.subscribe_( PathA, ParsedPathA );
				expect( 0, groupA, bindingsAA, PathA, 0, [] );

				var groupB = new AnimationObjectGroup( ObjectA, ObjectB );
				assert.ok( groupB instanceof AnimationObjectGroup, "constructor (with args)" );

				var bindingsBB = groupB.subscribe_( PathB, ParsedPathB );
				expect( 1, groupB, bindingsBB, PathB, 0, [ ObjectA, ObjectB ] );

				// add

				groupA.add( ObjectA, ObjectB );
				expect( 2, groupA, bindingsAA, PathA, 0, [ ObjectA, ObjectB ] );

				groupB.add( ObjectC );
				expect( 3, groupB, bindingsBB, PathB, 0, [ ObjectA, ObjectB, ObjectC ] );

				// remove

				groupA.remove( ObjectA, ObjectC );
				expect( 4, groupA, bindingsAA, PathA, 1, [ ObjectB ] );

				groupB.remove( ObjectA, ObjectB, ObjectC );
				expect( 5, groupB, bindingsBB, PathB, 3, [] );

				// subscribe after re-add

				groupA.add( ObjectC );
				expect( 6, groupA, bindingsAA, PathA, 1, [ ObjectB, ObjectC ] );
				var bindingsAC = groupA.subscribe_( PathC, ParsedPathC );
				expect( 7, groupA, bindingsAC, PathC, 1, [ ObjectB, ObjectC ] );

				// re-add after subscribe

				var bindingsBC = groupB.subscribe_( PathC, ParsedPathC );
				groupB.add( ObjectA, ObjectB );
				expect( 8, groupB, bindingsBB, PathB, 1, [ ObjectA, ObjectB ] );

				// unsubscribe

				var copyOfBindingsBC = bindingsBC.slice();
				groupB.unsubscribe_( PathC );
				groupB.add( ObjectC );
				assert.deepEqual( bindingsBC, copyOfBindingsBC, "no more update after unsubscribe" );

				// uncache active

				groupB.uncache( ObjectA );
				expect( 9, groupB, bindingsBB, PathB, 0, [ ObjectB, ObjectC ] );

				// uncache cached

				groupA.uncache( ObjectA );
				expect( 10, groupA, bindingsAC, PathC, 0, [ ObjectB, ObjectC ] );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'AnimationUtils', () => {

			// PUBLIC STUFF
			QUnit.todo( "arraySlice", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "convertArray", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "isTypedArray", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getKeyframeOrder", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "sortedArray", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "flattenJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'KeyframeTrack', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// STATIC STUFF
			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "TimeBufferType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "ValueBufferType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "DefaultInterpolation", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "InterpolantFactoryMethodDiscrete", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "InterpolantFactoryMethodLinear", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "InterpolantFactoryMethodSmooth", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setInterpolation", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getInterpolation", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getValueSize", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "shift", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "scale", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "trim", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( 'validate', ( assert ) => {

				var validTrack = new NumberKeyframeTrack( '.material.opacity', [ 0, 1 ], [ 0, 0.5 ] );
				var invalidTrack = new NumberKeyframeTrack( '.material.opacity', [ 0, 1 ], [ 0, NaN ] );

				assert.ok( validTrack.validate() );

				console.level = CONSOLE_LEVEL.OFF;
				assert.notOk( invalidTrack.validate() );
				console.level = CONSOLE_LEVEL.DEFAULT;

			} );

			QUnit.test( 'optimize', ( assert ) => {

				var track = new NumberKeyframeTrack( '.material.opacity', [ 0, 1, 2, 3, 4 ], [ 0, 0, 0, 0, 1 ] );

				assert.equal( track.values.length, 5 );

				track.optimize();

				assert.smartEqual( Array.from( track.times ), [ 0, 3, 4 ] );
				assert.smartEqual( Array.from( track.values ), [ 0, 0, 1 ] );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'PropertyBinding', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// STATIC STUFF
			QUnit.todo( "Composite", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "create", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( 'sanitizeNodeName', ( assert ) => {

				assert.equal(
					PropertyBinding.sanitizeNodeName( 'valid-name-123_' ),
					'valid-name-123_',
					'Leaves valid name intact.'
				);

				assert.equal(
					PropertyBinding.sanitizeNodeName( '' ),
					'',
					'Leaves non-latin unicode characters intact.'
				);

				assert.equal(
					PropertyBinding.sanitizeNodeName( 'space separated name 123_ -' ),
					'space_separated_name_123__-',
					'Replaces spaces with underscores.'
				);

				assert.equal(
					PropertyBinding.sanitizeNodeName( '"Mtys" %_* ' ),
					'"Mtys"_%_*_',
					'Allows various punctuation and symbols.'
				);

				assert.equal(
					PropertyBinding.sanitizeNodeName( '/invalid: name ^123.[_]' ),
					'invalid_name_^123_',
					'Strips reserved characters.'
				);

			} );

			QUnit.test( 'parseTrackName', ( assert ) => {

				var paths = [

					[
						'.property',
						{
							nodeName: undefined,
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'nodeName.property',
						{
							nodeName: 'nodeName',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'a.property',
						{
							nodeName: 'a',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'no.de.Name.property',
						{
							nodeName: 'no.de.Name',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'no.d-e.Name.property',
						{
							nodeName: 'no.d-e.Name',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'nodeName.property[accessor]',
						{
							nodeName: 'nodeName',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: 'accessor'
						}
					],

					[
						'nodeName.material.property[accessor]',
						{
							nodeName: 'nodeName',
							objectName: 'material',
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: 'accessor'
						}
					],

					[
						'no.de.Name.material.property',
						{
							nodeName: 'no.de.Name',
							objectName: 'material',
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'no.de.Name.material[materialIndex].property',
						{
							nodeName: 'no.de.Name',
							objectName: 'material',
							objectIndex: 'materialIndex',
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'uuid.property[accessor]',
						{
							nodeName: 'uuid',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: 'accessor'
						}
					],

					[
						'uuid.objectName[objectIndex].propertyName[propertyIndex]',
						{
							nodeName: 'uuid',
							objectName: 'objectName',
							objectIndex: 'objectIndex',
							propertyName: 'propertyName',
							propertyIndex: 'propertyIndex'
						}
					],

					[
						'parentName/nodeName.property',
						{
							// directoryName is currently unused.
							nodeName: 'nodeName',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'parentName/no.de.Name.property',
						{
							// directoryName is currently unused.
							nodeName: 'no.de.Name',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: undefined
						}
					],

					[
						'parentName/parentName/nodeName.property[index]',
						{
							// directoryName is currently unused.
							nodeName: 'nodeName',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'property',
							propertyIndex: 'index'
						}
					],

					[
						'.bone[Armature.DEF_cog].position',
						{
							nodeName: undefined,
							objectName: 'bone',
							objectIndex: 'Armature.DEF_cog',
							propertyName: 'position',
							propertyIndex: undefined
						}
					],

					[
						'scene:helium_balloon_model:helium_balloon_model.position',
						{
							nodeName: 'helium_balloon_model',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: 'position',
							propertyIndex: undefined
						}
					],

					[
						'.[]',
						{
							nodeName: '',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: '',
							propertyIndex: ''
						}
					],

					[
						'.[]',
						{
							nodeName: '',
							objectName: undefined,
							objectIndex: undefined,
							propertyName: '',
							propertyIndex: ''
						}
					]

				];

				paths.forEach( function ( path ) {

					assert.smartEqual(
						PropertyBinding.parseTrackName( path[ 0 ] ),
						path[ 1 ],
						'Parses track name: ' + path[ 0 ]
					);

				} );

			} );

			QUnit.todo( "findNode", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "BindingType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "Versioning", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "GetterByBindingType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "SetterByBindingTypeAndVersioning", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getValue", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( 'setValue', ( assert ) => {

				var paths = [
					'.material.opacity',
					'.material[opacity]'
				];

				paths.forEach( function ( path ) {

					var originalValue = 0;
					var expectedValue = 1;

					var geometry = new BoxGeometry();
					var material = new MeshBasicMaterial();
					material.opacity = originalValue;
					var mesh = new Mesh( geometry, material );

					var binding = new PropertyBinding( mesh, path, null );
					binding.bind();

					assert.equal(
						material.opacity,
						originalValue,
						'Sets property of material with "' + path + '" (pre-setValue)'
					);

					binding.setValue( [ expectedValue ], 0 );
					assert.equal(
						material.opacity,
						expectedValue,
						'Sets property of material with "' + path + '" (post-setValue)'
					);

				} );

			} );

			QUnit.todo( "bind", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "unbind", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'PropertyMixer', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "accumulate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "apply", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "saveOriginalState", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "restoreOriginalState", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'BooleanKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'ColorKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'NumberKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'QuaternionKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'StringKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Animation', () => {

		QUnit.module( 'Tracks', () => {

			QUnit.module( 'VectorKeyframeTrack', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Audios', () => {

		QUnit.module( 'Audio', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "getOutput", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setNodeSource", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setBuffer", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "play", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "pause", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "stop", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "connect", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "disconnect", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFilters", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setFilters", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFilter", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setFilter", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPlaybackRate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getPlaybackRate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onEnded", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getLoop", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setLoop", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getVolume", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setVolume", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Audios', () => {

		QUnit.module( 'AudioAnalyser', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "getFrequencyData", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getAverageFrequency", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Audios', () => {

		QUnit.module( 'AudioContext', () => {

			// PUBLIC STUFF
			QUnit.todo( "getContext", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setContext", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	class Clock {

		constructor( autoStart ) {

			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;

			this.running = false;

		}

		start() {

			this.startTime = now();

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		}

		stop() {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		}

		getElapsedTime() {

			this.getDelta();
			return this.elapsedTime;

		}

		getDelta() {

			let diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				const newTime = now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	}

	function now() {

		return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

	}

	/* global QUnit */

	QUnit.module( 'Audios', () => {

		QUnit.module( 'AudioListener', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "getInput", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "removeFilter", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFilter", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setFilter", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getMasterVolume", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setMasterVolume", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Audios', () => {

		QUnit.module( 'PositionalAudio', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "getOutput", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getRefDistance", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setRefDistance", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getRolloffFactor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setRolloffFactor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getDistanceModel", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setDistanceModel", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getMaxDistance", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setMaxDistance", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	function ArrayCamera( array = [] ) {

		PerspectiveCamera.call( this );

		this.cameras = array;

	}

	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

		constructor: ArrayCamera,

		isArrayCamera: true

	} );

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'ArrayCamera', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isArrayCamera", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'Camera', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isCamera", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getWorldDirection", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var cam = new Camera();

				// fill the matrices with any nonsense values just to see if they get copied
				cam.matrixWorldInverse.set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				cam.projectionMatrix.set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );

				var clonedCam = cam.clone();

				// TODO: Uuuummmhhh DO NOT relie equality on object methods !
				// TODO: What's append if matrix.equal is wrongly implemented ???
				// TODO: this MUST be check by assert
				assert.ok( cam.matrixWorldInverse.equals( clonedCam.matrixWorldInverse ), "matrixWorldInverse is equal" );
				assert.ok( cam.projectionMatrix.equals( clonedCam.projectionMatrix ), "projectionMatrix is equal" );

			} );

			// OTHERS
			// TODO: this should not be here !!! This is Object3D stuff !!!
			QUnit.test( "lookAt", ( assert ) => {

				var cam = new Camera();
				cam.lookAt( new Vector3( 0, 1, - 1 ) );

				assert.numEqual( cam.rotation.x * ( 180 / Math.PI ), 45, "x is equal" );

			} );

		} );

	} );

	const fov = 90, aspect = 1;

	class CubeCamera extends Object3D {

		constructor( near, far, renderTarget ) {

			super();

			this.type = 'CubeCamera';

			if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

				console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
				return;

			}

			this.renderTarget = renderTarget;

			const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.layers = this.layers;
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );

			const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.layers = this.layers;
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );

			const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.layers = this.layers;
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );

			const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.layers = this.layers;
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );

			const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.layers = this.layers;
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );

			const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.layers = this.layers;
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );

		}

		update( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			const renderTarget = this.renderTarget;

			const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

			const currentXrEnabled = renderer.xr.enabled;
			const currentRenderTarget = renderer.getRenderTarget();

			renderer.xr.enabled = false;

			const generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

			renderer.xr.enabled = currentXrEnabled;

		}

	}

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'CubeCamera', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'OrthographicCamera', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isOrthographicCamera", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setViewOffset", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clearViewOffset", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "updateProjectionMatrix", ( assert ) => {

				var left = - 1, right = 1, top = 1, bottom = - 1, near = 1, far = 3;
				var cam = new OrthographicCamera( left, right, top, bottom, near, far );

				// updateProjectionMatrix is called in constructor
				var pMatrix = cam.projectionMatrix.elements;

				// orthographic projection is given my the 4x4 Matrix
				// 2/r-l		0			 0		-(l+r/r-l)
				//   0		2/t-b		 0		-(t+b/t-b)
				//   0			0		-2/f-n	-(f+n/f-n)
				//   0			0			 0				1

				assert.ok( pMatrix[ 0 ] === 2 / ( right - left ), "m[0,0] === 2 / (r - l)" );
				assert.ok( pMatrix[ 5 ] === 2 / ( top - bottom ), "m[1,1] === 2 / (t - b)" );
				assert.ok( pMatrix[ 10 ] === - 2 / ( far - near ), "m[2,2] === -2 / (f - n)" );
				assert.ok( pMatrix[ 12 ] === - ( ( right + left ) / ( right - left ) ), "m[3,0] === -(r+l/r-l)" );
				assert.ok( pMatrix[ 13 ] === - ( ( top + bottom ) / ( top - bottom ) ), "m[3,1] === -(t+b/b-t)" );
				assert.ok( pMatrix[ 14 ] === - ( ( far + near ) / ( far - near ) ), "m[3,2] === -(f+n/f-n)" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			// TODO: no no no clone is a camera methods that relied to copy method
			QUnit.test( "clone", ( assert ) => {

				var left = - 1.5, right = 1.5, top = 1, bottom = - 1, near = 0.1, far = 42;
				var cam = new OrthographicCamera( left, right, top, bottom, near, far );

				var clonedCam = cam.clone();

				assert.ok( cam.left === clonedCam.left, "left is equal" );
				assert.ok( cam.right === clonedCam.right, "right is equal" );
				assert.ok( cam.top === clonedCam.top, "top is equal" );
				assert.ok( cam.bottom === clonedCam.bottom, "bottom is equal" );
				assert.ok( cam.near === clonedCam.near, "near is equal" );
				assert.ok( cam.far === clonedCam.far, "far is equal" );
				assert.ok( cam.zoom === clonedCam.zoom, "zoom is equal" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'PerspectiveCamera', () => {

			// see e.g. math/Matrix4.js
			var matrixEquals4 = function ( a, b, tolerance ) {

				tolerance = tolerance || 0.0001;
				if ( a.elements.length != b.elements.length ) {

					return false;

				}
				for ( var i = 0, il = a.elements.length; i < il; i ++ ) {

					var delta = a.elements[ i ] - b.elements[ i ];
					if ( delta > tolerance ) {

						return false;

					}

				}

				return true;

			};

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isPerspectiveCamera", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setFocalLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFocalLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getEffectiveFOV", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFilmWidth", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getFilmHeight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setViewOffset", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clearViewOffset", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "updateProjectionMatrix", ( assert ) => {

				var cam = new PerspectiveCamera( 75, 16 / 9, 0.1, 300.0 );

				// updateProjectionMatrix is called in constructor
				var m = cam.projectionMatrix;

				// perspective projection is given my the 4x4 Matrix
				// 2n/r-l		0			l+r/r-l				 0
				//   0		2n/t-b	t+b/t-b				 0
				//   0			0		-(f+n/f-n)	-(2fn/f-n)
				//   0			0				-1					 0

				// this matrix was calculated by hand via glMatrix.perspective(75, 16 / 9, 0.1, 300.0, pMatrix)
				// to get a reference matrix from plain WebGL
				var reference = new Matrix4().set(
					0.7330642938613892, 0, 0, 0,
					0, 1.3032253980636597, 0, 0,
					0, 0, - 1.000666856765747, - 0.2000666856765747,
					0, 0, - 1, 0
				);

				// assert.ok( reference.equals(m) );
				assert.ok( matrixEquals4( reference, m, 0.000001 ) );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			// TODO: no no no clone is a camera methods that relied to copy method
			QUnit.test( "clone", ( assert ) => {

				var near = 1,
					far = 3,
					aspect = 16 / 9,
					fov = 90;

				var cam = new PerspectiveCamera( fov, aspect, near, far );

				var clonedCam = cam.clone();

				assert.ok( cam.fov === clonedCam.fov, "fov is equal" );
				assert.ok( cam.aspect === clonedCam.aspect, "aspect is equal" );
				assert.ok( cam.near === clonedCam.near, "near is equal" );
				assert.ok( cam.far === clonedCam.far, "far is equal" );
				assert.ok( cam.zoom === clonedCam.zoom, "zoom is equal" );
				assert.ok( cam.projectionMatrix.equals( clonedCam.projectionMatrix ), "projectionMatrix is equal" );

			} );

		} );

	} );

	new Matrix4();
	new Matrix4();

	/* global QUnit */

	QUnit.module( 'Cameras', () => {

		QUnit.module( 'StereoCamera', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'BufferAttribute', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				assert.throws(
					function () {

						new BufferAttribute( [ 1, 2, 3, 4 ], 2, false );

					},
					/array should be a Typed Array/,
					"Calling constructor with a simple array throws Error"
				);

			} );

			// PROPERTIES
			QUnit.todo( "needsUpdate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isBufferAttribute", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setUsage", ( assert ) => {

				var attr = new BufferAttribute();
				attr.setUsage( DynamicDrawUsage );

				assert.strictEqual( attr.usage, DynamicDrawUsage, "Usage was set" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 );
				attr.setUsage( DynamicDrawUsage );
				attr.needsUpdate = true;

				var attrCopy = new BufferAttribute().copy( attr );

				assert.ok( attr.count === attrCopy.count, 'count is equal' );
				assert.ok( attr.itemSize === attrCopy.itemSize, 'itemSize is equal' );
				assert.ok( attr.usage === attrCopy.usage, 'usage is equal' );
				assert.ok( attr.array.length === attrCopy.array.length, 'array length is equal' );
				assert.ok( attr.version === 1 && attrCopy.version === 0, 'version is not copied which is good' );

			} );

			QUnit.test( "copyAt", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ), 3 );
				var attr2 = new BufferAttribute( new Float32Array( 9 ), 3 );

				attr2.copyAt( 1, attr, 2 );
				attr2.copyAt( 0, attr, 1 );
				attr2.copyAt( 2, attr, 0 );

				var i = attr.array;
				var i2 = attr2.array; // should be [4, 5, 6, 7, 8, 9, 1, 2, 3]

				assert.ok( i2[ 0 ] === i[ 3 ] && i2[ 1 ] === i[ 4 ] && i2[ 2 ] === i[ 5 ], 'chunck copied to correct place' );
				assert.ok( i2[ 3 ] === i[ 6 ] && i2[ 4 ] === i[ 7 ] && i2[ 5 ] === i[ 8 ], 'chunck copied to correct place' );
				assert.ok( i2[ 6 ] === i[ 0 ] && i2[ 7 ] === i[ 1 ] && i2[ 8 ] === i[ 2 ], 'chunck copied to correct place' );

			} );

			QUnit.test( "copyArray", ( assert ) => {

				var f32a = new Float32Array( [ 5, 6, 7, 8 ] );
				var a = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4 ] ), 2, false );

				a.copyArray( f32a );

				assert.deepEqual( a.array, f32a, "Check array has new values" );

			} );

			QUnit.test( "copyColorsArray", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( 6 ), 3 );

				attr.copyColorsArray( [
					new Color( 0, 0.5, 1 ),
					new Color( 0.25, 1, 0 )
				] );

				var i = attr.array;
				assert.ok( i[ 0 ] === 0 && i[ 1 ] === 0.5 && i[ 2 ] === 1, 'first color was copied correctly' );
				assert.ok( i[ 3 ] === 0.25 && i[ 4 ] === 1 && i[ 5 ] === 0, 'second color was copied correctly' );

			} );

			QUnit.test( "copyVector2sArray", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( 4 ), 2 );

				attr.copyVector2sArray( [
					new Vector2( 1, 2 ),
					new Vector2( 4, 5 )
				] );

				var i = attr.array;
				assert.ok( i[ 0 ] === 1 && i[ 1 ] === 2, 'first vector was copied correctly' );
				assert.ok( i[ 2 ] === 4 && i[ 3 ] === 5, 'second vector was copied correctly' );

			} );

			QUnit.test( "copyVector3sArray", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( 6 ), 2 );

				attr.copyVector3sArray( [
					new Vector3( 1, 2, 3 ),
					new Vector3( 10, 20, 30 )
				] );

				var i = attr.array;
				assert.ok( i[ 0 ] === 1 && i[ 1 ] === 2 && i[ 2 ] === 3, 'first vector was copied correctly' );
				assert.ok( i[ 3 ] === 10 && i[ 4 ] === 20 && i[ 5 ] === 30, 'second vector was copied correctly' );

			} );

			QUnit.test( "copyVector4sArray", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( 8 ), 2 );

				attr.copyVector4sArray( [
					new Vector4( 1, 2, 3, 4 ),
					new Vector4( 10, 20, 30, 40 )
				] );

				var i = attr.array;
				assert.ok( i[ 0 ] === 1 && i[ 1 ] === 2 && i[ 2 ] === 3 && i[ 3 ] === 4, 'first vector was copied correctly' );
				assert.ok( i[ 4 ] === 10 && i[ 5 ] === 20 && i[ 6 ] === 30 && i[ 7 ] === 40, 'second vector was copied correctly' );

			} );

			QUnit.test( "set", ( assert ) => {

				var f32a = new Float32Array( [ 1, 2, 3, 4 ] );
				var a = new BufferAttribute( f32a, 2, false );
				var expected = new Float32Array( [ 9, 2, 8, 4 ] );

				a.set( [ 9 ] );
				a.set( [ 8 ], 2 );

				assert.deepEqual( a.array, expected, "Check array has expected values" );

			} );

			QUnit.test( "set[X, Y, Z, W, XYZ, XYZW]/get[X, Y, Z, W]", ( assert ) => {

				var f32a = new Float32Array( [ 1, 2, 3, 4, 5, 6, 7, 8 ] );
				var a = new BufferAttribute( f32a, 4, false );
				var expected = new Float32Array( [ 1, 2, - 3, - 4, - 5, - 6, 7, 8 ] );

				a.setX( 1, a.getX( 1 ) * - 1 );
				a.setY( 1, a.getY( 1 ) * - 1 );
				a.setZ( 0, a.getZ( 0 ) * - 1 );
				a.setW( 0, a.getW( 0 ) * - 1 );

				assert.deepEqual( a.array, expected, "Check all set* calls set the correct values" );

			} );

			QUnit.test( "setXY", ( assert ) => {

				var f32a = new Float32Array( [ 1, 2, 3, 4 ] );
				var a = new BufferAttribute( f32a, 2, false );
				var expected = new Float32Array( [ - 1, - 2, 3, 4 ] );

				a.setXY( 0, - 1, - 2 );

				assert.deepEqual( a.array, expected, "Check for the correct values" );

			} );

			QUnit.test( "setXYZ", ( assert ) => {

				var f32a = new Float32Array( [ 1, 2, 3, 4, 5, 6 ] );
				var a = new BufferAttribute( f32a, 3, false );
				var expected = new Float32Array( [ 1, 2, 3, - 4, - 5, - 6 ] );

				a.setXYZ( 1, - 4, - 5, - 6 );

				assert.deepEqual( a.array, expected, "Check for the correct values" );

			} );

			QUnit.test( "setXYZW", ( assert ) => {

				var f32a = new Float32Array( [ 1, 2, 3, 4 ] );
				var a = new BufferAttribute( f32a, 4, false );
				var expected = new Float32Array( [ - 1, - 2, - 3, - 4 ] );

				a.setXYZW( 0, - 1, - 2, - 3, - 4 );

				assert.deepEqual( a.array, expected, "Check for the correct values" );

			} );

			QUnit.test( "onUpload", ( assert ) => {

				var a = new BufferAttribute();
				var func = function () { };

				a.onUpload( func );

				assert.strictEqual( a.onUploadCallback, func, "Check callback was set properly" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 0.12, - 12 ] ), 2 );
				var attrCopy = attr.clone();

				assert.ok( attr.array.length === attrCopy.array.length, 'attribute was cloned' );
				for ( var i = 0; i < attr.array.length; i ++ ) {

					assert.ok( attr.array[ i ] === attrCopy.array[ i ], 'array item is equal' );

				}

			} );

			QUnit.test( "toJSON", ( assert ) => {

				const attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3, true );
				assert.deepEqual( attr.toJSON(), {
					itemSize: 3,
					type: 'Float32Array',
					array: [ 1, 2, 3, 4, 5, 6 ],
					normalized: true
				}, 'Serialized to JSON as expected' );

			} );

			// OTHERS
			QUnit.test( "count", ( assert ) => {

				assert.ok(
					new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 ).count === 2,
					'count is equal to the number of chunks'
				);

			} );

		} );

		QUnit.module( 'Int8BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Uint8BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Uint8ClampedBufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Int16BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Uint16BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Int32BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Uint32BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Float32BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

		QUnit.module( 'Float64BufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	var DegToRad = Math.PI / 180;

	function bufferAttributeEquals( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;

		if ( a.count !== b.count || a.itemSize !== b.itemSize ) {

			return false;

		}

		for ( var i = 0, il = a.count * a.itemSize; i < il; i ++ ) {

			var delta = a[ i ] - b[ i ];
			if ( delta > tolerance ) {

				return false;

			}

		}

		return true;

	}

	function getBBForVertices( vertices ) {

		var geometry = new BufferGeometry();

		geometry.setAttribute( "position", new BufferAttribute( new Float32Array( vertices ), 3 ) );
		geometry.computeBoundingBox();

		return geometry.boundingBox;

	}

	function getBSForVertices( vertices ) {

		var geometry = new BufferGeometry();

		geometry.setAttribute( "position", new BufferAttribute( new Float32Array( vertices ), 3 ) );
		geometry.computeBoundingSphere();

		return geometry.boundingSphere;

	}

	function getNormalsForVertices( vertices, assert ) {

		var geometry = new BufferGeometry();

		geometry.setAttribute( "position", new BufferAttribute( new Float32Array( vertices ), 3 ) );

		geometry.computeVertexNormals();

		assert.ok( geometry.attributes.normal !== undefined, "normal attribute was created" );

		return geometry.attributes.normal.array;

	}

	QUnit.module( 'Core', () => {

		QUnit.module( 'BufferGeometry', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isBufferGeometry", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setIndex/getIndex", ( assert ) => {

				var a = new BufferGeometry();
				var uint16 = [ 1, 2, 3 ];
				var uint32 = [ 65535, 65536, 65537 ];
				var str = "foo";

				a.setIndex( uint16 );
				assert.ok( a.getIndex() instanceof Uint16BufferAttribute, "Index has the right type" );
				assert.deepEqual( a.getIndex().array, new Uint16Array( uint16 ), "Small index gets stored correctly" );

				a.setIndex( uint32 );
				assert.ok( a.getIndex() instanceof Uint32BufferAttribute, "Index has the right type" );
				assert.deepEqual( a.getIndex().array, new Uint32Array( uint32 ), "Large index gets stored correctly" );

				a.setIndex( str );
				assert.strictEqual( a.getIndex(), str, "Weird index gets stored correctly" );

			} );

			QUnit.todo( "getAttribute", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set / delete Attribute", ( assert ) => {

				var geometry = new BufferGeometry();
				var attributeName = "position";

				assert.ok( geometry.attributes[ attributeName ] === undefined, 'no attribute defined' );

				geometry.setAttribute( attributeName, new BufferAttribute( new Float32Array( [ 1, 2, 3 ], 1 ) ) );

				assert.ok( geometry.attributes[ attributeName ] !== undefined, 'attribute is defined' );

				geometry.deleteAttribute( attributeName );

				assert.ok( geometry.attributes[ attributeName ] === undefined, 'no attribute defined' );

			} );

			QUnit.test( "addGroup", ( assert ) => {

				var a = new BufferGeometry();
				var expected = [
					{
						start: 0,
						count: 1,
						materialIndex: 0
					},
					{
						start: 1,
						count: 2,
						materialIndex: 2
					}
				];

				a.addGroup( 0, 1, 0 );
				a.addGroup( 1, 2, 2 );

				assert.deepEqual( a.groups, expected, "Check groups were stored correctly and in order" );

				a.clearGroups();
				assert.strictEqual( a.groups.length, 0, "Check groups were deleted correctly" );

			} );
			QUnit.todo( "clearGroups", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setDrawRange", ( assert ) => {

				var a = new BufferGeometry();

				a.setDrawRange( 1.0, 7 );

				assert.deepEqual( a.drawRange, {
					start: 1,
					count: 7
				}, "Check draw range was stored correctly" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "position", new BufferAttribute( new Float32Array( 6 ), 3 ) );

				var matrix = new Matrix4().set(
					1, 0, 0, 1.5,
					0, 1, 0, - 2,
					0, 0, 1, 3,
					0, 0, 0, 1
				);
				geometry.applyMatrix4( matrix );

				var position = geometry.attributes.position.array;
				var m = matrix.elements;
				assert.ok( position[ 0 ] === m[ 12 ] && position[ 1 ] === m[ 13 ] && position[ 2 ] === m[ 14 ], "position was extracted from matrix" );
				assert.ok( position[ 3 ] === m[ 12 ] && position[ 4 ] === m[ 13 ] && position[ 5 ] === m[ 14 ], "position was extracted from matrix twice" );
				assert.ok( geometry.attributes.position.version === 1, "version was increased during update" );

			} );

			QUnit.test( "rotateX/Y/Z", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "position", new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 ) );

				var pos = geometry.attributes.position.array;

				geometry.rotateX( 180 * DegToRad );

				// object was rotated around x so all items should be flipped but the x ones
				assert.ok( pos[ 0 ] === 1 && pos[ 1 ] === - 2 && pos[ 2 ] === - 3 &&
					pos[ 3 ] === 4 && pos[ 4 ] === - 5 && pos[ 5 ] === - 6, "vertices were rotated around x by 180 degrees" );

				geometry.rotateY( 180 * DegToRad );

				// vertices were rotated around y so all items should be flipped again but the y ones
				assert.ok( pos[ 0 ] === - 1 && pos[ 1 ] === - 2 && pos[ 2 ] === 3 &&
					pos[ 3 ] === - 4 && pos[ 4 ] === - 5 && pos[ 5 ] === 6, "vertices were rotated around y by 180 degrees" );

				geometry.rotateZ( 180 * DegToRad );

				// vertices were rotated around z so all items should be flipped again but the z ones
				assert.ok( pos[ 0 ] === 1 && pos[ 1 ] === 2 && pos[ 2 ] === 3 &&
					pos[ 3 ] === 4 && pos[ 4 ] === 5 && pos[ 5 ] === 6, "vertices were rotated around z by 180 degrees" );

			} );

			QUnit.test( "translate", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "position", new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 ) );

				var pos = geometry.attributes.position.array;

				geometry.translate( 10, 20, 30 );

				assert.ok( pos[ 0 ] === 11 && pos[ 1 ] === 22 && pos[ 2 ] === 33 &&
					pos[ 3 ] === 14 && pos[ 4 ] === 25 && pos[ 5 ] === 36, "vertices were translated" );

			} );

			QUnit.test( "scale", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "position", new BufferAttribute( new Float32Array( [ - 1, - 1, - 1, 2, 2, 2 ] ), 3 ) );

				var pos = geometry.attributes.position.array;

				geometry.scale( 1, 2, 3 );

				assert.ok( pos[ 0 ] === - 1 && pos[ 1 ] === - 2 && pos[ 2 ] === - 3 &&
					pos[ 3 ] === 2 && pos[ 4 ] === 4 && pos[ 5 ] === 6, "vertices were scaled" );

			} );

			QUnit.test( "lookAt", ( assert ) => {

				var a = new BufferGeometry();
				var vertices = new Float32Array( [
					- 1.0, - 1.0, 1.0,
					1.0, - 1.0, 1.0,
					1.0, 1.0, 1.0,

					1.0, 1.0, 1.0,
					- 1.0, 1.0, 1.0,
					- 1.0, - 1.0, 1.0
				] );
				a.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );

				var sqrt = Math.sqrt( 2 );
				var expected = new Float32Array( [
					1, 0, - sqrt,
					- 1, 0, - sqrt,
					- 1, sqrt, 0,

					- 1, sqrt, 0,
					1, sqrt, 0,
					1, 0, - sqrt
				] );

				a.lookAt( new Vector3( 0, 1, - 1 ) );

				assert.ok( bufferAttributeEquals( a.attributes.position.array, expected ), "Rotation is correct" );

			} );

			QUnit.test( "center", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "position", new BufferAttribute( new Float32Array( [
					- 1, - 1, - 1,
					1, 1, 1,
					4, 4, 4
				] ), 3 ) );

				geometry.center();

				var pos = geometry.attributes.position.array;

				// the boundingBox should go from (-1, -1, -1) to (4, 4, 4) so it has a size of (5, 5, 5)
				// after centering it the vertices should be placed between (-2.5, -2.5, -2.5) and (2.5, 2.5, 2.5)
				assert.ok( pos[ 0 ] === - 2.5 && pos[ 1 ] === - 2.5 && pos[ 2 ] === - 2.5 &&
					pos[ 3 ] === - 0.5 && pos[ 4 ] === - 0.5 && pos[ 5 ] === - 0.5 &&
					pos[ 6 ] === 2.5 && pos[ 7 ] === 2.5 && pos[ 8 ] === 2.5, "vertices were replaced by boundingBox dimensions" );

			} );

			QUnit.test( "computeBoundingBox", ( assert ) => {

				var bb = getBBForVertices( [ - 1, - 2, - 3, 13, - 2, - 3.5, - 1, - 20, 0, - 4, 5, 6 ] );

				assert.ok( bb.min.x === - 4 && bb.min.y === - 20 && bb.min.z === - 3.5, "min values are set correctly" );
				assert.ok( bb.max.x === 13 && bb.max.y === 5 && bb.max.z === 6, "max values are set correctly" );

				var bb = getBBForVertices( [ - 1, - 1, - 1 ] );

				assert.ok( bb.min.x === bb.max.x && bb.min.y === bb.max.y && bb.min.z === bb.max.z, "since there is only one vertex, max and min are equal" );
				assert.ok( bb.min.x === - 1 && bb.min.y === - 1 && bb.min.z === - 1, "since there is only one vertex, min and max are this vertex" );

			} );

			QUnit.test( "computeBoundingSphere", ( assert ) => {

				var bs = getBSForVertices( [ - 10, 0, 0, 10, 0, 0 ] );

				assert.ok( bs.radius === ( 10 + 10 ) / 2, "radius is equal to deltaMinMax / 2" );
				assert.ok( bs.center.x === 0 && bs.center.y === 0 && bs.center.y === 0, "bounding sphere is at ( 0, 0, 0 )" );

				var bs = getBSForVertices( [ - 5, 11, - 3, 5, - 11, 3 ] );
				var radius = new Vector3( 5, 11, 3 ).length();

				assert.ok( bs.radius === radius, "radius is equal to directionLength" );
				assert.ok( bs.center.x === 0 && bs.center.y === 0 && bs.center.y === 0, "bounding sphere is at ( 0, 0, 0 )" );

			} );

			QUnit.todo( "computeFaceNormals", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "computeVertexNormals", ( assert ) => {

				// get normals for a counter clockwise created triangle
				var normals = getNormalsForVertices( [ - 1, 0, 0, 1, 0, 0, 0, 1, 0 ], assert );

				assert.ok( normals[ 0 ] === 0 && normals[ 1 ] === 0 && normals[ 2 ] === 1,
					"first normal is pointing to screen since the the triangle was created counter clockwise" );

				assert.ok( normals[ 3 ] === 0 && normals[ 4 ] === 0 && normals[ 5 ] === 1,
					"second normal is pointing to screen since the the triangle was created counter clockwise" );

				assert.ok( normals[ 6 ] === 0 && normals[ 7 ] === 0 && normals[ 8 ] === 1,
					"third normal is pointing to screen since the the triangle was created counter clockwise" );

				// get normals for a clockwise created triangle
				var normals = getNormalsForVertices( [ 1, 0, 0, - 1, 0, 0, 0, 1, 0 ], assert );

				assert.ok( normals[ 0 ] === 0 && normals[ 1 ] === 0 && normals[ 2 ] === - 1,
					"first normal is pointing to screen since the the triangle was created clockwise" );

				assert.ok( normals[ 3 ] === 0 && normals[ 4 ] === 0 && normals[ 5 ] === - 1,
					"second normal is pointing to screen since the the triangle was created clockwise" );

				assert.ok( normals[ 6 ] === 0 && normals[ 7 ] === 0 && normals[ 8 ] === - 1,
					"third normal is pointing to screen since the the triangle was created clockwise" );

				var normals = getNormalsForVertices( [ 0, 0, 1, 0, 0, - 1, 1, 1, 0 ], assert );

				// the triangle is rotated by 45 degrees to the right so the normals of the three vertices
				// should point to (1, -1, 0).normalized(). The simplest solution is to check against a normalized
				// vector (1, -1, 0) but you will get calculation errors because of floating calculations so another
				// valid technique is to create a vector which stands in 90 degrees to the normals and calculate the
				// dot product which is the cos of the angle between them. This should be < floating calculation error
				// which can be taken from Number.EPSILON
				var direction = new Vector3( 1, 1, 0 ).normalize(); // a vector which should have 90 degrees difference to normals
				var difference = direction.dot( new Vector3( normals[ 0 ], normals[ 1 ], normals[ 2 ] ) );
				assert.ok( difference < Number.EPSILON, "normal is equal to reference vector" );

				// get normals for a line should be NAN because you need min a triangle to calculate normals
				var normals = getNormalsForVertices( [ 1, 0, 0, - 1, 0, 0 ], assert );
				for ( var i = 0; i < normals.length; i ++ ) {

					assert.ok( ! normals[ i ], "normals can't be calculated which is good" );

				}

			} );
			QUnit.test( "computeVertexNormals (indexed)", ( assert ) => {

				var sqrt = 0.5 * Math.sqrt( 2 );
				var normal = new BufferAttribute( new Float32Array( [
					- 1, 0, 0, - 1, 0, 0, - 1, 0, 0,
					sqrt, sqrt, 0, sqrt, sqrt, 0, sqrt, sqrt, 0,
					- 1, 0, 0
				] ), 3 );
				var position = new BufferAttribute( new Float32Array( [
					0.5, 0.5, 0.5, 0.5, 0.5, - 0.5, 0.5, - 0.5, 0.5,
					0.5, - 0.5, - 0.5, - 0.5, 0.5, - 0.5, - 0.5, 0.5, 0.5,
					- 0.5, - 0.5, - 0.5
				] ), 3 );
				var index = new BufferAttribute( new Uint16Array( [
					0, 2, 1, 2, 3, 1, 4, 6, 5, 6, 7, 5
				] ), 1 );

				var a = new BufferGeometry();
				a.setAttribute( "position", position );
				a.computeVertexNormals();
				assert.ok(
					bufferAttributeEquals( normal, a.getAttribute( "normal" ) ),
					"Regular geometry: first computed normals are correct"
				);

				// a second time to see if the existing normals get properly deleted
				a.computeVertexNormals();
				assert.ok(
					bufferAttributeEquals( normal, a.getAttribute( "normal" ) ),
					"Regular geometry: second computed normals are correct"
				);

				// indexed geometry
				var a = new BufferGeometry();
				a.setAttribute( "position", position );
				a.setIndex( index );
				a.computeVertexNormals();
				assert.ok( bufferAttributeEquals( normal, a.getAttribute( "normal" ) ), "Indexed geometry: computed normals are correct" );

			} );

			QUnit.test( "merge", ( assert ) => {

				var geometry1 = new BufferGeometry();
				geometry1.setAttribute( "attrName", new BufferAttribute( new Float32Array( [ 1, 2, 3, 0, 0, 0 ] ), 3 ) );

				var geometry2 = new BufferGeometry();
				geometry2.setAttribute( "attrName", new BufferAttribute( new Float32Array( [ 4, 5, 6 ] ), 3 ) );

				var attr = geometry1.attributes.attrName.array;

				geometry1.merge( geometry2, 1 );

				// merged array should be 1, 2, 3, 4, 5, 6
				for ( var i = 0; i < attr.length; i ++ ) {

					assert.ok( attr[ i ] === i + 1, "" );

				}

				console.level = CONSOLE_LEVEL.ERROR;
				geometry1.merge( geometry2 );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( attr[ 0 ] === 4 && attr[ 1 ] === 5 && attr[ 2 ] === 6, "copied the 3 attributes without offset" );

			} );

			QUnit.todo( "normalizeNormals", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "toNonIndexed", ( assert ) => {

				var geometry = new BufferGeometry();
				var vertices = new Float32Array( [
					0.5, 0.5, 0.5, 0.5, 0.5, - 0.5, 0.5, - 0.5, 0.5, 0.5, - 0.5, - 0.5
				] );
				var index = new BufferAttribute( new Uint16Array( [ 0, 2, 1, 2, 3, 1 ] ) );
				var expected = new Float32Array( [
					0.5, 0.5, 0.5, 0.5, - 0.5, 0.5, 0.5, 0.5, - 0.5,
					0.5, - 0.5, 0.5, 0.5, - 0.5, - 0.5, 0.5, 0.5, - 0.5
				] );

				geometry.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );
				geometry.setIndex( index );

				var nonIndexed = geometry.toNonIndexed();

				assert.deepEqual( nonIndexed.getAttribute( "position" ).array, expected, "Expected vertices" );

			} );

			QUnit.test( "toJSON", ( assert ) => {

				var index = new BufferAttribute( new Uint16Array( [ 0, 1, 2, 3 ] ), 1 );
				var attribute1 = new BufferAttribute( new Uint16Array( [ 1, 3, 5, 7 ] ), 1 );
				attribute1.name = "attribute1";
				var a = new BufferGeometry();
				a.name = "JSONQUnit.test";
				// a.parameters = { "placeholder": 0 };
				a.setAttribute( "attribute1", attribute1 );
				a.setIndex( index );
				a.addGroup( 0, 1, 2 );
				a.boundingSphere = new Sphere( new Vector3( x, y, z ), 0.5 );
				var j = a.toJSON();
				var gold = {
					"metadata": {
						"version": 4.5,
						"type": "BufferGeometry",
						"generator": "BufferGeometry.toJSON"
					},
					"uuid": a.uuid,
					"type": "BufferGeometry",
					"name": "JSONQUnit.test",
					"data": {
						"attributes": {
							"attribute1": {
								"itemSize": 1,
								"type": "Uint16Array",
								"array": [ 1, 3, 5, 7 ],
								"normalized": false,
								"name": "attribute1"
							}
						},
						"index": {
							"type": "Uint16Array",
							"array": [ 0, 1, 2, 3 ]
						},
						"groups": [
							{
								"start": 0,
								"count": 1,
								"materialIndex": 2
							}
						],
						"boundingSphere": {
							"center": [ 2, 3, 4 ],
							"radius": 0.5
						}
					}
				};

				assert.deepEqual( j, gold, "Generated JSON is as expected" );

				// add morphAttributes
				a.morphAttributes.attribute1 = [];
				a.morphAttributes.attribute1.push( attribute1.clone() );
				j = a.toJSON();
				gold.data.morphAttributes = {
					"attribute1": [ {
						"itemSize": 1,
						"type": "Uint16Array",
						"array": [ 1, 3, 5, 7 ],
						"normalized": false,
						"name": "attribute1"
					} ]
				};
				gold.data.morphTargetsRelative = false;

				assert.deepEqual( j, gold, "Generated JSON with morphAttributes is as expected" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var a = new BufferGeometry();
				a.setAttribute( "attribute1", new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 ) );
				a.setAttribute( "attribute2", new BufferAttribute( new Float32Array( [ 0, 1, 3, 5, 6 ] ), 1 ) );
				a.addGroup( 0, 1, 2 );
				a.computeBoundingBox();
				a.computeBoundingSphere();
				a.setDrawRange( 0, 1 );
				var b = a.clone();

				assert.notEqual( a, b, "A new object was created" );
				assert.notEqual( a.id, b.id, "New object has a different GUID" );

				assert.strictEqual(
					Object.keys( a.attributes ).count, Object.keys( b.attributes ).count,
					"Both objects have the same amount of attributes"
				);
				assert.ok(
					bufferAttributeEquals( a.getAttribute( "attribute1" ), b.getAttribute( "attribute1" ) ),
					"First attributes buffer is identical"
				);
				assert.ok(
					bufferAttributeEquals( a.getAttribute( "attribute2" ), b.getAttribute( "attribute2" ) ),
					"Second attributes buffer is identical"
				);

				assert.deepEqual( a.groups, b.groups, "Groups are identical" );

				assert.ok( a.boundingBox.equals( b.boundingBox ), "BoundingBoxes are equal" );
				assert.ok( a.boundingSphere.equals( b.boundingSphere ), "BoundingSpheres are equal" );

				assert.strictEqual( a.drawRange.start, b.drawRange.start, "DrawRange start is identical" );
				assert.strictEqual( a.drawRange.count, b.drawRange.count, "DrawRange count is identical" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var geometry = new BufferGeometry();
				geometry.setAttribute( "attrName", new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 ) );
				geometry.setAttribute( "attrName2", new BufferAttribute( new Float32Array( [ 0, 1, 3, 5, 6 ] ), 1 ) );

				var copy = new BufferGeometry().copy( geometry );

				assert.ok( copy !== geometry && geometry.id !== copy.id, "new object was created" );

				Object.keys( geometry.attributes ).forEach( function ( key ) {

					var attribute = geometry.attributes[ key ];
					assert.ok( attribute !== undefined, "all attributes where copied" );

					for ( var i = 0; i < attribute.array.length; i ++ ) {

						assert.ok( attribute.array[ i ] === copy.attributes[ key ].array[ i ], "values of the attribute are equal" );

					}

				} );

			} );

			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'Clock', () => {

			function mockPerformance() {

				self.performance = {
					deltaTime: 0,

					next: function ( delta ) {

						this.deltaTime += delta;

					},

					now: function () {

						return this.deltaTime;

					}

				};

			}

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "start", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "stop", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getElapsedTime", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getDelta", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( "clock with performance", ( assert ) => {

				if ( typeof performance === 'undefined' ) {

					assert.expect( 0 );
					return;

				}

				mockPerformance();

				var clock = new Clock( false );

				clock.start();

				self.performance.next( 123 );
				assert.numEqual( clock.getElapsedTime(), 0.123, "okay" );

				self.performance.next( 100 );
				assert.numEqual( clock.getElapsedTime(), 0.223, "okay" );

				clock.stop();

				self.performance.next( 1000 );
				assert.numEqual( clock.getElapsedTime(), 0.223, "don't update time if the clock was stopped" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'EventDispatcher', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "addEventListener", ( assert ) => {

				var eventDispatcher = new EventDispatcher();

				var listener = {};
				eventDispatcher.addEventListener( 'anyType', listener );

				assert.ok( eventDispatcher._listeners.anyType.length === 1, "listener with unknown type was added" );
				assert.ok( eventDispatcher._listeners.anyType[ 0 ] === listener, "listener with unknown type was added" );

				eventDispatcher.addEventListener( 'anyType', listener );

				assert.ok( eventDispatcher._listeners.anyType.length === 1, "can't add one listener twice to same type" );
				assert.ok( eventDispatcher._listeners.anyType[ 0 ] === listener, "listener is still there" );

			} );

			QUnit.test( "hasEventListener", ( assert ) => {

				var eventDispatcher = new EventDispatcher();

				var listener = {};
				eventDispatcher.addEventListener( 'anyType', listener );

				assert.ok( eventDispatcher.hasEventListener( 'anyType', listener ), "listener was found" );
				assert.ok( ! eventDispatcher.hasEventListener( 'anotherType', listener ), "listener was not found which is good" );

			} );

			QUnit.test( "removeEventListener", ( assert ) => {

				var eventDispatcher = new EventDispatcher();

				var listener = {};

				assert.ok( eventDispatcher._listeners === undefined, "there are no listeners by default" );

				eventDispatcher.addEventListener( 'anyType', listener );
				assert.ok( Object.keys( eventDispatcher._listeners ).length === 1 &&
					eventDispatcher._listeners.anyType.length === 1, "if a listener was added, there is a new key" );

				eventDispatcher.removeEventListener( 'anyType', listener );
				assert.ok( eventDispatcher._listeners.anyType.length === 0, "listener was deleted" );

				eventDispatcher.removeEventListener( 'unknownType', listener );
				assert.ok( eventDispatcher._listeners.unknownType === undefined, "unknown types will be ignored" );

				eventDispatcher.removeEventListener( 'anyType', undefined );
				assert.ok( eventDispatcher._listeners.anyType.length === 0, "undefined listeners are ignored" );

			} );

			QUnit.test( "dispatchEvent", ( assert ) => {

				var eventDispatcher = new EventDispatcher();

				var callCount = 0;
				var listener = function () {

					callCount ++;

				};

				eventDispatcher.addEventListener( 'anyType', listener );
				assert.ok( callCount === 0, "no event, no call" );

				eventDispatcher.dispatchEvent( { type: 'anyType' } );
				assert.ok( callCount === 1, "one event, one call" );

				eventDispatcher.dispatchEvent( { type: 'anyType' } );
				assert.ok( callCount === 2, "two events, two calls" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'InstancedBufferAttribute', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var instance = new InstancedBufferAttribute( new Float32Array( 10 ), 2 );
				assert.ok( instance.meshPerAttribute === 1, "ok" );

				var instance = new InstancedBufferAttribute( new Float32Array( 10 ), 2, false, 123 );
				assert.ok( instance.meshPerAttribute === 123, "ok" );

			} );

			// PUBLIC STUFF
			QUnit.test( "copy", ( assert ) => {

				var array = new Float32Array( [ 1, 2, 3, 7, 8, 9 ] );
				var instance = new InstancedBufferAttribute( array, 2, true, 123 );
				var copiedInstance = instance.copy( instance );

				assert.ok( copiedInstance instanceof InstancedBufferAttribute, "the clone has the correct type" );
				assert.ok( copiedInstance.itemSize === 2, "itemSize was copied" );
				assert.ok( copiedInstance.normalized === true, "normalized was copied" );
				assert.ok( copiedInstance.meshPerAttribute === 123, "meshPerAttribute was copied" );

				for ( var i = 0; i < array.length; i ++ ) {

					assert.ok( copiedInstance.array[ i ] === array[ i ], "array was copied" );

				}

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'InstancedBufferGeometry', () => {

			function createClonableMock() {

				return {
					callCount: 0,
					clone: function () {

						this.callCount ++;
						return this;

					}
				};

			}

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "copy", ( assert ) => {

				var instanceMock1 = {};
				var instanceMock2 = {};
				var indexMock = createClonableMock();
				var defaultAttribute1 = new BufferAttribute( new Float32Array( [ 1 ] ) );
				var defaultAttribute2 = new BufferAttribute( new Float32Array( [ 2 ] ) );

				var instance = new InstancedBufferGeometry();

				instance.addGroup( 0, 10, instanceMock1 );
				instance.addGroup( 10, 5, instanceMock2 );
				instance.setIndex( indexMock );
				instance.setAttribute( 'defaultAttribute1', defaultAttribute1 );
				instance.setAttribute( 'defaultAttribute2', defaultAttribute2 );

				var copiedInstance = new InstancedBufferGeometry().copy( instance );

				assert.ok( copiedInstance instanceof InstancedBufferGeometry, "the clone has the correct type" );

				assert.equal( copiedInstance.index, indexMock, "index was copied" );
				assert.equal( copiedInstance.index.callCount, 1, "index.clone was called once" );

				assert.ok( copiedInstance.attributes[ 'defaultAttribute1' ] instanceof BufferAttribute, "attribute was created" );
				assert.deepEqual( copiedInstance.attributes[ 'defaultAttribute1' ].array, defaultAttribute1.array, "attribute was copied" );
				assert.deepEqual( copiedInstance.attributes[ 'defaultAttribute2' ].array, defaultAttribute2.array, "attribute was copied" );

				assert.equal( copiedInstance.groups[ 0 ].start, 0, "group was copied" );
				assert.equal( copiedInstance.groups[ 0 ].count, 10, "group was copied" );
				assert.equal( copiedInstance.groups[ 0 ].materialIndex, instanceMock1, "group was copied" );

				assert.equal( copiedInstance.groups[ 1 ].start, 10, "group was copied" );
				assert.equal( copiedInstance.groups[ 1 ].count, 5, "group was copied" );
				assert.equal( copiedInstance.groups[ 1 ].materialIndex, instanceMock2, "group was copied" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		clone: function ( data ) {

			const ib = InterleavedBuffer.prototype.clone.call( this, data );

			ib.meshPerAttribute = this.meshPerAttribute;

			return ib;

		},

		toJSON: function ( data ) {

			const json = InterleavedBuffer.prototype.toJSON.call( this, data );

			json.isInstancedInterleavedBuffer = true;
			json.meshPerAttribute = this.meshPerAttribute;

			return json;

		}

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'InstancedInterleavedBuffer', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var array = new Float32Array( [ 1, 2, 3, 7, 8, 9 ] );
				var instance = new InstancedInterleavedBuffer( array, 3 );

				assert.ok( instance.meshPerAttribute === 1, "ok" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isInstancedInterleavedBuffer", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var array = new Float32Array( [ 1, 2, 3, 7, 8, 9 ] );
				var instance = new InstancedInterleavedBuffer( array, 3 );
				var copiedInstance = instance.copy( instance );

				assert.ok( copiedInstance.meshPerAttribute === 1, "additional attribute was copied" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'InterleavedBuffer', () => {

			function checkInstanceAgainstCopy( instance, copiedInstance, assert ) {

				assert.ok( copiedInstance instanceof InterleavedBuffer, "the clone has the correct type" );

				for ( var i = 0; i < instance.array.length; i ++ ) {

					assert.ok( copiedInstance.array[ i ] === instance.array[ i ], "array was copied" );

				}

				assert.ok( copiedInstance.stride === instance.stride, "stride was copied" );
				assert.ok( copiedInstance.usage === DynamicDrawUsage, "usage was copied" );

			}

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.test( "needsUpdate", ( assert ) => {

				var a = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 4 ] ), 2 );

				a.needsUpdate = true;

				assert.strictEqual( a.version, 1, "Check version increased" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isInterleavedBuffer", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setUsage", ( assert ) => {

				var instance = new InterleavedBuffer();
				instance.setUsage( DynamicDrawUsage );

				assert.strictEqual( instance.usage, DynamicDrawUsage, "Usage was set" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var array = new Float32Array( [ 1, 2, 3, 7, 8, 9 ] );
				var instance = new InterleavedBuffer( array, 3 );
				instance.setUsage( DynamicDrawUsage );

				checkInstanceAgainstCopy( instance, instance.copy( instance ), assert );

			} );

			QUnit.test( "copyAt", ( assert ) => {

				var a = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ] ), 3 );
				var b = new InterleavedBuffer( new Float32Array( 9 ), 3 );
				var expected = new Float32Array( [ 4, 5, 6, 7, 8, 9, 1, 2, 3 ] );

				b.copyAt( 1, a, 2 );
				b.copyAt( 0, a, 1 );
				b.copyAt( 2, a, 0 );

				assert.deepEqual( b.array, expected, "Check the right values were replaced" );

			} );

			QUnit.test( "set", ( assert ) => {

				var instance = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 7, 8, 9 ] ), 3 );

				instance.set( [ 0, - 1 ] );
				assert.ok( instance.array[ 0 ] === 0 && instance.array[ 1 ] === - 1, "replace at first by default" );

			} );

			QUnit.test( "onUpload", ( assert ) => {

				var a = new InterleavedBuffer();
				var func = function () { };

				a.onUpload( func );

				assert.strictEqual( a.onUploadCallback, func, "Check callback was set properly" );

			} );

			// OTHERS
			QUnit.test( "count", ( assert ) => {

				var instance = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 7, 8, 9 ] ), 3 );

				assert.equal( instance.count, 2, "count is calculated via array length / stride" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'InterleavedBufferAttribute', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.test( "count", ( assert ) => {

				var buffer = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 7, 8, 9 ] ), 3 );
				var instance = new InterleavedBufferAttribute( buffer, 2, 0 );

				assert.ok( instance.count === 2, "count is calculated via array length / stride" );

			} );

			QUnit.todo( "array", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			// setY, setZ and setW are calculated in the same way so not QUnit.testing this
			// TODO: ( you can't be sure that will be the case in future, or a mistake was introduce in one off them ! )
			QUnit.test( "setX", ( assert ) => {

				var buffer = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 7, 8, 9 ] ), 3 );
				var instance = new InterleavedBufferAttribute( buffer, 2, 0 );

				instance.setX( 0, 123 );
				instance.setX( 1, 321 );

				assert.ok( instance.data.array[ 0 ] === 123 &&
					instance.data.array[ 3 ] === 321, "x was calculated correct based on index and default offset" );

				var buffer = new InterleavedBuffer( new Float32Array( [ 1, 2, 3, 7, 8, 9 ] ), 3 );
				var instance = new InterleavedBufferAttribute( buffer, 2, 1 );

				instance.setX( 0, 123 );
				instance.setX( 1, 321 );

				// the offset was defined as 1, so go one step futher in the array
				assert.ok( instance.data.array[ 1 ] === 123 &&
					instance.data.array[ 4 ] === 321, "x was calculated correct based on index and default offset" );

			} );

			QUnit.todo( "setY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setZ", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setW", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getX", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getZ", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getW", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setXY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setXYZ", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setXYZW", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'Layers', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Layers();

				a.set( 0 );
				assert.strictEqual( a.mask, 1, "Set channel 0" );

				a.set( 1 );
				assert.strictEqual( a.mask, 2, "Set channel 1" );

				a.set( 2 );
				assert.strictEqual( a.mask, 4, "Set channel 2" );

			} );

			QUnit.test( "enable", ( assert ) => {

				var a = new Layers();

				a.set( 0 );
				a.enable( 0 );
				assert.strictEqual( a.mask, 1, "Enable channel 0 with mask 0" );

				a.set( 0 );
				a.enable( 1 );
				assert.strictEqual( a.mask, 3, "Enable channel 1 with mask 0" );

				a.set( 1 );
				a.enable( 0 );
				assert.strictEqual( a.mask, 3, "Enable channel 0 with mask 1" );

				a.set( 1 );
				a.enable( 1 );
				assert.strictEqual( a.mask, 2, "Enable channel 1 with mask 1" );

			} );

			QUnit.test( "toggle", ( assert ) => {

				var a = new Layers();

				a.set( 0 );
				a.toggle( 0 );
				assert.strictEqual( a.mask, 0, "Toggle channel 0 with mask 0" );

				a.set( 0 );
				a.toggle( 1 );
				assert.strictEqual( a.mask, 3, "Toggle channel 1 with mask 0" );

				a.set( 1 );
				a.toggle( 0 );
				assert.strictEqual( a.mask, 3, "Toggle channel 0 with mask 1" );

				a.set( 1 );
				a.toggle( 1 );
				assert.strictEqual( a.mask, 0, "Toggle channel 1 with mask 1" );

			} );

			QUnit.test( "disable", ( assert ) => {

				var a = new Layers();

				a.set( 0 );
				a.disable( 0 );
				assert.strictEqual( a.mask, 0, "Disable channel 0 with mask 0" );

				a.set( 0 );
				a.disable( 1 );
				assert.strictEqual( a.mask, 1, "Disable channel 1 with mask 0" );

				a.set( 1 );
				a.disable( 0 );
				assert.strictEqual( a.mask, 2, "Disable channel 0 with mask 1" );

				a.set( 1 );
				a.disable( 1 );
				assert.strictEqual( a.mask, 0, "Disable channel 1 with mask 1" );

			} );

			QUnit.test( "test", ( assert ) => {

				var a = new Layers();
				var b = new Layers();

				assert.ok( a.test( b ), "Start out true" );

				a.set( 1 );
				assert.notOk( a.test( b ), "Set channel 1 in a and fail the QUnit.test" );

				b.toggle( 1 );
				assert.ok( a.test( b ), "Toggle channel 1 in b and pass again" );

			} );

		} );

	} );

	/* global QUnit */

	const matrixEquals4 = ( a, b ) => {

		for ( let i = 0; i < 16; i ++ ) {

			if ( Math.abs( a.elements[ i ] - b.elements[ i ] ) >= eps ) {

				return false;

			}

		}

		return true;

	};

	QUnit.module( 'Core', () => {

		QUnit.module( 'Object3D', () => {

			var RadToDeg = 180 / Math.PI;

			var eulerEquals = function ( a, b, tolerance ) {

				tolerance = tolerance || 0.0001;

				if ( a.order != b.order ) {

					return false;

				}

				return (
					Math.abs( a.x - b.x ) <= tolerance &&
					Math.abs( a.y - b.y ) <= tolerance &&
					Math.abs( a.z - b.z ) <= tolerance
				);

			};

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// STATIC STUFF
			QUnit.test( "DefaultUp", ( assert ) => {

				const currentDefaultUp = new Vector3().copy( Object3D.DefaultUp );
				const v = new Vector3();

				try {

					assert.deepEqual( Object3D.DefaultUp, v.set( 0, 1, 0 ), "default DefaultUp is Y-up" );

					const object = new Object3D();

					assert.deepEqual( object.up, v.set( 0, 1, 0 ), ".up of a new object inherits Object3D.DefaultUp = Y-up" );

					Object3D.DefaultUp.set( 0, 0, 1 );

					const object2 = new Object3D();

					assert.deepEqual( object2.up, v.set( 0, 0, 1 ), ".up of a new object inherits Object3D.DefaultUp = Z-up" );

				} finally {

					Object3D.DefaultUp.copy( currentDefaultUp );

				}

			} );

			QUnit.test( "DefaultMatrixAutoUpdate", ( assert ) => {

				const currentDefaultMatrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;

				try {

					assert.equal( currentDefaultMatrixAutoUpdate, true, "default DefaultMatrixAutoUpdate is true" );

					const object = new Object3D();

					assert.equal( object.matrixAutoUpdate, true, ".matrixAutoUpdate of a new object inherits Object3D.DefaultMatrixAutoUpdate = true" );

					Object3D.DefaultMatrixAutoUpdate = false;

					const object2 = new Object3D();

					assert.equal( object2.matrixAutoUpdate, false, ".matrixAutoUpdate of a new object inherits Object3D.DefaultMatrixAutoUpdate = false" );

				} finally {

					Object3D.DefaultMatrixAutoUpdate = currentDefaultMatrixAutoUpdate;

				}

			} );

			// PUBLIC STUFF
			QUnit.todo( "isObject3D", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onBeforeRender", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onAfterRender", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Object3D();
				var m = new Matrix4();
				var expectedPos = new Vector3( x, y, z );
				var expectedQuat = new Quaternion( 0.5 * Math.sqrt( 2 ), 0, 0, 0.5 * Math.sqrt( 2 ) );

				m.makeRotationX( Math.PI / 2 );
				m.setPosition( new Vector3( x, y, z ) );

				a.applyMatrix4( m );

				assert.deepEqual( a.position, expectedPos, "Position has the expected values" );
				assert.ok(
					Math.abs( a.quaternion.x - expectedQuat.x ) <= eps &&
					Math.abs( a.quaternion.y - expectedQuat.y ) <= eps &&
					Math.abs( a.quaternion.z - expectedQuat.z ) <= eps,
					"Quaternion has the expected values"
				);

			} );

			QUnit.test( "applyQuaternion", ( assert ) => {

				var a = new Object3D();
				var sqrt = 0.5 * Math.sqrt( 2 );
				var quat = new Quaternion( 0, sqrt, 0, sqrt );
				var expected = new Quaternion( sqrt / 2, sqrt / 2, 0, 0 );

				a.quaternion.set( 0.25, 0.25, 0.25, 0.25 );
				a.applyQuaternion( quat );

				assert.ok(
					Math.abs( a.quaternion.x - expected.x ) <= eps &&
					Math.abs( a.quaternion.y - expected.y ) <= eps &&
					Math.abs( a.quaternion.z - expected.z ) <= eps,
					"Quaternion has the expected values"
				);

			} );

			QUnit.test( "setRotationFromAxisAngle", ( assert ) => {

				var a = new Object3D();
				var axis = new Vector3( 0, 1, 0 );
				var angle = Math.PI;
				var expected = new Euler( - Math.PI, 0, - Math.PI );
				var euler = new Euler();

				a.setRotationFromAxisAngle( axis, angle );
				euler.setFromQuaternion( a.getWorldQuaternion( new Quaternion() ) );
				assert.ok( eulerEquals( euler, expected ), "Correct values after rotation" );

				axis.set( 1, 0, 0 );
				var angle = 0;
				expected.set( 0, 0, 0 );

				a.setRotationFromAxisAngle( axis, angle );
				euler.setFromQuaternion( a.getWorldQuaternion( new Quaternion() ) );
				assert.ok( eulerEquals( euler, expected ), "Correct values after zeroing" );

			} );

			QUnit.test( "setRotationFromEuler", ( assert ) => {

				var a = new Object3D();
				var rotation = new Euler( ( 45 / RadToDeg ), 0, Math.PI );
				var expected = rotation.clone(); // bit obvious
				var euler = new Euler();

				a.setRotationFromEuler( rotation );
				euler.setFromQuaternion( a.getWorldQuaternion( new Quaternion() ) );
				assert.ok( eulerEquals( euler, expected ), "Correct values after rotation" );

			} );

			QUnit.test( "setRotationFromMatrix", ( assert ) => {

				var a = new Object3D();
				var m = new Matrix4();
				var eye = new Vector3( 0, 0, 0 );
				var target = new Vector3( 0, 1, - 1 );
				var up = new Vector3( 0, 1, 0 );
				var euler = new Euler();

				m.lookAt( eye, target, up );
				a.setRotationFromMatrix( m );
				euler.setFromQuaternion( a.getWorldQuaternion( new Quaternion() ) );
				assert.numEqual( euler.x * RadToDeg, 45, "Correct rotation angle" );

			} );

			QUnit.test( "setRotationFromQuaternion", ( assert ) => {

				var a = new Object3D();
				var rotation = new Quaternion().setFromEuler( new Euler( Math.PI, 0, - Math.PI ) );
				var euler = new Euler();

				a.setRotationFromQuaternion( rotation );
				euler.setFromQuaternion( a.getWorldQuaternion( new Quaternion() ) );
				assert.ok( eulerEquals( euler, new Euler( Math.PI, 0, - Math.PI ) ), "Correct values after rotation" );

			} );

			QUnit.todo( "rotateOnAxis", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "rotateOnWorldAxis", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "rotateX", ( assert ) => {

				var obj = new Object3D();

				var angleInRad = 1.562;
				obj.rotateX( angleInRad );

				assert.numEqual( obj.rotation.x, angleInRad, "x is equal" );

			} );

			QUnit.test( "rotateY", ( assert ) => {

				var obj = new Object3D();

				var angleInRad = - 0.346;
				obj.rotateY( angleInRad );

				assert.numEqual( obj.rotation.y, angleInRad, "y is equal" );

			} );

			QUnit.test( "rotateZ", ( assert ) => {

				var obj = new Object3D();

				var angleInRad = 1;
				obj.rotateZ( angleInRad );

				assert.numEqual( obj.rotation.z, angleInRad, "z is equal" );

			} );

			QUnit.test( "translateOnAxis", ( assert ) => {

				var obj = new Object3D();

				obj.translateOnAxis( new Vector3( 1, 0, 0 ), 1 );
				obj.translateOnAxis( new Vector3( 0, 1, 0 ), 1.23 );
				obj.translateOnAxis( new Vector3( 0, 0, 1 ), - 4.56 );

				assert.propEqual( obj.position, {
					x: 1,
					y: 1.23,
					z: - 4.56
				} );

			} );

			QUnit.test( "translateX", ( assert ) => {

				var obj = new Object3D();
				obj.translateX( 1.234 );

				assert.numEqual( obj.position.x, 1.234, "x is equal" );

			} );

			QUnit.test( "translateY", ( assert ) => {

				var obj = new Object3D();
				obj.translateY( 1.234 );

				assert.numEqual( obj.position.y, 1.234, "y is equal" );

			} );

			QUnit.test( "translateZ", ( assert ) => {

				var obj = new Object3D();
				obj.translateZ( 1.234 );

				assert.numEqual( obj.position.z, 1.234, "z is equal" );

			} );

			QUnit.test( "localToWorld", ( assert ) => {

				const v = new Vector3();
				const expectedPosition = new Vector3( 5, - 1, - 4 );

				const parent = new Object3D();
				const child = new Object3D();

				parent.position.set( 1, 0, 0 );
				parent.rotation.set( 0, Math.PI / 2, 0 );
				parent.scale.set( 2, 1, 1 );

				child.position.set( 0, 1, 0 );
				child.rotation.set( Math.PI / 2, 0, 0 );
				child.scale.set( 1, 2, 1 );

				parent.add( child );
				parent.updateMatrixWorld();

				child.localToWorld( v.set( 2, 2, 2 ) );

				assert.ok(
					Math.abs( v.x - expectedPosition.x ) <= eps &&
					Math.abs( v.y - expectedPosition.y ) <= eps &&
					Math.abs( v.z - expectedPosition.z ) <= eps,
					"local vector is converted to world"
				);

			} );

			QUnit.test( "worldToLocal", ( assert ) => {

				const v = new Vector3();
				const expectedPosition = new Vector3( - 1, 0.5, - 1 );

				const parent = new Object3D();
				const child = new Object3D();

				parent.position.set( 1, 0, 0 );
				parent.rotation.set( 0, Math.PI / 2, 0 );
				parent.scale.set( 2, 1, 1 );

				child.position.set( 0, 1, 0 );
				child.rotation.set( Math.PI / 2, 0, 0 );
				child.scale.set( 1, 2, 1 );

				parent.add( child );
				parent.updateMatrixWorld();

				child.worldToLocal( v.set( 2, 2, 2 ) );

				assert.ok(
					Math.abs( v.x - expectedPosition.x ) <= eps &&
					Math.abs( v.y - expectedPosition.y ) <= eps &&
					Math.abs( v.z - expectedPosition.z ) <= eps,
					"world vector is converted to local"
				);

			} );

			QUnit.test( "lookAt", ( assert ) => {

				var obj = new Object3D();
				obj.lookAt( new Vector3( 0, - 1, 1 ) );

				assert.numEqual( obj.rotation.x * RadToDeg, 45, "x is equal" );

			} );

			QUnit.test( "add/remove/clear", ( assert ) => {

				var a = new Object3D();
				var child1 = new Object3D();
				var child2 = new Object3D();

				assert.strictEqual( a.children.length, 0, "Starts with no children" );

				a.add( child1 );
				assert.strictEqual( a.children.length, 1, "The first child was added" );
				assert.strictEqual( a.children[ 0 ], child1, "It's the right one" );

				a.add( child2 );
				assert.strictEqual( a.children.length, 2, "The second child was added" );
				assert.strictEqual( a.children[ 1 ], child2, "It's the right one" );
				assert.strictEqual( a.children[ 0 ], child1, "The first one is still there" );

				a.remove( child1 );
				assert.strictEqual( a.children.length, 1, "The first child was removed" );
				assert.strictEqual( a.children[ 0 ], child2, "The second one is still there" );

				a.add( child1 );
				a.remove( child1, child2 );
				assert.strictEqual( a.children.length, 0, "Both children were removed at once" );

				child1.add( child2 );
				assert.strictEqual( child1.children.length, 1, "The second child was added to the first one" );
				a.add( child2 );
				assert.strictEqual( a.children.length, 1, "The second one was added to the parent (no remove)" );
				assert.strictEqual( a.children[ 0 ], child2, "The second one is now the parent's child again" );
				assert.strictEqual( child1.children.length, 0, "The first one no longer has any children" );

				a.add( child1 );
				assert.strictEqual( a.children.length, 2, "The first child was added to the parent" );
				a.clear();
				assert.strictEqual( a.children.length, 0, "All childrens were removed" );
				assert.strictEqual( child1.parent, null, "First child has no parent" );
				assert.strictEqual( child2.parent, null, "Second child has no parent" );

			} );

			QUnit.test( "attach", ( assert ) => {

				const object = new Object3D();
				const oldParent = new Object3D();
				const newParent = new Object3D();
				const expectedMatrixWorld = new Matrix4();

				// Attach to a parent

				object.position.set( 1, 2, 3 );
				object.rotation.set( Math.PI / 2, Math.PI / 3, Math.PI / 4 );
				object.scale.set( 2, 3, 4 );
				newParent.position.set( 4, 5, 6 );
				newParent.rotation.set( Math.PI / 5, Math.PI / 6, Math.PI / 7 );
				newParent.scale.set( 5, 5, 5 );

				object.updateMatrixWorld();
				newParent.updateMatrixWorld();
				expectedMatrixWorld.copy( object.matrixWorld );

				newParent.attach( object );

				assert.ok( object.parent && object.parent == newParent &&
					oldParent.children.indexOf( object ) === - 1,
					"object is a child of a new parent" );

				assert.ok( matrixEquals4( expectedMatrixWorld, object.matrixWorld ), "object's world matrix is maintained" );

				// Attach to a new parent from an old parent

				object.position.set( 1, 2, 3 );
				object.rotation.set( Math.PI / 2, Math.PI / 3, Math.PI / 4 );
				object.scale.set( 2, 3, 4 );
				oldParent.position.set( 4, 5, 6 );
				oldParent.rotation.set( Math.PI / 5, Math.PI / 6, Math.PI / 7 );
				oldParent.scale.set( 5, 5, 5 );
				newParent.position.set( 7, 8, 9 );
				newParent.rotation.set( Math.PI / 8, Math.PI / 9, Math.PI / 10 );
				newParent.scale.set( 6, 6, 6 );

				oldParent.add( object );
				oldParent.updateMatrixWorld();
				newParent.updateMatrixWorld();
				expectedMatrixWorld.copy( object.matrixWorld );

				newParent.attach( object );

				assert.ok( object.parent && object.parent == newParent &&
					newParent.children.indexOf( object ) !== - 1 &&
					oldParent.children.indexOf( object ) === - 1,
					"object is no longer a child of an old parent and is a child of a new parent now" );

				assert.ok( matrixEquals4( expectedMatrixWorld, object.matrixWorld ),
					"object's world matrix is maintained even it had a parent" );

			} );

			QUnit.test( "getObjectById/getObjectByName/getObjectByProperty", ( assert ) => {

				var parent = new Object3D();
				var childName = new Object3D();
				var childId = new Object3D(); // id = parent.id + 2
				var childNothing = new Object3D();

				parent.prop = true;
				childName.name = "foo";
				parent.add( childName, childId, childNothing );

				assert.strictEqual( parent.getObjectByProperty( 'prop', true ), parent, "Get parent by its own property" );
				assert.strictEqual( parent.getObjectByName( "foo" ), childName, "Get child by name" );
				assert.strictEqual( parent.getObjectById( parent.id + 2 ), childId, "Get child by Id" );
				assert.strictEqual(
					parent.getObjectByProperty( 'no-property', 'no-value' ), undefined,
					"Unknown property results in undefined"
				);

			} );

			QUnit.test( "getWorldPosition", ( assert ) => {

				var a = new Object3D();
				var b = new Object3D();
				var expectedSingle = new Vector3( x, y, z );
				var expectedParent = new Vector3( x, y, 0 );
				var expectedChild = new Vector3( x, y, 7 + ( z - z ) );
				var position = new Vector3();

				a.translateX( x );
				a.translateY( y );
				a.translateZ( z );

				assert.deepEqual( a.getWorldPosition( position ), expectedSingle, "WorldPosition as expected for single object" );

				// translate child and then parent
				b.translateZ( 7 );
				a.add( b );
				a.translateZ( - z );

				assert.deepEqual( a.getWorldPosition( position ), expectedParent, "WorldPosition as expected for parent" );
				assert.deepEqual( b.getWorldPosition( position ), expectedChild, "WorldPosition as expected for child" );

			} );

			QUnit.todo( "getWorldQuaternion", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "getWorldScale", ( assert ) => {

				var a = new Object3D();
				var m = new Matrix4().makeScale( x, y, z );
				var expected = new Vector3( x, y, z );

				a.applyMatrix4( m );

				assert.deepEqual( a.getWorldScale( new Vector3() ), expected, "WorldScale as expected" );

			} );

			QUnit.test( "getWorldDirection", ( assert ) => {

				var a = new Object3D();
				var expected = new Vector3( 0, - 0.5 * Math.sqrt( 2 ), 0.5 * Math.sqrt( 2 ) );
				var direction = new Vector3();

				a.lookAt( new Vector3( 0, - 1, 1 ) );
				a.getWorldDirection( direction );

				assert.ok(
					Math.abs( direction.x - expected.x ) <= eps &&
					Math.abs( direction.y - expected.y ) <= eps &&
					Math.abs( direction.z - expected.z ) <= eps,
					"Direction has the expected values"
				);

			} );

			QUnit.test( "localTransformVariableInstantiation", ( assert ) => {

				var a = new Object3D();
				var b = new Object3D();
				var c = new Object3D();
				var d = new Object3D();

				a.getWorldDirection( new Vector3() );
				a.lookAt( new Vector3( 0, - 1, 1 ) );

				assert.ok( true, "Calling lookAt after getWorldDirection does not create errors" );

				b.getWorldPosition( new Vector3() );
				b.lookAt( new Vector3( 0, - 1, 1 ) );

				assert.ok( true, "Calling lookAt after getWorldPosition does not create errors" );

				c.getWorldQuaternion( new Quaternion() );
				c.lookAt( new Vector3( 0, - 1, 1 ) );

				assert.ok( true, "Calling lookAt after getWorldQuaternion does not create errors" );

				d.getWorldScale( new Vector3() );
				d.lookAt( new Vector3( 0, - 1, 1 ) );

				assert.ok( true, "Calling lookAt after getWorldScale does not create errors" );

			} );

			QUnit.todo( "raycast", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "traverse/traverseVisible/traverseAncestors", ( assert ) => {

				var a = new Object3D();
				var b = new Object3D();
				var c = new Object3D();
				var d = new Object3D();
				var names = [];
				var expectedNormal = [ "parent", "child", "childchild 1", "childchild 2" ];
				var expectedVisible = [ "parent", "child", "childchild 2" ];
				var expectedAncestors = [ "child", "parent" ];

				a.name = "parent";
				b.name = "child";
				c.name = "childchild 1";
				c.visible = false;
				d.name = "childchild 2";

				b.add( c );
				b.add( d );
				a.add( b );

				a.traverse( function ( obj ) {

					names.push( obj.name );

				} );
				assert.deepEqual( names, expectedNormal, "Traversed objects in expected order" );

				var names = [];
				a.traverseVisible( function ( obj ) {

					names.push( obj.name );

				} );
				assert.deepEqual( names, expectedVisible, "Traversed visible objects in expected order" );

				var names = [];
				c.traverseAncestors( function ( obj ) {

					names.push( obj.name );

				} );
				assert.deepEqual( names, expectedAncestors, "Traversed ancestors in expected order" );

			} );

			QUnit.test( "updateMatrix", ( assert ) => {

				const a = new Object3D();
				a.position.set( 2, 3, 4 );
				a.quaternion.set( 5, 6, 7, 8 );
				a.scale.set( 9, 10, 11 );

				assert.deepEqual( a.matrix.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "Updating position, quaternion, or scale has no effect to matrix until calling updateMatrix()" );

				a.updateMatrix();

				assert.deepEqual( a.matrix.elements, [
					-1521, 1548, -234, 0,
					-520, -1470, 1640, 0,
					1826, 44, -1331, 0,
					2, 3, 4, 1
				], "matrix is calculated from position, quaternion, and scale" );

				assert.equal( a.matrixWorldNeedsUpdate, true, "The flag indicating world matrix needs to be updated should be true" );

			} );

			QUnit.test( "updateMatrixWorld", ( assert ) => {

				const parent = new Object3D();
				const child = new Object3D();

				// -- Standard usage test

				parent.position.set( 1, 2, 3 );
				child.position.set( 4, 5, 6 );
				parent.add( child );

				parent.updateMatrixWorld();

				assert.deepEqual( parent.matrix.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					1, 2, 3, 1
				], "updateMatrixWorld() updates local matrix" );

				assert.deepEqual( parent.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					1, 2, 3, 1
				], "updateMatrixWorld() updates world matrix" );

				assert.deepEqual( child.matrix.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					4, 5, 6, 1
				], "updateMatrixWorld() updates children's local matrix" );

				assert.deepEqual( child.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					5, 7, 9, 1
				], "updateMatrixWorld() updates children's world matrices from their parent world matrix and their local matrices" );

				assert.equal( parent.matrixWorldNeedsUpdate || child.matrixWorldNeedsUpdate, false, "The flag indicating world matrix needs to be updated should be false after updating world matrix" );

				// -- No sync between local position/quaternion/scale/matrix and world matrix test

				parent.position.set( 0, 0, 0 );
				parent.updateMatrix();

				assert.deepEqual( parent.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					1, 2, 3, 1
				], "Updating position, quaternion, scale, or local matrix has no effect to world matrix until calling updateWorldMatrix()" );

				// -- matrixAutoUpdate = false test

				// Resetting local and world matrices to the origin
				child.position.set( 0, 0, 0 );
				parent.updateMatrixWorld();

				parent.position.set( 1, 2, 3 );
				parent.matrixAutoUpdate = false;
				child.matrixAutoUpdate = false;
				parent.updateMatrixWorld();

				assert.deepEqual( parent.matrix.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "updateMatrixWorld() doesn't update local matrix if matrixAutoUpdate is false" );

				assert.deepEqual( parent.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "World matrix isn't updated because local matrix isn't updated and the flag indicating world matrix needs to be updated didn't rise" );

				assert.deepEqual( child.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "No effect to child world matrix if parent local and world matrices and child local matrix are not updated" );

				// -- Propagation to children world matrices test

				parent.matrixAutoUpdate = true;
				parent.updateMatrixWorld();

				assert.deepEqual( child.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					1, 2, 3, 1
				], "Updating parent world matrix has effect to children world matrices even if children local matrices aren't changed" );

				// -- force argument test

				// Resetting the local and world matrices to the origin
				child.position.set( 0, 0, 0 );
				child.matrixAutoUpdate = true;
				parent.updateMatrixWorld();

				parent.position.set( 1, 2, 3 );
				parent.updateMatrix();
				parent.matrixAutoUpdate = false;
				parent.matrixWorldNeedsUpdate = false;

				parent.updateMatrixWorld( true );

				assert.deepEqual( parent.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					1, 2, 3, 1
				], "force = true forces to update world matrix even if local matrix is not changed" );

				// -- Restriction test: No effect to parent matrices

				// Resetting the local and world matrices to the origin
				parent.position.set( 0, 0, 0 );
				child.position.set( 0, 0, 0 );
				parent.matrixAutoUpdate = true;
				child.matrixAutoUpdate = true;
				parent.updateMatrixWorld();

				parent.position.set( 1, 2, 3 );
				child.position.set( 4, 5, 6 );

				child.updateMatrixWorld();

				assert.deepEqual( parent.matrix.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "updateMatrixWorld() doesn't update parent local matrix" );

				assert.deepEqual( parent.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
				], "updateMatrixWorld() doesn't update parent world matrix" );

				assert.deepEqual( child.matrixWorld.elements, [
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					4, 5, 6, 1
				], "updateMatrixWorld() calculates world matrix from the current parent world matrix" );

			} );

			QUnit.test( "updateWorldMatrix", ( assert ) => {

				const object = new Object3D();
				const parent = new Object3D();
				const child = new Object3D();

				const m = new Matrix4();
				const v = new Vector3();

				parent.add( object );
				object.add( child );

				parent.position.set( 1, 2, 3 );
				object.position.set( 4, 5, 6 );
				child.position.set( 7, 8, 9 );

				// Update the world matrix of an object

				object.updateWorldMatrix();

				assert.deepEqual( parent.matrix.elements,
					m.elements,
					"No effect to parents' local matrices" );

				assert.deepEqual( parent.matrixWorld.elements,
					m.elements,
					"No effect to parents' world matrices" );

				assert.deepEqual( object.matrix.elements,
					m.setPosition( object.position ).elements,
					"Object's local matrix is updated" );

				assert.deepEqual( object.matrixWorld.elements,
					m.setPosition( object.position ).elements,
					"Object's world matrix is updated" );

				assert.deepEqual( child.matrix.elements,
					m.identity().elements,
					"No effect to children's local matrices" );

				assert.deepEqual( child.matrixWorld.elements,
					m.elements,
					"No effect to children's world matrices" );

				// Update the world matrices of an object and its parents

				object.matrix.identity();
				object.matrixWorld.identity();

				object.updateWorldMatrix( true, false );

				assert.deepEqual( parent.matrix.elements,
					m.setPosition( parent.position ).elements,
					"Parents' local matrices are updated" );

				assert.deepEqual( parent.matrixWorld.elements,
					m.setPosition( parent.position ).elements,
					"Parents' world matrices are updated" );

				assert.deepEqual( object.matrix.elements,
					m.setPosition( object.position ).elements,
					"Object's local matrix is updated" );

				assert.deepEqual( object.matrixWorld.elements,
					m.setPosition( v.copy( parent.position ).add( object.position ) ).elements,
					"Object's world matrix is updated" );

				assert.deepEqual( child.matrix.elements,
					m.identity().elements,
					"No effect to children's local matrices" );

				assert.deepEqual( child.matrixWorld.elements,
					m.identity().elements,
					"No effect to children's world matrices" );

				// Update the world matrices of an object and its children

				parent.matrix.identity();
				parent.matrixWorld.identity();
				object.matrix.identity();
				object.matrixWorld.identity();

				object.updateWorldMatrix( false, true );

				assert.deepEqual( parent.matrix.elements,
					m.elements,
					"No effect to parents' local matrices" );

				assert.deepEqual( parent.matrixWorld.elements,
					m.elements,
					"No effect to parents' world matrices" );

				assert.deepEqual( object.matrix.elements,
					m.setPosition( object.position ).elements,
					"Object's local matrix is updated" );

				assert.deepEqual( object.matrixWorld.elements,
					m.setPosition( object.position ).elements,
					"Object's world matrix is updated" );

				assert.deepEqual( child.matrix.elements,
					m.setPosition( child.position ).elements,
					"Children's local matrices are updated" );

				assert.deepEqual( child.matrixWorld.elements,
					m.setPosition( v.copy( object.position ).add( child.position ) ).elements,
					"Children's world matrices are updated" );

				// Update the world matrices of an object and its parents and children

				object.matrix.identity();
				object.matrixWorld.identity();
				child.matrix.identity();
				child.matrixWorld.identity();

				object.updateWorldMatrix( true, true );

				assert.deepEqual( parent.matrix.elements,
					m.setPosition( parent.position ).elements,
					"Parents' local matrices are updated" );

				assert.deepEqual( parent.matrixWorld.elements,
					m.setPosition( parent.position ).elements,
					"Parents' world matrices are updated" );

				assert.deepEqual( object.matrix.elements,
					m.setPosition( object.position ).elements,
					"Object's local matrix is updated" );

				assert.deepEqual( object.matrixWorld.elements,
					m.setPosition( v.copy( parent.position ).add( object.position ) ).elements,
					"Object's world matrix is updated" );

				assert.deepEqual( child.matrix.elements,
					m.setPosition( child.position ).elements,
					"Children's local matrices are updated" );

				assert.deepEqual( child.matrixWorld.elements,
					m.setPosition( v.copy( parent.position ).add( object.position ).add( child.position ) ).elements,
					"Children's world matrices are updated" );

				// object.matrixAutoUpdate = false test

				object.matrix.identity();
				object.matrixWorld.identity();

				object.matrixAutoUpdate = false;
				object.updateWorldMatrix( true, false );

				assert.deepEqual( object.matrix.elements,
					m.identity().elements,
					"No effect to object's local matrix if matrixAutoUpdate is false" );

				assert.deepEqual( object.matrixWorld.elements,
					m.setPosition( parent.position ).elements,
					"object's world matrix is updated even if matrixAutoUpdate is false" );

			} );

			QUnit.test( "toJSON", ( assert ) => {

				var a = new Object3D();
				var child = new Object3D();
				var childChild = new Object3D();

				a.name = "a's name";
				a.matrix.set( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 );
				a.visible = false;
				a.castShadow = true;
				a.receiveShadow = true;
				a.userData[ "foo" ] = "bar";

				child.uuid = "5D4E9AE8-DA61-4912-A575-71A5BE3D72CD";
				childChild.uuid = "B43854B3-E970-4E85-BD41-AAF8D7BFA189";
				child.add( childChild );
				a.add( child );

				var gold = {
					"metadata": {
						"version": 4.5,
						"type": "Object",
						"generator": "Object3D.toJSON"
					},
					"object": {
						"uuid": "0A1E4F43-CB5B-4097-8F82-DC2969C0B8C2",
						"type": "Object3D",
						"name": "a's name",
						"castShadow": true,
						"receiveShadow": true,
						"visible": false,
						"userData": { "foo": "bar" },
						"layers": 1,
						"matrix": [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ],
						"children": [
							{
								"uuid": "5D4E9AE8-DA61-4912-A575-71A5BE3D72CD",
								"type": "Object3D",
								"layers": 1,
								"matrix": [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ],
								"children": [
									{
										"uuid": "B43854B3-E970-4E85-BD41-AAF8D7BFA189",
										"type": "Object3D",
										"layers": 1,
										"matrix": [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]
									}
								]
							}
						]
					}
				};

				// hacks
				var out = a.toJSON();
				out.object.uuid = "0A1E4F43-CB5B-4097-8F82-DC2969C0B8C2";

				assert.deepEqual( out, gold, "JSON is as expected" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var a;
				var b = new Object3D();

				assert.strictEqual( a, undefined, "Undefined pre-clone()" );

				a = b.clone();
				assert.notStrictEqual( a, b, "Defined but seperate instances post-clone()" );

				a.uuid = b.uuid;
				assert.deepEqual( a, b, "But identical properties" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Object3D();
				var b = new Object3D();
				var child = new Object3D();
				var childChild = new Object3D();

				a.name = "original";
				b.name = "to-be-copied";

				b.position.set( x, y, z );
				b.quaternion.set( x, y, z, w );
				b.scale.set( 2, 3, 4 );

				// bogus QUnit.test values
				b.matrix.set( 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 );
				b.matrixWorld.set( 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2 );

				b.matrixAutoUpdate = false;
				b.matrixWorldNeedsUpdate = true;

				b.layers.mask = 2;
				b.visible = false;

				b.castShadow = true;
				b.receiveShadow = true;

				b.frustumCulled = false;
				b.renderOrder = 1;

				b.userData[ "foo" ] = "bar";

				child.add( childChild );
				b.add( child );

				assert.notDeepEqual( a, b, "Objects are not equal pre-copy()" );
				a.copy( b, true );

				// check they're all unique instances
				assert.ok(
					a.uuid !== b.uuid &&
					a.children[ 0 ].uuid !== b.children[ 0 ].uuid &&
					a.children[ 0 ].children[ 0 ].uuid !== b.children[ 0 ].children[ 0 ].uuid,
					"UUIDs are all different"
				);

				// and now fix that
				a.uuid = b.uuid;
				a.children[ 0 ].uuid = b.children[ 0 ].uuid;
				a.children[ 0 ].children[ 0 ].uuid = b.children[ 0 ].children[ 0 ].uuid;

				assert.deepEqual( a, b, "Objects are equal post-copy()" );

			} );

		} );

	} );

	function Raycaster( origin, direction, near = 0, far = Infinity ) {

		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near;
		this.far = far;
		this.camera = null;
		this.layers = new Layers();

		this.params = {
			Mesh: {},
			Line: { threshold: 1 },
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {

					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;

				}
			}
		} );

	}

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.layers.test( raycaster.layers ) ) {

			object.raycast( raycaster, intersects );

		}

		if ( recursive === true ) {

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	Object.assign( Raycaster.prototype, {

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera && camera.isPerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
				this.camera = camera;

			} else if ( camera && camera.isOrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
				this.camera = camera;

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

			}

		},

		intersectObject: function ( object, recursive = false, intersects = [] ) {

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive = false, intersects = [] ) {

			for ( let i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	} );

	/* global QUnit */

	function checkRayDirectionAgainstReferenceVector( rayDirection, refVector, assert ) {

		assert.ok( refVector.x - rayDirection.x <= Number.EPSILON && refVector.y - rayDirection.y <= Number.EPSILON && refVector.z - rayDirection.z <= Number.EPSILON, "camera is pointing to" +
			" the same direction as expected" );

	}

	function getRaycaster() {

		return new Raycaster(
			new Vector3( 0, 0, 0 ),
			new Vector3( 0, 0, - 1 ),
			1,
			100
		);

	}

	function getObjectsToCheck() {

		var objects = [];

		var sphere1 = getSphere();
		sphere1.position.set( 0, 0, - 10 );
		sphere1.name = 1;
		objects.push( sphere1 );

		var sphere11 = getSphere();
		sphere11.position.set( 0, 0, 1 );
		sphere11.name = 11;
		sphere1.add( sphere11 );

		var sphere12 = getSphere();
		sphere12.position.set( 0, 0, - 1 );
		sphere12.name = 12;
		sphere1.add( sphere12 );

		var sphere2 = getSphere();
		sphere2.position.set( - 5, 0, - 5 );
		sphere2.name = 2;
		objects.push( sphere2 );

		for ( var i = 0; i < objects.length; i ++ ) {

			objects[ i ].updateMatrixWorld();

		}

		return objects;

	}

	function getSphere() {

		return new Mesh( new SphereGeometry( 1, 100, 100 ) );

	}

	QUnit.module( 'Core', () => {

		QUnit.module( 'Raycaster', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var origin = new Vector3( 0, 0, 0 );
				var direction = new Vector3( 0, 0, - 1 );
				var a = new Raycaster( origin.clone(), direction.clone() );

				assert.deepEqual( a.ray.origin, origin, "Origin is correct" );
				assert.deepEqual( a.ray.direction, direction, "Direction is correct" );

				origin.set( 1, 1, 1 );
				direction.set( - 1, 0, 0 );
				a.set( origin, direction );

				assert.deepEqual( a.ray.origin, origin, "Origin was set correctly" );
				assert.deepEqual( a.ray.direction, direction, "Direction was set correctly" );

			} );

			QUnit.test( "setFromCamera (Perspective)", ( assert ) => {

				var raycaster = new Raycaster();
				var rayDirection = raycaster.ray.direction;
				var camera = new PerspectiveCamera( 90, 1, 1, 1000 );

				raycaster.setFromCamera( {
					x: 0,
					y: 0
				}, camera );
				assert.ok( rayDirection.x === 0 && rayDirection.y === 0 && rayDirection.z === - 1,
					"camera is looking straight to -z and so does the ray in the middle of the screen" );

				var step = 0.1;

				for ( var x = - 1; x <= 1; x += step ) {

					for ( var y = - 1; y <= 1; y += step ) {

						raycaster.setFromCamera( {
							x,
							y
						}, camera );

						var refVector = new Vector3( x, y, - 1 ).normalize();

						checkRayDirectionAgainstReferenceVector( rayDirection, refVector, assert );

					}

				}

			} );

			QUnit.test( "setFromCamera (Orthographic)", ( assert ) => {

				var raycaster = new Raycaster();
				var rayOrigin = raycaster.ray.origin;
				var rayDirection = raycaster.ray.direction;
				var camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1000 );
				var expectedOrigin = new Vector3( 0, 0, 0 );
				var expectedDirection = new Vector3( 0, 0, - 1 );

				raycaster.setFromCamera( {
					x: 0,
					y: 0
				}, camera );
				assert.deepEqual( rayOrigin, expectedOrigin, "Ray origin has the right coordinates" );
				assert.deepEqual( rayDirection, expectedDirection, "Camera and Ray are pointing towards -z" );

			} );

			QUnit.test( "intersectObject", ( assert ) => {

				var raycaster = getRaycaster();
				var objectsToCheck = getObjectsToCheck();

				assert.ok( raycaster.intersectObject( objectsToCheck[ 0 ] ).length === 1,
					"no recursive search should lead to one hit" );

				assert.ok( raycaster.intersectObject( objectsToCheck[ 0 ], true ).length === 3,
					"recursive search should lead to three hits" );

				var intersections = raycaster.intersectObject( objectsToCheck[ 0 ], true );
				for ( var i = 0; i < intersections.length - 1; i ++ ) {

					assert.ok( intersections[ i ].distance <= intersections[ i + 1 ].distance, "intersections are sorted" );

				}

			} );

			QUnit.test( "intersectObjects", ( assert ) => {

				var raycaster = getRaycaster();
				var objectsToCheck = getObjectsToCheck();

				assert.ok( raycaster.intersectObjects( objectsToCheck ).length === 1,
					"no recursive search should lead to one hit" );

				assert.ok( raycaster.intersectObjects( objectsToCheck, true ).length === 3,
					"recursive search should lead to three hits" );

				var intersections = raycaster.intersectObjects( objectsToCheck, true );
				for ( var i = 0; i < intersections.length - 1; i ++ ) {

					assert.ok( intersections[ i ].distance <= intersections[ i + 1 ].distance, "intersections are sorted" );

				}

			} );

			QUnit.test( "Line intersection threshold", ( assert ) => {

				var raycaster = getRaycaster();
				var points = [ new Vector3( -2, -10, -5 ), new Vector3( -2, 10, -5 ) ];
				var geometry = new BufferGeometry().setFromPoints( points );
				var line = new Line( geometry, null );

				raycaster.params.Line.threshold = 1.999;
				assert.ok( raycaster.intersectObject( line ).length === 0,
					"no Line intersection with a not-large-enough threshold" );

				raycaster.params.Line.threshold = 2.001;
				assert.ok( raycaster.intersectObject( line ).length === 1,
					"successful Line intersection with a large-enough threshold" );

			} );

			QUnit.test( "Points intersection threshold", ( assert ) => {

				var raycaster = getRaycaster();
				var coordinates = [ new Vector3( -2, 0, -5 ) ];
				var geometry = new BufferGeometry().setFromPoints( coordinates );
				var points = new Points( geometry, null );

				raycaster.params.Points.threshold = 1.999;
				assert.ok( raycaster.intersectObject( points ).length === 0,
					"no Points intersection with a not-large-enough threshold" );

				raycaster.params.Points.threshold = 2.001;
				assert.ok( raycaster.intersectObject( points ).length === 1,
					"successful Points intersection with a large-enough threshold" );

			} );


		} );

	} );

	class Uniform {

		constructor( value ) {

			if ( typeof value === 'string' ) {

				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];

			}

			this.value = value;

		}

		clone() {

			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

		}

	}

	/* global QUnit */

	QUnit.module( 'Core', () => {

		QUnit.module( 'Uniform', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a;
				var b = new Vector3( x, y, z );

				a = new Uniform( 5 );
				assert.strictEqual( a.value, 5, "New constructor works with simple values" );

				a = new Uniform( b );
				assert.ok( a.value.equals( b ), "New constructor works with complex values" );

			} );

			// PUBLIC STUFF
			QUnit.test( "clone", ( assert ) => {

				var a = new Uniform( 23 );
				var b = a.clone();

				assert.strictEqual( b.value, a.value, "clone() with simple values works" );

				var a = new Uniform( new Vector3( 1, 2, 3 ) );
				var b = a.clone();

				assert.ok( b.value.equals( a.value ), "clone() with complex values works" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'ShapeUtils', () => {

			// PUBLIC STUFF
			QUnit.todo( "area", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "isClockWise", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "triangulateShape", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'Curve', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPointAt", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getSpacedPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getLength", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getLengths", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "updateArcLengths", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getUtoTmapping", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getTangent", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getTangentAt", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "computeFrenetFrames", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'CurvePath', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "add", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "closePath", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getLength", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "updateArcLengths", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getCurveLengths", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getSpacedPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "createPointsGeometry", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "createSpacedPointsGeometry", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "createGeometry", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'Font', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isFont", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "generateShapes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'Interpolations', () => {

				// PUBLIC STUFF
				QUnit.todo( "CatmullRom", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "QuadraticBezier", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "CubicBezier", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'Path', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "fromPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "moveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "lineTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "quadraticCurveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "bezierCurveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "splineThru", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "arc", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "absarc", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "ellipse", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "absellipse", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'Shape', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getPointsHoles", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "extractAllPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "extractPoints", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Core', () => {

			QUnit.module( 'ShapePath', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "moveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "lineTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "quadraticCurveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "bezierCurveTo", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "splineThru", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "toShapes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'ArcCurve', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isArcCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'CatmullRomCurve3', () => {

				/* eslint-disable */
				var positions = [
					new Vector3( - 60, - 100,   60 ),
					new Vector3( - 60,    20,   60 ),
					new Vector3( - 60,   120,   60 ),
					new Vector3(   60,    20, - 60 ),
					new Vector3(   60, - 100, - 60 )
				];
				/* eslint-enable */

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isCatmullRomCurve3", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "catmullrom check", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var expectedPoints = [

						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 60, - 51.04, 60 ),
						new Vector3( - 60, - 2.7199999999999998, 60 ),
						new Vector3( - 61.92, 44.48, 61.92 ),
						new Vector3( - 68.64, 95.36000000000001, 68.64 ),
						new Vector3( - 60, 120, 60 ),
						new Vector3( - 14.880000000000017, 95.36000000000001, 14.880000000000017 ),
						new Vector3( 41.75999999999997, 44.48000000000003, - 41.75999999999997 ),
						new Vector3( 67.68, - 2.720000000000023, - 67.68 ),
						new Vector3( 65.75999999999999, - 51.04000000000001, - 65.75999999999999 ),
						new Vector3( 60, - 100, - 60 )

					];

					var points = curve.getPoints( 10 );

					assert.equal( points.length, expectedPoints.length, 'correct number of points.' );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, 'points[' + i + '].x' );
						assert.numEqual( point.y, expectedPoints[ i ].y, 'points[' + i + '].y' );
						assert.numEqual( point.z, expectedPoints[ i ].z, 'points[' + i + '].z' );

					} );

				} );

				QUnit.test( "chordal basic check", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );

					curve.curveType = 'chordal';

					var expectedPoints = [
						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 60, - 52, 60 ),
						new Vector3( - 60, - 4, 60 ),
						new Vector3( - 60.656435889910924, 41.62455386421379, 60.656435889910924 ),
						new Vector3( - 62.95396150459915, 87.31049238896205, 62.95396150459915 ),
						new Vector3( - 60, 120, 60 ),
						new Vector3( - 16.302568199486444, 114.1500463116312, 16.302568199486444 ),
						new Vector3( 42.998098664956586, 54.017050116427455, - 42.998098664956586 ),
						new Vector3( 63.542500175682434, - 1.137153397546383, - 63.542500175682434 ),
						new Vector3( 62.65687513176183, - 49.85286504815978, - 62.65687513176183 ),
						new Vector3( 60.00000000000001, - 100, - 60.00000000000001 )
					];

					var points = curve.getPoints( 10 );

					assert.equal( points.length, expectedPoints.length, 'correct number of points.' );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, 'points[' + i + '].x' );
						assert.numEqual( point.y, expectedPoints[ i ].y, 'points[' + i + '].y' );
						assert.numEqual( point.z, expectedPoints[ i ].z, 'points[' + i + '].z' );

					} );

				} );

				QUnit.test( "centripetal basic check", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'centripetal';

					var expectedPoints = [
						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 60, - 51.47527724919028, 60 ),
						new Vector3( - 60, - 3.300369665587032, 60 ),
						new Vector3( - 61.13836565863938, 42.86306307781241, 61.13836565863938 ),
						new Vector3( - 65.1226454638772, 90.69743905511538, 65.1226454638772 ),
						new Vector3( - 60, 120, 60 ),
						new Vector3( - 15.620412575504497, 103.10790870179872, 15.620412575504497 ),
						new Vector3( 42.384384731047874, 48.35477686933143, - 42.384384731047874 ),
						new Vector3( 65.25545512241153, - 1.646250966068339, - 65.25545512241153 ),
						new Vector3( 63.94159134180865, - 50.234688224551256, - 63.94159134180865 ),
						new Vector3( 59.99999999999999, - 100, - 59.99999999999999 ),
					];

					var points = curve.getPoints( 10 );

					assert.equal( points.length, expectedPoints.length, 'correct number of points.' );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, 'points[' + i + '].x' );
						assert.numEqual( point.y, expectedPoints[ i ].y, 'points[' + i + '].y' );
						assert.numEqual( point.z, expectedPoints[ i ].z, 'points[' + i + '].z' );

					} );

				} );

				QUnit.test( "closed catmullrom basic check", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';
					curve.closed = true;

					var expectedPoints = [
						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 67.5, - 46.25, 67.5 ),
						new Vector3( - 60, 20, 60 ),
						new Vector3( - 67.5, 83.75, 67.5 ),
						new Vector3( - 60, 120, 60 ),
						new Vector3( 0, 83.75, 0 ),
						new Vector3( 60, 20, - 60 ),
						new Vector3( 75, - 46.25, - 75 ),
						new Vector3( 60, - 100, - 60 ),
						new Vector3( 0, - 115, 0 ),
						new Vector3( - 60, - 100, 60 ),
					];

					var points = curve.getPoints( 10 );

					assert.equal( points.length, expectedPoints.length, 'correct number of points.' );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, 'points[' + i + '].x' );
						assert.numEqual( point.y, expectedPoints[ i ].y, 'points[' + i + '].y' );
						assert.numEqual( point.z, expectedPoints[ i ].z, 'points[' + i + '].z' );

					} );

				} );

				//
				// curve.type = 'catmullrom'; only from here on
				//
				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var length = curve.getLength();
					var expectedLength = 551.549686276872;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0,
						120,
						220,
						416.9771560359221,
						536.9771560359221
					];
					var lengths = curve.getLengths( expectedLengths.length - 1 );

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var expectedPoints = [
						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 64.84177333183106, 64.86956465359813, 64.84177333183106 ),
						new Vector3( - 28.288507045700854, 104.83101184518996, 28.288507045700854 ),
						new Vector3( 60, - 100, - 60 )
					];

					var points = [
						curve.getPointAt( 0, new Vector3() ),
						curve.getPointAt( 0.3, new Vector3() ),
						curve.getPointAt( 0.5, new Vector3() ),
						curve.getPointAt( 1, new Vector3() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var expectedTangents = [
						new Vector3( 0, 1, 0 ),
						new Vector3( - 0.0001090274561657922, 0.9999999881130137, 0.0001090274561657922 ),
						new Vector3( 0.7071067811865475, - 2.0930381713877622e-13, - 0.7071067811865475 ),
						new Vector3( 0.43189437062802816, - 0.7917919583070032, - 0.43189437062802816 ),
						new Vector3( - 0.00019991333100812723, - 0.9999999600346592, 0.00019991333100812723 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector3() ),
						curve.getTangent( 0.25, new Vector3() ),
						curve.getTangent( 0.5, new Vector3() ),
						curve.getTangent( 0.75, new Vector3() ),
						curve.getTangent( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

					//

					expectedTangents = [
						new Vector3( 0, 1, 0 ),
						new Vector3( - 0.10709018822205997, 0.9884651653817284, 0.10709018822205997 ),
						new Vector3( 0.6396363672964268, - 0.4262987629159402, - 0.6396363672964268 ),
						new Vector3( 0.5077298411616501, - 0.6960034603275557, - 0.5077298411616501 ),
						new Vector3( - 0.00019991333100812723, - 0.9999999600346592, 0.00019991333100812723 )
					];

					tangents = [
						curve.getTangentAt( 0, new Vector3() ),
						curve.getTangentAt( 0.25, new Vector3() ),
						curve.getTangentAt( 0.5, new Vector3() ),
						curve.getTangentAt( 0.75, new Vector3() ),
						curve.getTangentAt( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangentAt #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangentAt #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "computeFrenetFrames", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var expected = {
						binormals: [
							new Vector3( - 1, 0, 0 ),
							new Vector3( - 0.28685061854203, 0.6396363672964267, - 0.7131493814579701 ),
							new Vector3( - 1.9982670528160395e-8, - 0.0001999133310081272, - 0.9999999800173295 )
						],
						normals: [
							new Vector3( 0, 0, - 1 ),
							new Vector3( - 0.7131493814579699, - 0.6396363672964268, - 0.2868506185420297 ),
							new Vector3( - 0.9999999800173294, 0.00019991333100810582, - 1.99826701852146e-8 )
						],
						tangents: [
							new Vector3( 0, 1, 0 ),
							new Vector3( 0.6396363672964269, - 0.4262987629159403, - 0.6396363672964269 ),
							new Vector3( - 0.0001999133310081273, - 0.9999999600346594, 0.0001999133310081273 )
						]
					};

					var frames = curve.computeFrenetFrames( 2, false );

					Object.keys( expected ).forEach( function ( group, i ) {

						expected[ group ].forEach( function ( vec, j ) {

							assert.numEqual( frames[ group ][ j ].x, vec.x, "Frenet frames [" + i + ", " + j + "].x correct" );
							assert.numEqual( frames[ group ][ j ].y, vec.y, "Frenet frames [" + i + ", " + j + "].y correct" );
							assert.numEqual( frames[ group ][ j ].z, vec.z, "Frenet frames [" + i + ", " + j + "].z correct" );

						} );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.5, 500 );

					var expectedSomewhere = 0.8964116382083199;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.5, 500 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = new CatmullRomCurve3( positions );
					curve.curveType = 'catmullrom';

					var expectedPoints = [
						new Vector3( - 60, - 100, 60 ),
						new Vector3( - 60, 10.311489426555056, 60 ),
						new Vector3( - 65.05889864636504, 117.99691802595966, 65.05889864636504 ),
						new Vector3( 6.054276900088592, 78.7153118386369, - 6.054276900088592 ),
						new Vector3( 64.9991491385602, 8.386980812799566, - 64.9991491385602 ),
						new Vector3( 60, - 100, - 60 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'CubicBezierCurve', ( hooks ) => {

				let curve = undefined;
				hooks.before( function () {

					curve = new CubicBezierCurve(
						new Vector2( - 10, 0 ),
						new Vector2( - 5, 15 ),
						new Vector2( 20, 15 ),
						new Vector2( 10, 0 )
					);

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isCubicBezierCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 3.359375, 8.4375 ),
						new Vector2( 5.625, 11.25 ),
						new Vector2( 11.796875, 8.4375 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

					// symmetry
					var curveRev = new CubicBezierCurve(
						curve.v3, curve.v2, curve.v1, curve.v0
					);

					var points = curveRev.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Reversed: Correct number of points" );
					assert.deepEqual( points, expectedPoints.reverse(), "Reversed: Correct points curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var length = curve.getLength();
					var expectedLength = 36.64630888504102;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0,
						10.737285813492393,
						20.15159143794633,
						26.93408340370825,
						35.56079575637337
					];
					var lengths = curve.getLengths( expectedLengths.length - 1 );

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 3.3188282598022596, 8.463722639089221 ),
						new Vector2( 3.4718554735926617, 11.07899406116314 ),
						new Vector2( 10, 0 )
					];

					var points = [
						curve.getPointAt( 0, new Vector2() ),
						curve.getPointAt( 0.3, new Vector2() ),
						curve.getPointAt( 0.5, new Vector2() ),
						curve.getPointAt( 1, new Vector2() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var expectedTangents = [
						new Vector2( 0.316370061632252, 0.9486358543207215 ),
						new Vector2( 0.838961283088303, 0.5441911111721949 ),
						new Vector2( 1, 0 ),
						new Vector2( 0.47628313192245453, - 0.8792919755383518 ),
						new Vector2( - 0.5546041767829665, - 0.8321142992972107 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector2() ),
						curve.getTangent( 0.25, new Vector2() ),
						curve.getTangent( 0.5, new Vector2() ),
						curve.getTangent( 0.75, new Vector2() ),
						curve.getTangent( 1, new Vector2() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

					//

					var expectedTangents = [
						new Vector2( 0.316370061632252, 0.9486358543207215 ),
						new Vector2( 0.7794223085548987, 0.6264988945935596 ),
						new Vector2( 0.988266153082452, 0.15274164681452052 ),
						new Vector2( 0.5004110404199416, - 0.8657879593906534 ),
						new Vector2( - 0.5546041767829665, - 0.8321142992972107 )
					];

					var tangents = [
						curve.getTangentAt( 0, new Vector2() ),
						curve.getTangentAt( 0.25, new Vector2() ),
						curve.getTangentAt( 0.5, new Vector2() ),
						curve.getTangentAt( 0.75, new Vector2() ),
						curve.getTangentAt( 1, new Vector2() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangentAt #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangentAt #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.5, 1 );

					var expectedSomewhere = 0.02130029182257093;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.5, 1 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 6.16826457740703, 6.17025727295411 ),
						new Vector2( - 0.058874033259857184, 10.1240558653185 ),
						new Vector2( 7.123523032625162, 11.154913869041575 ),
						new Vector2( 12.301846885754463, 6.808865855469985 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'CubicBezierCurve3', ( hooks ) => {

				let curve = undefined;
				hooks.before( function () {

					curve = new CubicBezierCurve3(
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 5, 15, 4 ),
						new Vector3( 20, 15, - 5 ),
						new Vector3( 10, 0, 10 )
					);

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isCubicBezierCurve3", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 3.359375, 8.4375, 1.984375 ),
						new Vector3( 5.625, 11.25, 1.125 ),
						new Vector3( 11.796875, 8.4375, 2.703125 ),
						new Vector3( 10, 0, 10 )
					];

					var points = curve.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

					// symmetry
					var curveRev = new CubicBezierCurve3(
						curve.v3, curve.v2, curve.v1, curve.v0
					);

					points = curveRev.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Reversed: Correct number of points" );
					assert.deepEqual( points, expectedPoints.reverse(), "Reversed: Correct points curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var length = curve.getLength();
					var expectedLength = 39.58103024989427;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0,
						10.73729718231036,
						20.19074500737662,
						27.154413277853756,
						38.453287150114214
					];
					var lengths = curve.getLengths( expectedLengths.length - 1 );

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 2.591880240484318, 8.908333501170798, 1.8953420625251136 ),
						new Vector3( 4.866251460832755, 11.22787914038507, 1.150832855206874 ),
						new Vector3( 10, 0, 10 )
					];

					var points = [
						curve.getPointAt( 0, new Vector3() ),
						curve.getPointAt( 0.3, new Vector3() ),
						curve.getPointAt( 0.5, new Vector3() ),
						curve.getPointAt( 1, new Vector3() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var expectedTangents = [
						new Vector3( 0.3138715439944244, 0.9411440474105875, 0.12542940601858074 ),
						new Vector3( 0.8351825262580098, 0.54174002562179, - 0.09480449605683638 ),
						new Vector3( 0.9997531780538501, 0, - 0.02221672728433752 ),
						new Vector3( 0.40693407933981185, - 0.7512629496079668, 0.5196235518317053 ),
						new Vector3( - 0.42632467075185815, - 0.6396469221230213, 0.6396085444448543 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector3() ),
						curve.getTangent( 0.25, new Vector3() ),
						curve.getTangent( 0.5, new Vector3() ),
						curve.getTangent( 0.75, new Vector3() ),
						curve.getTangent( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

					//

					expectedTangents = [
						new Vector3( 0.3138715439944244, 0.9411440474105875, 0.12542940601858074 ),
						new Vector3( 0.8016539573770751, 0.5918626760037707, - 0.08396133262002324 ),
						new Vector3( 0.997337559412928, 0.05740742907719314, - 0.044968652092444425 ),
						new Vector3( 0.1389373097746809, - 0.7882209938358005, 0.5995032016837588 ),
						new Vector3( - 0.42632467075185815, - 0.6396469221230213, 0.6396085444448543 )
					];

					tangents = [
						curve.getTangentAt( 0, new Vector3() ),
						curve.getTangentAt( 0.25, new Vector3() ),
						curve.getTangentAt( 0.5, new Vector3() ),
						curve.getTangentAt( 0.75, new Vector3() ),
						curve.getTangentAt( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangentAt #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangentAt #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.5, 1 );

					var expectedSomewhere = 0.021163245321323316;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.5, 1 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 5.756524515061918, 6.568020242700483, 2.22116711170301 ),
						new Vector3( 1.0003511895116906, 10.49656064587831, 1.4727101010850698 ),
						new Vector3( 8.767656412295171, 10.784286845278622, 1.2873599519775174 ),
						new Vector3( 12.306772513558396, 5.545103788071547, 4.909948454535794 ),
						new Vector3( 10, 0, 10 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

				QUnit.test( "computeFrenetFrames", ( assert ) => {

					var expected = {
						binormals: [
							new Vector3( - 0.9486358543207215, 0.316370061632252, - 6.938893903907228e-18 ),
							new Vector3( - 0.05491430765311864, 0.9969838307670049, 0.054842137122173326 ),
							new Vector3( 0.5944656510461876, 0.334836503700931, 0.7310917216844742 )
						],
						normals: [
							new Vector3( 0.03968210891259515, 0.11898683173537697, - 0.9921025471723304 ),
							new Vector3( - 0.047981365124836806, 0.05222670079466692, - 0.9974819097732357 ),
							new Vector3( 0.6818048583242511, - 0.6919077473246573, - 0.23749906180354932 )
						],
						tangents: [
							new Vector3( 0.3138715439944244, 0.9411440474105875, 0.12542940601858074 ),
							new Vector3( 0.9973375594129282, 0.05740742907719315, - 0.04496865209244443 ),
							new Vector3( - 0.42632467075185815, - 0.6396469221230213, 0.6396085444448543 )
						]
					};

					var frames = curve.computeFrenetFrames( 2, false );

					Object.keys( expected ).forEach( function ( group, i ) {

						expected[ group ].forEach( function ( vec, j ) {

							assert.numEqual( frames[ group ][ j ].x, vec.x, "Frenet frames [" + i + ", " + j + "].x correct" );
							assert.numEqual( frames[ group ][ j ].y, vec.y, "Frenet frames [" + i + ", " + j + "].y correct" );
							assert.numEqual( frames[ group ][ j ].z, vec.z, "Frenet frames [" + i + ", " + j + "].z correct" );

						} );

					} );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'EllipseCurve', ( hooks ) => {

				let curve = undefined;
				hooks.before( function () {

					curve = new EllipseCurve(
						0, 0, // ax, aY
						10, 10, // xRadius, yRadius
						0, 2 * Math.PI, // aStartAngle, aEndAngle
						false, // aClockwise
						0 // aRotation
					);

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isEllipseCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var expectedPoints = [
						new Vector2( 10, 0 ),
						new Vector2( 0, 10 ),
						new Vector2( - 10, 0 ),
						new Vector2( 0, - 10 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, "point[" + i + "].x correct" );
						assert.numEqual( point.y, expectedPoints[ i ].y, "point[" + i + "].y correct" );

					} );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var length = curve.getLength();
					var expectedLength = 62.829269247282795;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var lengths = curve.getLengths( 5 );
					var expectedLengths = [
						0,
						11.755705045849462,
						23.51141009169892,
						35.26711513754839,
						47.02282018339785,
						58.77852522924731
					];

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPoint/getPointAt", ( assert ) => {

					var testValues = [ 0, 0.3, 0.5, 0.7, 1 ];

					var p = new Vector2();
					var a = new Vector2();

					testValues.forEach( function ( val ) {

						var expectedX = Math.cos( val * Math.PI * 2 ) * 10;
						var expectedY = Math.sin( val * Math.PI * 2 ) * 10;

						curve.getPoint( val, p );
						curve.getPointAt( val, a );

						assert.numEqual( p.x, expectedX, "getPoint(" + val + ").x correct" );
						assert.numEqual( p.y, expectedY, "getPoint(" + val + ").y correct" );

						assert.numEqual( a.x, expectedX, "getPointAt(" + val + ").x correct" );
						assert.numEqual( a.y, expectedY, "getPointAt(" + val + ").y correct" );

					} );

				} );

				QUnit.test( "getTangent", ( assert ) => {

					var expectedTangents = [
						new Vector2( - 0.000314159260186071, 0.9999999506519786 ),
						new Vector2( - 1, 0 ),
						new Vector2( 0, - 1 ),
						new Vector2( 1, 0 ),
						new Vector2( 0.00031415926018600165, 0.9999999506519784 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector2() ),
						curve.getTangent( 0.25, new Vector2() ),
						curve.getTangent( 0.5, new Vector2() ),
						curve.getTangent( 0.75, new Vector2() ),
						curve.getTangent( 1, new Vector2() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.7, 1 );

					var expectedSomewhere = 0.01591614882650014;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.7, 1 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var expectedPoints = [
						new Vector2( 10, 0 ),
						new Vector2( 3.0901699437494603, 9.51056516295154 ),
						new Vector2( - 8.090169943749492, 5.877852522924707 ),
						new Vector2( - 8.090169943749459, - 5.877852522924751 ),
						new Vector2( 3.0901699437494807, - 9.510565162951533 ),
						new Vector2( 10, - 2.4492935982947065e-15 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );

					expectedPoints.forEach( function ( exp, i ) {

						var point = points[ i ];

						assert.numEqual( point.x, exp.x, "Point #" + i + ": x correct" );
						assert.numEqual( point.y, exp.y, "Point #" + i + ": y correct" );

					} );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'LineCurve', ( hooks ) => {

				let _points = undefined;
				let _curve = undefined;
				hooks.before( function () {

					_points = [
						new Vector2( 0, 0 ),
						new Vector2( 10, 10 ),
						new Vector2( - 10, 10 ),
						new Vector2( - 8, 5 )
					];

					_curve = new LineCurve( _points[ 0 ], _points[ 1 ] );

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isLineCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = new LineCurve( _points[ 0 ], _points[ 3 ] );

					var expectedPoints = [
						new Vector2( 0, 0 ),
						new Vector2( - 2.4, 1.5 ),
						new Vector2( - 4, 2.5 ),
						new Vector2( - 8, 5 )
					];

					var points = [
						curve.getPointAt( 0, new Vector2() ),
						curve.getPointAt( 0.3, new Vector2() ),
						curve.getPointAt( 0.5, new Vector2() ),
						curve.getPointAt( 1, new Vector2() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent", ( assert ) => {

					var curve = _curve;
					var tangent = new Vector2();

					curve.getTangent( 0, tangent );
					var expectedTangent = Math.sqrt( 0.5 );

					assert.numEqual( tangent.x, expectedTangent, "tangent.x correct" );
					assert.numEqual( tangent.y, expectedTangent, "tangent.y correct" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( 0, 0 ),
						new Vector2( 2, 2 ),
						new Vector2( 4, 4 ),
						new Vector2( 6, 6 ),
						new Vector2( 8, 8 ),
						new Vector2( 10, 10 )
					];

					var points = curve.getPoints();

					assert.deepEqual( points, expectedPoints, "Correct points for first curve" );

					//

					curve = new LineCurve( _points[ 1 ], _points[ 2 ] );

					expectedPoints = [
						new Vector2( 10, 10 ),
						new Vector2( 6, 10 ),
						new Vector2( 2, 10 ),
						new Vector2( - 2, 10 ),
						new Vector2( - 6, 10 ),
						new Vector2( - 10, 10 )
					];

					points = curve.getPoints();

					assert.deepEqual( points, expectedPoints, "Correct points for second curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = _curve;

					var length = curve.getLength();
					var expectedLength = Math.sqrt( 200 );

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var lengths = curve.getLengths( 5 );
					var expectedLengths = [
						0.0,
						Math.sqrt( 8 ),
						Math.sqrt( 32 ),
						Math.sqrt( 72 ),
						Math.sqrt( 128 ),
						Math.sqrt( 200 )
					];

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = _curve;

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.3, 0 );

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, 0.3, "getUtoTmapping( 0.3, 0 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( 0, 0 ),
						new Vector2( 2.5, 2.5 ),
						new Vector2( 5, 5 ),
						new Vector2( 7.5, 7.5 ),
						new Vector2( 10, 10 )
					];

					var points = curve.getSpacedPoints( 4 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'LineCurve3', ( hooks ) => {

				let _points = undefined;
				let _curve = undefined;
				hooks.before( function () {

					_points = [
						new Vector3( 0, 0, 0 ),
						new Vector3( 10, 10, 10 ),
						new Vector3( - 10, 10, - 10 ),
						new Vector3( - 8, 5, - 7 )
					];

					_curve = new LineCurve3( _points[ 0 ], _points[ 1 ] );

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isCatmullRomCurve3", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = new LineCurve3( _points[ 0 ], _points[ 3 ] );

					var expectedPoints = [
						new Vector3( 0, 0, 0 ),
						new Vector3( - 2.4, 1.5, - 2.1 ),
						new Vector3( - 4, 2.5, - 3.5 ),
						new Vector3( - 8, 5, - 7 )
					];

					var points = [
						curve.getPointAt( 0, new Vector3() ),
						curve.getPointAt( 0.3, new Vector3() ),
						curve.getPointAt( 0.5, new Vector3() ),
						curve.getPointAt( 1, new Vector3() )
					];

					assert.deepEqual( points, expectedPoints, "Correct getPointAt points" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector3( 0, 0, 0 ),
						new Vector3( 2, 2, 2 ),
						new Vector3( 4, 4, 4 ),
						new Vector3( 6, 6, 6 ),
						new Vector3( 8, 8, 8 ),
						new Vector3( 10, 10, 10 )
					];

					var points = curve.getPoints();

					assert.deepEqual( points, expectedPoints, "Correct points for first curve" );

					//

					curve = new LineCurve3( _points[ 1 ], _points[ 2 ] );

					expectedPoints = [
						new Vector3( 10, 10, 10 ),
						new Vector3( 6, 10, 6 ),
						new Vector3( 2, 10, 2 ),
						new Vector3( - 2, 10, - 2 ),
						new Vector3( - 6, 10, - 6 ),
						new Vector3( - 10, 10, - 10 )
					];

					points = curve.getPoints();

					assert.deepEqual( points, expectedPoints, "Correct points for second curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = _curve;

					var length = curve.getLength();
					var expectedLength = Math.sqrt( 300 );

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var lengths = curve.getLengths( 5 );
					var expectedLengths = [
						0.0,
						Math.sqrt( 12 ),
						Math.sqrt( 48 ),
						Math.sqrt( 108 ),
						Math.sqrt( 192 ),
						Math.sqrt( 300 )
					];

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var curve = _curve;
					var tangent = new Vector3();

					curve.getTangent( 0.5, tangent );
					var expectedTangent = Math.sqrt( 1 / 3 );

					assert.numEqual( tangent.x, expectedTangent, "tangent.x correct" );
					assert.numEqual( tangent.y, expectedTangent, "tangent.y correct" );
					assert.numEqual( tangent.z, expectedTangent, "tangent.z correct" );

					tangent = curve.getTangentAt( 0.5 );

					assert.numEqual( tangent.x, expectedTangent, "tangentAt.x correct" );
					assert.numEqual( tangent.y, expectedTangent, "tangentAt.y correct" );
					assert.numEqual( tangent.z, expectedTangent, "tangentAt.z correct" );

				} );

				QUnit.test( "computeFrenetFrames", ( assert ) => {

					var curve = _curve;

					var expected = {
						binormals: new Vector3( - 0.5 * Math.sqrt( 2 ), 0.5 * Math.sqrt( 2 ), 0 ),
						normals: new Vector3( Math.sqrt( 1 / 6 ), Math.sqrt( 1 / 6 ), - Math.sqrt( 2 / 3 ) ),
						tangents: new Vector3( Math.sqrt( 1 / 3 ), Math.sqrt( 1 / 3 ), Math.sqrt( 1 / 3 ) )
					};

					var frames = curve.computeFrenetFrames( 1, false );

					for ( var val in expected ) {

						assert.numEqual( frames[ val ][ 0 ].x, expected[ val ].x, "Frenet frames " + val + ".x correct" );
						assert.numEqual( frames[ val ][ 0 ].y, expected[ val ].y, "Frenet frames " + val + ".y correct" );
						assert.numEqual( frames[ val ][ 0 ].z, expected[ val ].z, "Frenet frames " + val + ".z correct" );

					}

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = _curve;

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.7, 0 );

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, 0.7, "getUtoTmapping( 0.7, 0 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector3( 0, 0, 0 ),
						new Vector3( 2.5, 2.5, 2.5 ),
						new Vector3( 5, 5, 5 ),
						new Vector3( 7.5, 7.5, 7.5 ),
						new Vector3( 10, 10, 10 )
					];

					var points = curve.getSpacedPoints( 4 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'QuadraticBezierCurve', ( hooks ) => {

				let _curve = undefined;
				hooks.before( function () {

					_curve = new QuadraticBezierCurve(
						new Vector2( - 10, 0 ),
						new Vector2( 20, 15 ),
						new Vector2( 10, 0 )
					);

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isQuadraticBezierCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( 2.5, 5.625 ),
						new Vector2( 10, 7.5 ),
						new Vector2( 12.5, 5.625 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

					// symmetry
					var curveRev = new QuadraticBezierCurve(
						curve.v2, curve.v1, curve.v0
					);

					points = curveRev.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Reversed: Correct number of points" );
					assert.deepEqual( points, expectedPoints.reverse(), "Reversed: Correct points curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = _curve;

					var length = curve.getLength();
					var expectedLength = 31.269026549416683;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0,
						13.707320124663317,
						21.43814317269643,
						24.56314317269643,
						30.718679298818998
					];
					var lengths = curve.getLengths( expectedLengths.length - 1 );

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 1.5127849599387615, 3.993582003773624 ),
						new Vector2( 4.310076165722796, 6.269921971403917 ),
						new Vector2( 10, 0 )
					];

					var points = [
						curve.getPointAt( 0, new Vector2() ),
						curve.getPointAt( 0.3, new Vector2() ),
						curve.getPointAt( 0.5, new Vector2() ),
						curve.getPointAt( 1, new Vector2() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var curve = _curve;

					var expectedTangents = [
						new Vector2( 0.89443315420562, 0.44720166888975904 ),
						new Vector2( 0.936329177569021, 0.3511234415884543 ),
						new Vector2( 1, 0 ),
						new Vector2( - 5.921189464667277e-13, - 1 ),
						new Vector2( - 0.5546617882904897, - 0.8320758983472577 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector2() ),
						curve.getTangent( 0.25, new Vector2() ),
						curve.getTangent( 0.5, new Vector2() ),
						curve.getTangent( 0.75, new Vector2() ),
						curve.getTangent( 1, new Vector2() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

					//

					expectedTangents = [
						new Vector2( 0.89443315420562, 0.44720166888975904 ),
						new Vector2( 0.9125211423360805, 0.40902954024086674 ),
						new Vector2( 0.9480289098765387, 0.3181842014278863 ),
						new Vector2( 0.7969127189169473, - 0.6040944615111106 ),
						new Vector2( - 0.5546617882904897, - 0.8320758983472577 )
					];

					tangents = [
						curve.getTangentAt( 0, new Vector2() ),
						curve.getTangentAt( 0.25, new Vector2() ),
						curve.getTangentAt( 0.5, new Vector2() ),
						curve.getTangentAt( 0.75, new Vector2() ),
						curve.getTangentAt( 1, new Vector2() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangentAt #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangentAt #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = _curve;

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.5, 1 );

					var expectedSomewhere = 0.015073978276116116;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.5, 1 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 4.366603655406173, 2.715408933540383 ),
						new Vector2( 1.3752241477827831, 5.191972084404416 ),
						new Vector2( 7.312990279153634, 7.136310044848586 ),
						new Vector2( 12.499856644824826, 5.653289188715387 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'QuadraticBezierCurve3', ( hooks ) => {

				let _curve = undefined;
				hooks.before( function () {

					_curve = new QuadraticBezierCurve3(
						new Vector3( - 10, 0, 2 ),
						new Vector3( 20, 15, - 5 ),
						new Vector3( 10, 0, 10 )
					);

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isQuadraticBezierCurve3", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( 2.5, 5.625, - 0.125 ),
						new Vector3( 10, 7.5, 0.5 ),
						new Vector3( 12.5, 5.625, 3.875 ),
						new Vector3( 10, 0, 10 )
					];

					var points = curve.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

					// symmetry
					var curveRev = new QuadraticBezierCurve3(
						curve.v2, curve.v1, curve.v0
					);

					points = curveRev.getPoints( expectedPoints.length - 1 );

					assert.strictEqual( points.length, expectedPoints.length, "Reversed: Correct number of points" );
					assert.deepEqual( points, expectedPoints.reverse(), "Reversed: Correct points curve" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = _curve;

					var length = curve.getLength();
					var expectedLength = 35.47294274967861;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0,
						13.871057998581074,
						21.62710402732536,
						26.226696400568883,
						34.91037361704809
					];
					var lengths = curve.getLengths( expectedLengths.length - 1 );

					assert.strictEqual( lengths.length, expectedLengths.length, "Correct number of segments" );

					lengths.forEach( function ( segment, i ) {

						assert.numEqual( segment, expectedLengths[ i ], "segment[" + i + "] correct" );

					} );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 0.4981634504454243, 4.427089043881476, 0.19308849757196012 ),
						new Vector3( 6.149415812887238, 6.838853310980195, - 0.20278120208668637 ),
						new Vector3( 10, 0, 10 )
					];

					var points = [
						curve.getPointAt( 0, new Vector3() ),
						curve.getPointAt( 0.3, new Vector3() ),
						curve.getPointAt( 0.5, new Vector3() ),
						curve.getPointAt( 1, new Vector3() )
					];

					assert.deepEqual( points, expectedPoints, "Correct points" );

				} );

				QUnit.test( "getTangent/getTangentAt", ( assert ) => {

					var curve = _curve;

					var expectedTangents = [
						new Vector3( 0.8755715084258769, 0.4377711603816079, - 0.2042815331129452 ),
						new Vector3( 0.9340289249885844, 0.3502608468707904, - 0.07005216937416067 ),
						new Vector3( 0.9284766908853163, 0, 0.37139067635396156 ),
						new Vector3( - 3.669031233375946e-13, - 0.6196442885791218, 0.7848827655333463 ),
						new Vector3( - 0.4263618889888853, - 0.6396068005601663, 0.6396238584473043 )
					];

					var tangents = [
						curve.getTangent( 0, new Vector3() ),
						curve.getTangent( 0.25, new Vector3() ),
						curve.getTangent( 0.5, new Vector3() ),
						curve.getTangent( 0.75, new Vector3() ),
						curve.getTangent( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangent #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangent #" + i + ": y correct" );

					} );

					//

					expectedTangents = [
						new Vector3( 0.8755715084258769, 0.4377711603816079, - 0.2042815331129452 ),
						new Vector3( 0.9060725703490549, 0.3984742932857448, - 0.14230507668907377 ),
						new Vector3( 0.9621604167456882, 0.2688562845452628, 0.044312872940942424 ),
						new Vector3( 0.016586454041780826, - 0.6163270940470614, 0.7873155674098058 ),
						new Vector3( - 0.4263618889888853, - 0.6396068005601663, 0.6396238584473043 )
					];

					tangents = [
						curve.getTangentAt( 0, new Vector3() ),
						curve.getTangentAt( 0.25, new Vector3() ),
						curve.getTangentAt( 0.5, new Vector3() ),
						curve.getTangentAt( 0.75, new Vector3() ),
						curve.getTangentAt( 1, new Vector3() )
					];

					expectedTangents.forEach( function ( exp, i ) {

						var tangent = tangents[ i ];

						assert.numEqual( tangent.x, exp.x, "getTangentAt #" + i + ": x correct" );
						assert.numEqual( tangent.y, exp.y, "getTangentAt #" + i + ": y correct" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = _curve;

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var somewhere = curve.getUtoTmapping( 0.5, 1 );

					var expectedSomewhere = 0.014760890927167196;

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( somewhere, expectedSomewhere, "getUtoTmapping( 0.5, 1 ) is correct" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector3( - 10, 0, 2 ),
						new Vector3( - 3.712652983516992, 3.015179001762753, 0.6957120710270492 ),
						new Vector3( 2.7830973773262975, 5.730399338061483, - 0.1452668772806931 ),
						new Vector3( 9.575825284074465, 7.48754187603603, 0.3461104039841496 ),
						new Vector3( 12.345199937734154, 4.575759904730531, 5.142117429101656 ),
						new Vector3( 10, 0, 10 )
					];

					var points = curve.getSpacedPoints();

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );
					assert.deepEqual( points, expectedPoints, "Correct points calculated" );

				} );

				QUnit.test( "computeFrenetFrames", ( assert ) => {

					var curve = _curve;

					var expected = {
						binormals: [
							new Vector3( - 0.447201668889759, 0.8944331542056199, 0 ),
							new Vector3( - 0.2684231751110917, 0.9631753839815436, - 0.01556209353802903 ),
							new Vector3( 0.3459273556592433, 0.53807011680075, 0.7686447905324219 )
						],
						normals: [
							new Vector3( - 0.18271617600817133, - 0.09135504253146765, - 0.9789121795283909 ),
							new Vector3( 0.046865035058597876, - 0.003078628350883253, - 0.9988964863970807 ),
							new Vector3( 0.8357929194629689, - 0.5489842348221077, 0.008155102228190641 )
						],
						tangents: [
							new Vector3( 0.8755715084258767, 0.4377711603816078, - 0.20428153311294514 ),
							new Vector3( 0.9621604167456884, 0.26885628454526284, 0.04431287294094243 ),
							new Vector3( - 0.4263618889888853, - 0.6396068005601663, 0.6396238584473043 )
						]
					};

					var frames = curve.computeFrenetFrames( 2, false );

					Object.keys( expected ).forEach( function ( group, i ) {

						expected[ group ].forEach( function ( vec, j ) {

							assert.numEqual( frames[ group ][ j ].x, vec.x, "Frenet frames [" + i + ", " + j + "].x correct" );
							assert.numEqual( frames[ group ][ j ].y, vec.y, "Frenet frames [" + i + ", " + j + "].y correct" );
							assert.numEqual( frames[ group ][ j ].z, vec.z, "Frenet frames [" + i + ", " + j + "].z correct" );

						} );

					} );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Curves', () => {

			QUnit.module( 'SplineCurve', ( hooks ) => {

				let _curve = undefined;
				hooks.before( function () {

					_curve = new SplineCurve( [
						new Vector2( - 10, 0 ),
						new Vector2( - 5, 5 ),
						new Vector2( 0, 0 ),
						new Vector2( 5, - 5 ),
						new Vector2( 10, 0 )
					] );

				} );

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isSplineCurve", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getPoint", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// OTHERS
				QUnit.test( "Simple curve", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 6.08, 4.56 ),
						new Vector2( - 2, 2.48 ),
						new Vector2( 2, - 2.48 ),
						new Vector2( 6.08, - 4.56 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getPoints( 5 );

					assert.strictEqual( points.length, expectedPoints.length, "1st: Correct number of points" );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, "points[" + i + "].x" );
						assert.numEqual( point.y, expectedPoints[ i ].y, "points[" + i + "].y" );

					} );

					//

					points = curve.getPoints( 4 );

					assert.deepEqual( points, curve.points, "2nd: Returned points are identical to control points" );

				} );

				QUnit.test( "getLength/getLengths", ( assert ) => {

					var curve = _curve;

					var length = curve.getLength();
					var expectedLength = 28.876950901868135;

					assert.numEqual( length, expectedLength, "Correct length of curve" );

					var expectedLengths = [
						0.0,
						Math.sqrt( 50 ),
						Math.sqrt( 200 ),
						Math.sqrt( 450 ),
						Math.sqrt( 800 )
					];

					var lengths = curve.getLengths( 4 );

					assert.deepEqual( lengths, expectedLengths, "Correct segment lengths" );

				} );

				QUnit.test( "getPointAt", ( assert ) => {

					var curve = _curve;
					var point = new Vector2();

					assert.ok( curve.getPointAt( 0, point ).equals( curve.points[ 0 ] ), "PointAt 0.0 correct" );
					assert.ok( curve.getPointAt( 1, point ).equals( curve.points[ 4 ] ), "PointAt 1.0 correct" );

					curve.getPointAt( 0.5, point );

					assert.numEqual( point.x, 0.0, "PointAt 0.5 x correct" );
					assert.numEqual( point.y, 0.0, "PointAt 0.5 y correct" );

				} );

				QUnit.test( "getTangent", ( assert ) => {

					var curve = _curve;

					var expectedTangent = [
						new Vector2( 0.7068243340243188, 0.7073891155729485 ), // 0
						new Vector2( 0.7069654305325396, - 0.7072481035902046 ), // 0.5
						new Vector2( 0.7068243340245123, 0.7073891155727552 ) // 1
					];

					var tangents = [
						curve.getTangent( 0, new Vector2() ),
						curve.getTangent( 0.5, new Vector2() ),
						curve.getTangent( 1, new Vector2() )
					];

					tangents.forEach( function ( tangent, i ) {

						assert.numEqual( tangent.x, expectedTangent[ i ].x, "tangent[" + i + "].x" );
						assert.numEqual( tangent.y, expectedTangent[ i ].y, "tangent[" + i + "].y" );

					} );

				} );

				QUnit.test( "getUtoTmapping", ( assert ) => {

					var curve = _curve;

					var start = curve.getUtoTmapping( 0, 0 );
					var end = curve.getUtoTmapping( 0, curve.getLength() );
					var middle = curve.getUtoTmapping( 0.5, 0 );

					assert.strictEqual( start, 0, "getUtoTmapping( 0, 0 ) is the starting point" );
					assert.strictEqual( end, 1, "getUtoTmapping( 0, length ) is the ending point" );
					assert.numEqual( middle, 0.5, "getUtoTmapping( 0.5, 0 ) is the middle" );

				} );

				QUnit.test( "getSpacedPoints", ( assert ) => {

					var curve = _curve;

					var expectedPoints = [
						new Vector2( - 10, 0 ),
						new Vector2( - 4.996509634683014, 4.999995128640857 ),
						new Vector2( 0, 0 ),
						new Vector2( 4.996509634683006, - 4.999995128640857 ),
						new Vector2( 10, 0 )
					];

					var points = curve.getSpacedPoints( 4 );

					assert.strictEqual( points.length, expectedPoints.length, "Correct number of points" );

					points.forEach( function ( point, i ) {

						assert.numEqual( point.x, expectedPoints[ i ].x, "points[" + i + "].x" );
						assert.numEqual( point.y, expectedPoints[ i ].y, "points[" + i + "].y" );

					} );

				} );

			} );

		} );

	} );

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

		this.hasPositions = false;
		this.hasNormals = false;
		this.hasColors = false;
		this.hasUvs = false;

		this.positionArray = null;
		this.normalArray = null;
		this.colorArray = null;
		this.uvArray = null;

		this.count = 0;

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	/* global QUnit */

	QUnit.module( 'Extras', () => {

		QUnit.module( 'Objects', () => {

			QUnit.module( 'ImmediateRenderObject', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "isImmediateRenderObject", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'BoxGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					width: 10,
					height: 20,
					depth: 30,
					widthSegments: 2,
					heightSegments: 3,
					depthSegments: 4
				};

				geometries = [
					new BoxGeometry(),
					new BoxGeometry( parameters.width, parameters.height, parameters.depth ),
					new BoxGeometry( parameters.width, parameters.height, parameters.depth, parameters.widthSegments, parameters.heightSegments, parameters.depthSegments ),
					new BoxGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'CircleGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					segments: 20,
					thetaStart: 0.1,
					thetaLength: 0.2
				};

				geometries = [
					new CircleGeometry(),
					new CircleGeometry( parameters.radius ),
					new CircleGeometry( parameters.radius, parameters.segments ),
					new CircleGeometry( parameters.radius, parameters.segments, parameters.thetaStart ),
					new CircleGeometry( parameters.radius, parameters.segments, parameters.thetaStart, parameters.thetaLength ),
						new CircleGeometry(),
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'ConeGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				geometries = [
					new ConeGeometry(),
					new ConeGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'CylinderGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radiusTop: 10,
					radiusBottom: 20,
					height: 30,
					radialSegments: 20,
					heightSegments: 30,
					openEnded: true,
					thetaStart: 0.1,
					thetaLength: 2.0,
				};

				geometries = [
					new CylinderGeometry(),
					new CylinderGeometry( parameters.radiusTop ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded, parameters.thetaStart ),
					new CylinderGeometry( parameters.radiusTop, parameters.radiusBottom, parameters.height, parameters.radialSegments, parameters.heightSegments, parameters.openEnded, parameters.thetaStart, parameters.thetaLength ),
					new CylinderGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'CircleBufferGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					detail: undefined
				};

				geometries = [
					new DodecahedronGeometry(),
					new DodecahedronGeometry( parameters.radius ),
					new DodecahedronGeometry( parameters.radius, parameters.detail ),
					new DodecahedronGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	function WebGLAnimation() {

		let context = null;
		let isAnimating = false;
		let animationLoop = null;
		let requestId = null;

		function onAnimationFrame( time, frame ) {

			animationLoop( time, frame );

			requestId = context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				requestId = context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				context.cancelAnimationFrame( requestId );

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	function WebGLAttributes( gl, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		const buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			const array = attribute.array;
			const usage = attribute.usage;

			const buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			let type = gl.FLOAT;

			if ( array instanceof Float32Array ) {

				type = gl.FLOAT;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				if ( attribute.isFloat16BufferAttribute ) {

					if ( isWebGL2 ) {

						type = gl.HALF_FLOAT;

					} else {

						console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

					}

				} else {

					type = gl.UNSIGNED_SHORT;

				}

			} else if ( array instanceof Int16Array ) {

				type = gl.SHORT;

			} else if ( array instanceof Uint32Array ) {

				type = gl.UNSIGNED_INT;

			} else if ( array instanceof Int32Array ) {

				type = gl.INT;

			} else if ( array instanceof Int8Array ) {

				type = gl.BYTE;

			} else if ( array instanceof Uint8Array ) {

				type = gl.UNSIGNED_BYTE;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			const array = attribute.array;
			const updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isGLBufferAttribute ) {

				const cached = buffers.get( attribute );

				if ( ! cached || cached.version < attribute.version ) {

					buffers.set( attribute, {
						buffer: attribute.buffer,
						type: attribute.type,
						bytesPerElement: attribute.elementSize,
						version: attribute.version
					} );

				}

				return;

			}

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			const data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	var alphamap_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vUv ).g;

#endif
`;

	var alphamap_pars_fragment = /* glsl */`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;

	var alphatest_fragment = /* glsl */`
#ifdef ALPHATEST

	if ( diffuseColor.a < ALPHATEST ) discard;

#endif
`;

	var aomap_fragment = /* glsl */`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );

	#endif

#endif
`;

	var aomap_pars_fragment = /* glsl */`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`;

	var begin_vertex = /* glsl */`
vec3 transformed = vec3( position );
`;

	var beginnormal_vertex = /* glsl */`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`;

	var bsdfs = /* glsl */`

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	return vec2( -1.04, 1.04 ) * a004 + r.zw;

}

float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

#if defined ( PHYSICALLY_CORRECT_LIGHTS )

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	// this is intended to be used on spot and point lights who are represented as luminous intensity
	// but who must be converted to luminous irradiance for surface lighting calculation
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

#else

	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {

		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );

	}

	return 1.0;

#endif

}

vec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotLH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );

	return ( 1.0 - specularColor ) * fresnel + specularColor;

} // validated

vec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {

	// See F_Schlick
	float fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );
	vec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;

	return Fr * fresnel + F0;

}


// Microfacet Models for Refraction through Rough Surfaces - equation (34)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {

	// geometry term (normalized) = G(l)G(v) / 4(nl)(nv)
	// also see #12151

	float a2 = pow2( alpha );

	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );

	return 1.0 / ( gl * gv );

} // validated

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	// dotNL and dotNV are explicitly swapped. This is not a mistake.
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility
vec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( incidentLight.direction + viewDir );

	float dotNL = saturate( dot( normal, incidentLight.direction ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );

	float D = D_GGX( alpha, dotNH );

	return F * ( G * D );

} // validated

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile
vec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );

	return specularColor * brdf.x + brdf.y;

} // validated

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
void BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {

	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );

	vec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );
	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
	vec3 FssEss = F * brdf.x + brdf.y;

	float Ess = brdf.x + brdf.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );

	//float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
	//float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
	float dotNH = saturate( dot( geometry.normal, halfDir ) );
	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );

	vec3 F = F_Schlick( specularColor, dotLH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html
float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
}

float BlinnExponentToGGXRoughness( const in float blinnExponent ) {
	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
}

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L94
float D_Charlie(float roughness, float NoH) {
	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / roughness;
	float cos2h = NoH * NoH;
	float sin2h = max(1.0 - cos2h, 0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16
	return (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);
}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs#L136
float V_Neubelt(float NoV, float NoL) {
	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));
}

vec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {

	vec3 N = geometry.normal;
	vec3 V = geometry.viewDir;

	vec3 H = normalize( V + L );
	float dotNH = saturate( dot( N, H ) );

	return specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );

}

#endif
`;

	var bumpmap_pars_fragment = /* glsl */`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );

		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;		// normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`;

	var clipping_planes_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

	}
	#pragma unroll_loop_end

	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

		bool clipped = true;

		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

		}
		#pragma unroll_loop_end

		if ( clipped ) discard;

	#endif

#endif
`;

	var clipping_planes_pars_fragment = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`;

	var clipping_planes_pars_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`;

	var clipping_planes_vertex = /* glsl */`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`;

	var color_fragment = /* glsl */`
#ifdef USE_COLOR

	diffuseColor.rgb *= vColor;

#endif
`;

	var color_pars_fragment = /* glsl */`
#ifdef USE_COLOR

	varying vec3 vColor;

#endif
`;

	var color_pars_vertex = /* glsl */`
#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	varying vec3 vColor;

#endif
`;

	var color_vertex = /* glsl */`
#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor.xyz *= color.xyz;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif
`;

	var common = /* glsl */`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement(a) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract(sin(sn) * c);
}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef CLEARCOAT
	vec3 clearcoatNormal;
#endif
};

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	float distance = dot( planeNormal, point - pointOnPlane );

	return - distance * planeNormal + point;

}

float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return sign( dot( point - pointOnPlane, planeNormal ) );

}

vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {

	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

// https://en.wikipedia.org/wiki/Relative_luminance
float linearToRelativeLuminance( const in vec3 color ) {

	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );

	return dot( weights, color.rgb );

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}
`;

	var cube_uv_reflection_fragment = /* glsl */`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );

		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );

		vec2 f = fract( uv );

		uv += 0.5 - f;

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		if ( mipInt < cubeUV_maxMipLevel ) {

			uv.y += 2.0 * cubeUV_maxTileSize;

		}

		uv.y += filterInt * 2.0 * cubeUV_minTileSize;

		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );

		uv *= texelSize;

		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x += texelSize;

		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.y += texelSize;

		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		uv.x -= texelSize;

		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;

		vec3 tm = mix( tl, tr, f.x );

		vec3 bm = mix( bl, br, f.x );

		return mix( tm, bm, f.y );

	}

	// These defines must match with PMREMGenerator

	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= r1 ) {

			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;

		} else if ( roughness >= r4 ) {

			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;

		} else if ( roughness >= r5 ) {

			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;

		} else if ( roughness >= r6 ) {

			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`;

	var defaultnormal_vertex = /* glsl */`
vec3 transformedNormal = objectNormal;

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 m = mat3( instanceMatrix );

	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );

	transformedNormal = m * transformedNormal;

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`;

	var displacementmap_pars_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`;

	var displacementmap_vertex = /* glsl */`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );

#endif
`;

	var emissivemap_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vUv );

	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`;

	var emissivemap_pars_fragment = /* glsl */`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`;

	var encodings_fragment = /* glsl */`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`;

	var encodings_pars_fragment = /* glsl */`
// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/

vec4 LinearToLinear( in vec4 value ) {
	return value;
}

vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}

vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}

vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}

vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}

vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
	// return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}

vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}

// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}

vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	// NOTE: The implementation with min causes the shader to not compile on
	// a common Alcatel A502DL in Chrome 78/Android 8.1. Some research suggests 
	// that the chipset is Mediatek MT6739 w/ IMG PowerVR GE8100 GPU.
	// D = min( floor( D ) / 255.0, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}

// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html

// M matrix, for encoding
const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );
vec4 LinearToLogLuv( in vec4 value ) {
	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;
	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );
	vec4 vResult;
	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;
	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;
	vResult.w = fract( Le );
	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;
	return vResult;
}

// Inverse M matrix, for decoding
const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );
vec4 LogLuvToLinear( in vec4 value ) {
	float Le = value.z * 255.0 + value.w;
	vec3 Xp_Y_XYZp;
	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );
	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;
	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;
	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;
	return vec4( max( vRGB, 0.0 ), 1.0 );
}
`;

	var envmap_fragment = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifndef ENVMAP_TYPE_CUBE_UV

		envColor = envMapTexelToLinear( envColor );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`;

	var envmap_common_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform int maxMipLevel;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`;

	var envmap_pars_fragment = /* glsl */`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`;

	var envmap_pars_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`;

	var envmap_vertex = /* glsl */`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`;

	var fog_vertex = /* glsl */`
#ifdef USE_FOG

	fogDepth = - mvPosition.z;

#endif
`;

	var fog_pars_vertex = /* glsl */`
#ifdef USE_FOG

	varying float fogDepth;

#endif
`;

	var fog_fragment = /* glsl */`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`;

	var fog_pars_fragment = /* glsl */`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float fogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`;

	var gradientmap_pars_fragment = /* glsl */`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return texture2D( gradientMap, coord ).rgb;

	#else

		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );

	#endif

}
`;

	var lightmap_fragment = /* glsl */`
#ifdef USE_LIGHTMAP

	vec4 lightMapTexel= texture2D( lightMap, vUv2 );
	reflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage

#endif
`;

	var lightmap_pars_fragment = /* glsl */`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`;

	var lights_lambert_vertex = /* glsl */`
vec3 diffuse = vec3( 1.0 );

GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );

GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;

vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif

IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;

vIndirectFront += getAmbientLightIrradiance( ambientLightColor );

vIndirectFront += getLightProbeIrradiance( lightProbe, geometry );

#ifdef DOUBLE_SIDED

	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );

	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );

#endif

#if NUM_POINT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_SPOT_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif
	}
	#pragma unroll_loop_end

#endif

/*
#if NUM_RECT_AREA_LIGHTS > 0

	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		// TODO (abelnation): implement

	}

#endif
*/

#if NUM_DIR_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );

		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = PI * directLight.color;

		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;

		#ifdef DOUBLE_SIDED

			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;

		#endif

	}
	#pragma unroll_loop_end

#endif

#if NUM_HEMI_LIGHTS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		#ifdef DOUBLE_SIDED

			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );

		#endif

	}
	#pragma unroll_loop_end

#endif
`;

	var lights_pars_begin = /* glsl */`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {

	vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI;

	#endif

	return irradiance;

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		directLight.color = directionalLight.color;
		directLight.direction = directionalLight.direction;
		directLight.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = pointLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );

		directLight.color = pointLight.color;
		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );
		directLight.visible = ( directLight.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// directLight is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {

		vec3 lVector = spotLight.position - geometry.position;
		directLight.direction = normalize( lVector );

		float lightDistance = length( lVector );
		float angleCos = dot( directLight.direction, spotLight.direction );

		if ( angleCos > spotLight.coneCos ) {

			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );

			directLight.color = spotLight.color;
			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );
			directLight.visible = true;

		} else {

			directLight.color = vec3( 0.0 );
			directLight.visible = false;

		}
	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {

		float dotNL = dot( geometry.normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			irradiance *= PI;

		#endif

		return irradiance;

	}

#endif
`;

	var envmap_physical_pars_fragment = /* glsl */`
#if defined( USE_ENVMAP )

	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif

	vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {

		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );

			// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level
			// of a specular cubemap, or just the default level of a specially created irradiance cubemap.

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );

			#else

				// force the bias high to get the last LOD level as it is the most blurred.
				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );

		#else

			vec4 envMapColor = vec4( 0.0 );

		#endif

		return PI * envMapColor.rgb * envMapIntensity;

	}

	// Trowbridge-Reitz distribution to Mip level, following the logic of http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html
	float getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {

		float maxMIPLevelScalar = float( maxMIPLevel );

		float sigma = PI * roughness * roughness / ( 1.0 + roughness );
		float desiredMIPLevel = maxMIPLevelScalar + log2( sigma );

		// clamp to allowable LOD ranges.
		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );

	}

	vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( -viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

		#else

			vec3 reflectVec = refract( -viewDir, normal, refractionRatio );

		#endif

		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

		float specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );

		#ifdef ENVMAP_TYPE_CUBE

			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );

			#ifdef TEXTURE_LOD_EXT

				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );

			#else

				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );

			#endif

			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;

		#elif defined( ENVMAP_TYPE_CUBE_UV )

			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );

		#endif

		return envMapColor.rgb * envMapIntensity;

	}

#endif
`;

	var lights_toon_fragment = /* glsl */`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`;

	var lights_toon_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon

#define Material_LightProbeLOD( material )	(0)
`;

	var lights_phong_fragment = /* glsl */`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`;

	var lights_phong_pars_fragment = /* glsl */`
varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif


struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong

#define Material_LightProbeLOD( material )	(0)
`;

	var lights_physical_fragment = /* glsl */`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.specularRoughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.specularRoughness += geometryRoughness;
material.specularRoughness = min( material.specularRoughness, 1.0 );

#ifdef REFLECTIVITY

	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

#endif

#ifdef CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheen;

#endif
`;

	var lights_physical_pars_fragment = /* glsl */`
struct PhysicalMaterial {

	vec3 diffuseColor;
	float specularRoughness;
	vec3 specularColor;

#ifdef CLEARCOAT
	float clearcoat;
	float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	vec3 sheenColor;
#endif

};

#define MAXIMUM_SPECULAR_COEFFICIENT 0.16
#define DEFAULT_SPECULAR_COEFFICIENT 0.04

// Clear coat directional hemishperical reflectance (this approximation should be improved)
float clearcoatDHRApprox( const in float roughness, const in float dotNL ) {

	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.specularRoughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifndef PHYSICALLY_CORRECT_LIGHTS

		irradiance *= PI; // punctual light

	#endif

	#ifdef CLEARCOAT

		float ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = ccDotNL * directLight.color;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			ccIrradiance *= PI; // punctual light

		#endif

		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

		reflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

	#else

		float clearcoatDHR = 0.0;

	#endif

	#ifdef USE_SHEEN
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(
			material.specularRoughness,
			directLight.direction,
			geometry,
			material.sheenColor
		);
	#else
		reflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);
	#endif

	reflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef CLEARCOAT

		float ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );

		reflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );

		float ccDotNL = ccDotNV;
		float clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );

	#else

		float clearcoatDHR = 0.0;

	#endif

	float clearcoatInv = 1.0 - clearcoatDHR;

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );

	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );

	reflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`;

	var lights_fragment_begin = /* glsl */`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

GeometricContext geometry;

geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

#ifdef CLEARCOAT

	geometry.clearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointDirectLightIrradiance( pointLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotDirectLightIrradiance( spotLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	irradiance += getLightProbeIrradiance( lightProbe, geometry );

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`;

	var lights_fragment_maps = /* glsl */`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

		#ifndef PHYSICALLY_CORRECT_LIGHTS

			lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage

		#endif

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );

	#ifdef CLEARCOAT

		clearcoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );

	#endif

#endif
`;

	var lights_fragment_end = /* glsl */`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );

#endif
`;

	var logdepthbuf_fragment = /* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`;

	var logdepthbuf_pars_fragment = /* glsl */`
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`;

	var logdepthbuf_pars_vertex = /* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`;

	var logdepthbuf_vertex = /* glsl */`
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

	#else

		if ( isPerspectiveMatrix( projectionMatrix ) ) {

			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;

			gl_Position.z *= gl_Position.w;

		}

	#endif

#endif
`;

	var map_fragment = /* glsl */`
#ifdef USE_MAP

	vec4 texelColor = texture2D( map, vUv );

	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;

#endif
`;

	var map_pars_fragment = /* glsl */`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`;

	var map_particle_fragment = /* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

#endif

#ifdef USE_MAP

	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`;

	var map_particle_pars_fragment = /* glsl */`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	uniform mat3 uvTransform;

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`;

	var metalnessmap_fragment = /* glsl */`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`;

	var metalnessmap_pars_fragment = /* glsl */`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`;

	var morphnormal_vertex = /* glsl */`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;
	objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
	objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
	objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
	objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];

#endif
`;

	var morphtarget_pars_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	uniform float morphTargetBaseInfluence;

	#ifndef USE_MORPHNORMALS

		uniform float morphTargetInfluences[ 8 ];

	#else

		uniform float morphTargetInfluences[ 4 ];

	#endif

#endif
`;

	var morphtarget_vertex = /* glsl */`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;
	transformed += morphTarget0 * morphTargetInfluences[ 0 ];
	transformed += morphTarget1 * morphTargetInfluences[ 1 ];
	transformed += morphTarget2 * morphTargetInfluences[ 2 ];
	transformed += morphTarget3 * morphTargetInfluences[ 3 ];

	#ifndef USE_MORPHNORMALS

		transformed += morphTarget4 * morphTargetInfluences[ 4 ];
		transformed += morphTarget5 * morphTargetInfluences[ 5 ];
		transformed += morphTarget6 * morphTargetInfluences[ 6 ];
		transformed += morphTarget7 * morphTargetInfluences[ 7 ];

	#endif

#endif
`;

	var normal_fragment_begin = /* glsl */`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	// Workaround for Adreno GPUs not able to do dFdx( vViewPosition )

	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	#ifdef USE_TANGENT

		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );

		#ifdef DOUBLE_SIDED

			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;

		#endif

		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

			mat3 vTBN = mat3( tangent, bitangent, normal );

		#endif

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 geometryNormal = normal;

`;

	var normal_fragment_maps = /* glsl */`

#ifdef OBJECTSPACE_NORMALMAP

	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( TANGENTSPACE_NORMALMAP )

	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	#ifdef USE_TANGENT

		normal = normalize( vTBN * mapN );

	#else

		normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );

	#endif

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`;

	var normalmap_pars_fragment = /* glsl */`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef OBJECTSPACE_NORMALMAP

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

		// Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988

		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

	}

#endif
`;

	var clearcoat_normal_fragment_begin = /* glsl */`
#ifdef CLEARCOAT

	vec3 clearcoatNormal = geometryNormal;

#endif
`;

	var clearcoat_normal_fragment_maps = /* glsl */`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	#ifdef USE_TANGENT

		clearcoatNormal = normalize( vTBN * clearcoatMapN );

	#else

		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );

	#endif

#endif
`;

	var clearcoat_pars_fragment = /* glsl */`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif
`;

	var packing = /* glsl */`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)

const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );

const float ShiftRight8 = 1. / 256.;

vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8; // tidy overflow
	return r * PackUpscale;
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}

vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}
`;

	var premultiplied_alpha_fragment = /* glsl */`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`;

	var project_vertex = /* glsl */`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`;

	var dithering_fragment = /* glsl */`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`;

	var dithering_pars_fragment = /* glsl */`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift acording to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`;

	var roughnessmap_fragment = /* glsl */`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`;

	var roughnessmap_pars_fragment = /* glsl */`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`;

	var shadowmap_pars_fragment = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		// if ( something && something ) breaks ATI OpenGL shader compiler
		// if ( all( something, something ) ) using this instead

		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );

		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

		bool frustumTest = all( frustumTestVec );

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`;

	var shadowmap_pars_vertex = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`;

	var shadowmap_vertex = /* glsl */`
#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0

		// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;

	#endif

	#if NUM_DIR_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif
`;

	var shadowmask_pars_fragment = /* glsl */`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`;

	var skinbase_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`;

	var skinning_pars_vertex = /* glsl */`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[ MAX_BONES ];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif
`;

	var skinning_vertex = /* glsl */`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`;

	var skinnormal_vertex = /* glsl */`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`;

	var specularmap_fragment = /* glsl */`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`;

	var specularmap_pars_fragment = /* glsl */`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`;

	var tonemapping_fragment = /* glsl */`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`;

	var tonemapping_pars_fragment = /* glsl */`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate(a) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return toneMappingExposure * color;

}

// source: https://www.cs.utah.edu/~reinhard/cdrom/
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 OptimizedCineonToneMapping( vec3 color ) {

	// optimized filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`;

	var transmissionmap_fragment = /* glsl */`
#ifdef USE_TRANSMISSIONMAP

	totalTransmission *= texture2D( transmissionMap, vUv ).r;

#endif
`;

	var transmissionmap_pars_fragment = /* glsl */`
#ifdef USE_TRANSMISSIONMAP

	uniform sampler2D transmissionMap;

#endif
`;

	var uv_pars_fragment = /* glsl */`
#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )

	varying vec2 vUv;

#endif
`;

	var uv_pars_vertex = /* glsl */`
#ifdef USE_UV

	#ifdef UVS_VERTEX_ONLY

		vec2 vUv;

	#else

		varying vec2 vUv;

	#endif

	uniform mat3 uvTransform;

#endif
`;

	var uv_vertex = /* glsl */`
#ifdef USE_UV

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

#endif
`;

	var uv2_pars_fragment = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	varying vec2 vUv2;

#endif
`;

	var uv2_pars_vertex = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	attribute vec2 uv2;
	varying vec2 vUv2;

	uniform mat3 uv2Transform;

#endif
`;

	var uv2_vertex = /* glsl */`
#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )

	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;

#endif
`;

	var worldpos_vertex = /* glsl */`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`;

	var background_frag = /* glsl */`
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;

	var background_vert = /* glsl */`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`;

	var cube_frag = /* glsl */`
#include <envmap_common_pars_fragment>
uniform float opacity;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>

	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;

	var cube_vert = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`;

	var depth_frag = /* glsl */`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#endif

}
`;

	var depth_vert = /* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`;

	var distanceRGBA_frag = /* glsl */`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( 1.0 );

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`;

	var distanceRGBA_vert = /* glsl */`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <skinbase_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`;

	var equirect_frag = /* glsl */`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	vec4 texColor = texture2D( tEquirect, sampleUV );

	gl_FragColor = mapTexelToLinear( texColor );

	#include <tonemapping_fragment>
	#include <encodings_fragment>

}
`;

	var equirect_vert = /* glsl */`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`;

	var linedashed_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;

	var linedashed_vert = /* glsl */`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

	var meshbasic_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
	
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	var meshbasic_vert = /* glsl */`
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <skinbase_vertex>

	#ifdef USE_ENVMAP

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`;

	var meshlambert_frag = /* glsl */`
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif


#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation

	#ifdef DOUBLE_SIDED

		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;

	#else

		reflectedLight.indirectDiffuse += vIndirectFront;

	#endif

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation

	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;

	var meshlambert_vert = /* glsl */`
#define LAMBERT

varying vec3 vLightFront;
varying vec3 vIndirectFront;

#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}
`;

	var meshmatcap_frag = /* glsl */`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>

#include <fog_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );

	#else

		vec4 matcapColor = vec4( 1.0 );

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	var meshmatcap_vert = /* glsl */`
#define MATCAP

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

		vNormal = normalize( transformedNormal );

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`;

	var meshtoon_frag = /* glsl */`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	var meshtoon_vert = /* glsl */`
#define TOON

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	var meshphong_frag = /* glsl */`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	var meshphong_vert = /* glsl */`
#define PHONG

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	var meshphysical_frag = /* glsl */`
#define STANDARD

#ifdef PHYSICAL
	#define REFLECTIVITY
	#define CLEARCOAT
	#define TRANSMISSION
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef TRANSMISSION
	uniform float transmission;
#endif

#ifdef REFLECTIVITY
	uniform float reflectivity;
#endif

#ifdef CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheen;
#endif

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <transmissionmap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <lights_physical_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#ifdef TRANSMISSION
		float totalTransmission = transmission;
	#endif

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <transmissionmap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	// this is a stub for the transmission model
	#ifdef TRANSMISSION
		diffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );
	#endif

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`;

	var meshphysical_vert = /* glsl */`
#define STANDARD

varying vec3 vViewPosition;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	var normal_frag = /* glsl */`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <packing>
#include <uv_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );

}
`;

	var normal_vert = /* glsl */`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	varying vec3 vViewPosition;

#endif

#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif

#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )

	vViewPosition = - mvPosition.xyz;

#endif

}
`;

	var points_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`;

	var points_vert = /* glsl */`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`;

	var shadow_frag = /* glsl */`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;

	var shadow_vert = /* glsl */`
#include <common>
#include <fog_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <begin_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`;

	var sprite_frag = /* glsl */`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>

	outgoingLight = diffuseColor.rgb;

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
`;

	var sprite_vert = /* glsl */`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`;

	const ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_pars_fragment: clearcoat_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		transmissionmap_fragment: transmissionmap_fragment,
		transmissionmap_pars_fragment: transmissionmap_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * Uniforms library for shared webgl shaders
	 */

	const UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowNormalBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} },

			ltc_1: { value: null },
			ltc_2: { value: null }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	const ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 1.0 },
					metalness: { value: 0.0 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	ShaderLib.physical = {

		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearcoat: { value: 0 },
				clearcoatMap: { value: null },
				clearcoatRoughness: { value: 0 },
				clearcoatRoughnessMap: { value: null },
				clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
				clearcoatNormalMap: { value: null },
				sheen: { value: new Color( 0x000000 ) },
				transmission: { value: 0 },
				transmissionMap: { value: null },
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	};

	function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

		const clearColor = new Color( 0x000000 );
		let clearAlpha = 0;

		let planeMesh;
		let boxMesh;

		let currentBackground = null;
		let currentBackgroundVersion = 0;
		let currentTonemapping = null;

		function render( renderList, scene, camera, forceClear ) {

			let background = scene.isScene === true ? scene.background : null;

			if ( background && background.isTexture ) {

				background = cubemaps.get( background );

			}

			// Ignore background in AR
			// TODO: Reconsider this.

			const xr = renderer.xr;
			const session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							name: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return this.uniforms.envMap.value;

						}

					} );

					objects.update( boxMesh );

				}

				if ( background.isWebGLCubeRenderTarget ) {

					// TODO Deprecate

					background = background.texture;

				}

				boxMesh.material.uniforms.envMap.value = background;
				boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneGeometry( 2, 2 ),
						new ShaderMaterial( {
							name: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha = 1 ) {

				clearColor.set( color );
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

		const maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );

		const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
		const vaoAvailable = capabilities.isWebGL2 || extension !== null;

		const bindingStates = {};

		const defaultState = createBindingState( null );
		let currentState = defaultState;

		function setup( object, material, program, geometry, index ) {

			let updateBuffers = false;

			if ( vaoAvailable ) {

				const state = getBindingState( geometry, program, material );

				if ( currentState !== state ) {

					currentState = state;
					bindVertexArrayObject( currentState.object );

				}

				updateBuffers = needsUpdate( geometry, index );

				if ( updateBuffers ) saveCache( geometry, index );

			} else {

				const wireframe = ( material.wireframe === true );

				if ( currentState.geometry !== geometry.id ||
					currentState.program !== program.id ||
					currentState.wireframe !== wireframe ) {

					currentState.geometry = geometry.id;
					currentState.program = program.id;
					currentState.wireframe = wireframe;

					updateBuffers = true;

				}

			}

			if ( object.isInstancedMesh === true ) {

				updateBuffers = true;

			}

			if ( index !== null ) {

				attributes.update( index, gl.ELEMENT_ARRAY_BUFFER );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( object, material, program, geometry );

				if ( index !== null ) {

					gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, attributes.get( index ).buffer );

				}

			}

		}

		function createVertexArrayObject() {

			if ( capabilities.isWebGL2 ) return gl.createVertexArray();

			return extension.createVertexArrayOES();

		}

		function bindVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

			return extension.bindVertexArrayOES( vao );

		}

		function deleteVertexArrayObject( vao ) {

			if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

			return extension.deleteVertexArrayOES( vao );

		}

		function getBindingState( geometry, program, material ) {

			const wireframe = ( material.wireframe === true );

			let programMap = bindingStates[ geometry.id ];

			if ( programMap === undefined ) {

				programMap = {};
				bindingStates[ geometry.id ] = programMap;

			}

			let stateMap = programMap[ program.id ];

			if ( stateMap === undefined ) {

				stateMap = {};
				programMap[ program.id ] = stateMap;

			}

			let state = stateMap[ wireframe ];

			if ( state === undefined ) {

				state = createBindingState( createVertexArrayObject() );
				stateMap[ wireframe ] = state;

			}

			return state;

		}

		function createBindingState( vao ) {

			const newAttributes = [];
			const enabledAttributes = [];
			const attributeDivisors = [];

			for ( let i = 0; i < maxVertexAttributes; i ++ ) {

				newAttributes[ i ] = 0;
				enabledAttributes[ i ] = 0;
				attributeDivisors[ i ] = 0;

			}

			return {

				// for backward compatibility on non-VAO support browser
				geometry: null,
				program: null,
				wireframe: false,

				newAttributes: newAttributes,
				enabledAttributes: enabledAttributes,
				attributeDivisors: attributeDivisors,
				object: vao,
				attributes: {},
				index: null

			};

		}

		function needsUpdate( geometry, index ) {

			const cachedAttributes = currentState.attributes;
			const geometryAttributes = geometry.attributes;

			let attributesNum = 0;

			for ( const key in geometryAttributes ) {

				const cachedAttribute = cachedAttributes[ key ];
				const geometryAttribute = geometryAttributes[ key ];

				if ( cachedAttribute === undefined ) return true;

				if ( cachedAttribute.attribute !== geometryAttribute ) return true;

				if ( cachedAttribute.data !== geometryAttribute.data ) return true;

				attributesNum ++;

			}

			if ( currentState.attributesNum !== attributesNum ) return true;

			if ( currentState.index !== index ) return true;

			return false;

		}

		function saveCache( geometry, index ) {

			const cache = {};
			const attributes = geometry.attributes;
			let attributesNum = 0;

			for ( const key in attributes ) {

				const attribute = attributes[ key ];

				const data = {};
				data.attribute = attribute;

				if ( attribute.data ) {

					data.data = attribute.data;

				}

				cache[ key ] = data;

				attributesNum ++;

			}

			currentState.attributes = cache;
			currentState.attributesNum = attributesNum;

			currentState.index = index;

		}

		function initAttributes() {

			const newAttributes = currentState.newAttributes;

			for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;
			const attributeDivisors = currentState.attributeDivisors;

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			const newAttributes = currentState.newAttributes;
			const enabledAttributes = currentState.enabledAttributes;

			for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

			if ( capabilities.isWebGL2 === true && ( type === gl.INT || type === gl.UNSIGNED_INT ) ) {

				gl.vertexAttribIPointer( index, size, type, stride, offset );

			} else {

				gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

			}

		}

		function setupVertexAttributes( object, material, program, geometry ) {

			if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			initAttributes();

			const geometryAttributes = geometry.attributes;

			const programAttributes = program.getAttributes();

			const materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( const name in programAttributes ) {

				const programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					const geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						const normalized = geometryAttribute.normalized;
						const size = geometryAttribute.itemSize;

						const attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;
						const bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							const data = geometryAttribute.data;
							const stride = data.stride;
							const offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = data.meshPerAttribute * data.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry._maxInstanceCount === undefined ) {

									geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								enableAttribute( programAttribute );

							}

							gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
							vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( name === 'instanceMatrix' ) {

						const attribute = attributes.get( object.instanceMatrix );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;

						enableAttributeAndDivisor( programAttribute + 0, 1 );
						enableAttributeAndDivisor( programAttribute + 1, 1 );
						enableAttributeAndDivisor( programAttribute + 2, 1 );
						enableAttributeAndDivisor( programAttribute + 3, 1 );

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
						gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
						gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
						gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

					} else if ( name === 'instanceColor' ) {

						const attribute = attributes.get( object.instanceColor );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						const buffer = attribute.buffer;
						const type = attribute.type;

						enableAttributeAndDivisor( programAttribute, 1 );

						gl.bindBuffer( gl.ARRAY_BUFFER, buffer );

						gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

					} else if ( materialDefaultAttributeValues !== undefined ) {

						const value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			disableUnusedAttributes();

		}

		function dispose() {

			reset();

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				for ( const programId in programMap ) {

					const stateMap = programMap[ programId ];

					for ( const wireframe in stateMap ) {

						deleteVertexArrayObject( stateMap[ wireframe ].object );

						delete stateMap[ wireframe ];

					}

					delete programMap[ programId ];

				}

				delete bindingStates[ geometryId ];

			}

		}

		function releaseStatesOfGeometry( geometry ) {

			if ( bindingStates[ geometry.id ] === undefined ) return;

			const programMap = bindingStates[ geometry.id ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometry.id ];

		}

		function releaseStatesOfProgram( program ) {

			for ( const geometryId in bindingStates ) {

				const programMap = bindingStates[ geometryId ];

				if ( programMap[ program.id ] === undefined ) continue;

				const stateMap = programMap[ program.id ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ program.id ];

			}

		}

		function reset() {

			resetDefaultState();

			if ( currentState === defaultState ) return;

			currentState = defaultState;
			bindVertexArrayObject( currentState.object );

		}

		// for backward-compatilibity

		function resetDefaultState() {

			defaultState.geometry = null;
			defaultState.program = null;
			defaultState.wireframe = false;

		}

		return {

			setup: setup,
			reset: reset,
			resetDefaultState: resetDefaultState,
			dispose: dispose,
			releaseStatesOfGeometry: releaseStatesOfGeometry,
			releaseStatesOfProgram: releaseStatesOfProgram,

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			disableUnusedAttributes: disableUnusedAttributes

		};

	}

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLCapabilities( gl, extensions, parameters ) {

		let maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		/* eslint-disable no-undef */
		const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
		/* eslint-enable no-undef */

		let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		const maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		const maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
		const maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
		const maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
		const maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

		const maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
		const maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
		const maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
		const maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

		const vertexTextures = maxVertexTextures > 0;
		const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
		const floatVertexTextures = vertexTextures && floatFragmentTextures;

		const maxSamples = isWebGL2 ? gl.getParameter( gl.MAX_SAMPLES ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	function WebGLClipping( properties ) {

		const scope = this;

		let globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false;

		const plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			const enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( material, camera, useCache ) {

			const planes = material.clippingPlanes,
				clipIntersection = material.clipIntersection,
				clipShadows = material.clipShadows;

			const materialProperties = properties.get( material );

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4;

				let dstArray = materialProperties.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, useCache );

				for ( let i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				materialProperties.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			const nPlanes = planes !== null ? planes.length : 0;
			let dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					const flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	class WebGLRenderTarget extends EventDispatcher {

		constructor( width, height, options ) {

			super();

			this.width = width;
			this.height = height;
			this.depth = 1;

			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;

			this.viewport = new Vector4( 0, 0, width, height );

			options = options || {};

			this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.texture.image = {};
			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = 1;

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

		}

		setTexture( texture ) {

			texture.image = {
				width: this.width,
				height: this.height,
				depth: this.depth
			};

			this.texture = texture;

		}

		setSize( width, height, depth = 1 ) {

			if ( this.width !== width || this.height !== height || this.depth !== depth ) {

				this.width = width;
				this.height = height;
				this.depth = depth;

				this.texture.image.width = width;
				this.texture.image.height = height;
				this.texture.image.depth = depth;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( source ) {

			this.width = source.width;
			this.height = source.height;
			this.depth = source.depth;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		}

		dispose() {

			this.dispatchEvent( { type: 'dispose' } );

		}

	}

	WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

	class WebGLCubeRenderTarget extends WebGLRenderTarget {

		constructor( size, options, dummy ) {

			if ( Number.isInteger( options ) ) {

				console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

				options = dummy;

			}

			super( size, size, options );

			options = options || {};

			this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

			this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
			this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

			this.texture._needsFlipEnvMap = false;

		}

		fromEquirectangularTexture( renderer, texture ) {

			this.texture.type = texture.type;
			this.texture.format = RGBAFormat; // see #18859
			this.texture.encoding = texture.encoding;

			this.texture.generateMipmaps = texture.generateMipmaps;
			this.texture.minFilter = texture.minFilter;
			this.texture.magFilter = texture.magFilter;

			const shader = {

				uniforms: {
					tEquirect: { value: null },
				},

				vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

				fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
			};

			const geometry = new BoxGeometry( 5, 5, 5 );

			const material = new ShaderMaterial( {

				name: 'CubemapFromEquirect',

				uniforms: cloneUniforms( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader,
				side: BackSide,
				blending: NoBlending

			} );

			material.uniforms.tEquirect.value = texture;

			const mesh = new Mesh( geometry, material );

			const currentMinFilter = texture.minFilter;

			// Avoid blurred poles
			if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

			const camera = new CubeCamera( 1, 10, this );
			camera.update( renderer, mesh );

			texture.minFilter = currentMinFilter;

			mesh.geometry.dispose();
			mesh.material.dispose();

			return this;

		}

		clear( renderer, color, depth, stencil ) {

			const currentRenderTarget = renderer.getRenderTarget();

			for ( let i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( this, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		}

	}

	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

	function WebGLCubeMaps( renderer ) {

		let cubemaps = new WeakMap();

		function mapTextureMapping( texture, mapping ) {

			if ( mapping === EquirectangularReflectionMapping ) {

				texture.mapping = CubeReflectionMapping;

			} else if ( mapping === EquirectangularRefractionMapping ) {

				texture.mapping = CubeRefractionMapping;

			}

			return texture;

		}

		function get( texture ) {

			if ( texture && texture.isTexture ) {

				const mapping = texture.mapping;

				if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

					if ( cubemaps.has( texture ) ) {

						const cubemap = cubemaps.get( texture ).texture;
						return mapTextureMapping( cubemap, texture.mapping );

					} else {

						const image = texture.image;

						if ( image && image.height > 0 ) {

							const currentRenderTarget = renderer.getRenderTarget();

							const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
							renderTarget.fromEquirectangularTexture( renderer, texture );
							cubemaps.set( texture, renderTarget );

							renderer.setRenderTarget( currentRenderTarget );

							texture.addEventListener( 'dispose', onTextureDispose );

							return mapTextureMapping( renderTarget.texture, texture.mapping );

						} else {

							// image not yet ready. try the conversion next frame

							return null;

						}

					}

				}

			}

			return texture;

		}

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			const cubemap = cubemaps.get( texture );

			if ( cubemap !== undefined ) {

				cubemaps.delete( texture );
				cubemap.dispose();

			}

		}

		function dispose() {

			cubemaps = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function WebGLExtensions( gl ) {

		const extensions = {};

		function getExtension( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			let extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			extensions[ name ] = extension;

			return extension;

		}

		return {

			has: function ( name ) {

				return getExtension( name ) !== null;

			},

			init: function ( capabilities ) {

				if ( capabilities.isWebGL2 ) {

					getExtension( 'EXT_color_buffer_float' );

				} else {

					getExtension( 'WEBGL_depth_texture' );
					getExtension( 'OES_texture_float' );
					getExtension( 'OES_texture_half_float' );
					getExtension( 'OES_texture_half_float_linear' );
					getExtension( 'OES_standard_derivatives' );
					getExtension( 'OES_element_index_uint' );
					getExtension( 'OES_vertex_array_object' );
					getExtension( 'ANGLE_instanced_arrays' );

				}

				getExtension( 'OES_texture_float_linear' );
				getExtension( 'EXT_color_buffer_half_float' );

			},

			get: function ( name ) {

				const extension = getExtension( name );

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				return extension;

			}

		};

	}

	function WebGLGeometries( gl, attributes, info, bindingStates ) {

		const geometries = {};
		const wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			const geometry = event.target;

			if ( geometry.index !== null ) {

				attributes.remove( geometry.index );

			}

			for ( const name in geometry.attributes ) {

				attributes.remove( geometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			delete geometries[ geometry.id ];

			const attribute = wireframeAttributes.get( geometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( geometry );

			}

			bindingStates.releaseStatesOfGeometry( geometry );

			if ( geometry.isInstancedBufferGeometry === true ) {

				delete geometry._maxInstanceCount;

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			if ( geometries[ geometry.id ] === true ) return geometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			geometries[ geometry.id ] = true;

			info.memory.geometries ++;

			return geometry;

		}

		function update( geometry ) {

			const geometryAttributes = geometry.attributes;

			// Updating index buffer in VAO now. See WebGLBindingStates.

			for ( const name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );

			}

			// morph targets

			const morphAttributes = geometry.morphAttributes;

			for ( const name in morphAttributes ) {

				const array = morphAttributes[ name ];

				for ( let i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], gl.ARRAY_BUFFER );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			const indices = [];

			const geometryIndex = geometry.index;
			const geometryPosition = geometry.attributes.position;
			let version = 0;

			if ( geometryIndex !== null ) {

				const array = geometryIndex.array;
				version = geometryIndex.version;

				for ( let i = 0, l = array.length; i < l; i += 3 ) {

					const a = array[ i + 0 ];
					const b = array[ i + 1 ];
					const c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				const array = geometryPosition.array;
				version = geometryPosition.version;

				for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					const a = i + 0;
					const b = i + 1;
					const c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			// Updating index buffer in VAO now. See WebGLBindingStates

			//

			const previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			const currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				const geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		let mode;

		function setMode( value ) {

			mode = value;

		}

		let type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode, 1 );

		}

		function renderInstances( start, count, primcount ) {

			if ( primcount === 0 ) return;

			let extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	function WebGLInfo( gl ) {

		const memory = {
			geometries: 0,
			textures: 0
		};

		const render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			render.calls ++;

			switch ( mode ) {

				case gl.TRIANGLES:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case gl.LINES:
					render.lines += instanceCount * ( count / 2 );
					break;

				case gl.LINE_STRIP:
					render.lines += instanceCount * ( count - 1 );
					break;

				case gl.LINE_LOOP:
					render.lines += instanceCount * count;
					break;

				case gl.POINTS:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	function numericalSort( a, b ) {

		return a[ 0 ] - b[ 0 ];

	}

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		const influencesList = {};
		const morphInfluences = new Float32Array( 8 );

		const workInfluences = [];

		for ( let i = 0; i < 8; i ++ ) {

			workInfluences[ i ] = [ i, 0 ];

		}

		function update( object, geometry, material, program ) {

			const objectInfluences = object.morphTargetInfluences;

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			const length = objectInfluences === undefined ? 0 : objectInfluences.length;

			let influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( let i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}

			// Collect influences

			for ( let i = 0; i < length; i ++ ) {

				const influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			for ( let i = 0; i < 8; i ++ ) {

				if ( i < length && influences[ i ][ 1 ] ) {

					workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
					workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

				} else {

					workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
					workInfluences[ i ][ 1 ] = 0;

				}

			}

			workInfluences.sort( numericalSort );

			const morphTargets = material.morphTargets && geometry.morphAttributes.position;
			const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			let morphInfluencesSum = 0;

			for ( let i = 0; i < 8; i ++ ) {

				const influence = workInfluences[ i ];
				const index = influence[ 0 ];
				const value = influence[ 1 ];

				if ( index !== Number.MAX_SAFE_INTEGER && value ) {

					if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

						geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

					}

					if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

						geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

					}

					morphInfluences[ i ] = value;
					morphInfluencesSum += value;

				} else {

					if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

						geometry.deleteAttribute( 'morphTarget' + i );

					}

					if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

						geometry.deleteAttribute( 'morphNormal' + i );

					}

					morphInfluences[ i ] = 0;

				}

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	function WebGLObjects( gl, geometries, attributes, info ) {

		let updateMap = new WeakMap();

		function update( object ) {

			const frame = info.render.frame;

			const geometry = object.geometry;
			const buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			if ( object.isInstancedMesh ) {

				if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

					object.addEventListener( 'dispose', onInstancedMeshDispose );

				}

				attributes.update( object.instanceMatrix, gl.ARRAY_BUFFER );

				if ( object.instanceColor !== null ) {

					attributes.update( object.instanceColor, gl.ARRAY_BUFFER );

				}

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		function onInstancedMeshDispose( event ) {

			const instancedMesh = event.target;

			instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

			attributes.remove( instancedMesh.instanceMatrix );

			if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	class DataTexture2DArray extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			super( null );

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;

		}

	}

	DataTexture2DArray.prototype.isDataTexture2DArray = true;

	class DataTexture3D extends Texture {

		constructor( data = null, width = 1, height = 1, depth = 1 ) {

			// We're going to add .setXXX() methods for setting properties later.
			// Users can still set in DataTexture3D directly.
			//
			//	const texture = new THREE.DataTexture3D( data, width, height, depth );
			// 	texture.anisotropy = 16;
			//
			// See #14839

			super( null );

			this.image = { data, width, height, depth };

			this.magFilter = NearestFilter;
			this.minFilter = NearestFilter;

			this.wrapR = ClampToEdgeWrapping;

			this.generateMipmaps = false;
			this.flipY = false;

			this.needsUpdate = true;

		}

	}

	DataTexture3D.prototype.isDataTexture3D = true;

	/**
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	const emptyTexture = new Texture();
	const emptyTexture2dArray = new DataTexture2DArray();
	const emptyTexture3d = new DataTexture3D();
	const emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	const arrayCacheF32 = [];
	const arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	const mat4array = new Float32Array( 16 );
	const mat3array = new Float32Array( 9 );
	const mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		const firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		const n = nBlocks * blockSize;
		let r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( let i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( let i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		let r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( let i = 0; i !== n; ++ i ) {

			r[ i ] = textures.allocateTextureUnit();

		}

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		const cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValueM2( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		const cache = this.cache;
		const elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		const cache = this.cache;
		const unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValueV1i( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValueV2i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		const cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// uint

	function setValueV1ui( gl, v ) {

		const cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}

	// Array of scalars
	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)
	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}


	// Array of vectors (flat or from THREE classes)

	function setValueV2fArray( gl, v ) {

		const data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		const data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2Array( gl, v ) {

		const data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		const data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		const data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of textures (2D / Cube)

	function setValueT1Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		const n = v.length;

		const units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( let i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		const cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		const seq = this.seq;

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	const RePathPart = /(\w+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		const path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			const match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex;

			let id = match[ 1 ];
			const idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				const map = container.map;
				let next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

		for ( let i = 0; i < n; ++ i ) {

			const info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		const u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		const v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		const r = [];

		for ( let i = 0, n = seq.length; i !== n; ++ i ) {

			const u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	function WebGLShader( gl, type, string ) {

		const shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	let programIdCount = 0;

	function addLineNumbers( string ) {

		const lines = string.split( '\n' );

		for ( let i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			case LogLuvEncoding:
				return [ 'LogLuv', '( value )' ];
			default:
				console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
				return [ 'Linear', '( value )' ];

		}

	}

	function getShaderErrors( gl, shader, type ) {

		const status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
		const log = gl.getShaderInfoLog( shader ).trim();

		if ( status && log === '' ) return '';

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		const source = gl.getShaderSource( shader );

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		const components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		let toneMappingName;

		switch ( toneMapping ) {

			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;

			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;

			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;

			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;

			case CustomToneMapping:
				toneMappingName = 'Custom';
				break;

			default:
				console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
				toneMappingName = 'Linear';

		}

		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

	}

	function generateExtensions( parameters ) {

		const chunks = [
			( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		const chunks = [];

		for ( const name in defines ) {

			const value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		const attributes = {};

		const n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( let i = 0; i < n; i ++ ) {

			const info = gl.getActiveAttrib( program, i );
			const name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		const string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

	function unrollLoops( string ) {

		return string
			.replace( unrollLoopPattern, loopReplacer )
			.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

	}

	function deprecatedLoopReplacer( match, start, end, snippet ) {

		console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
		return loopReplacer( match, start, end, snippet );

	}

	function loopReplacer( match, start, end, snippet ) {

		let string = '';

		for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	//

	function generatePrecision( parameters ) {

		let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

		if ( parameters.precision === 'highp' ) {

			precisionstring += '\n#define HIGH_PRECISION';

		} else if ( parameters.precision === 'mediump' ) {

			precisionstring += '\n#define MEDIUM_PRECISION';

		} else if ( parameters.precision === 'lowp' ) {

			precisionstring += '\n#define LOW_PRECISION';

		}

		return precisionstring;

	}

	function generateShadowMapTypeDefine( parameters ) {

		let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		} else if ( parameters.shadowMapType === VSMShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

		}

		return shadowMapTypeDefine;

	}

	function generateEnvMapTypeDefine( parameters ) {

		let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

			}

		}

		return envMapTypeDefine;

	}

	function generateEnvMapModeDefine( parameters ) {

		let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

		if ( parameters.envMap ) {

			switch ( parameters.envMapMode ) {

				case CubeRefractionMapping:
				case CubeUVRefractionMapping:

					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

		}

		return envMapModeDefine;

	}

	function generateEnvMapBlendingDefine( parameters ) {

		let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

		if ( parameters.envMap ) {

			switch ( parameters.combine ) {

				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		return envMapBlendingDefine;

	}

	function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

		const gl = renderer.getContext();

		const defines = parameters.defines;

		let vertexShader = parameters.vertexShader;
		let fragmentShader = parameters.fragmentShader;

		const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
		const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
		const envMapModeDefine = generateEnvMapModeDefine( parameters );
		const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


		const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		const customDefines = generateDefines( defines );

		const program = gl.createProgram();

		let prefixVertex, prefixFragment;
		let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

		if ( parameters.isRawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		} else {

			prefixVertex = [

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.instancing ? '#define USE_INSTANCING' : '',
				parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				'#ifdef USE_INSTANCING',

				'	attribute mat4 instanceMatrix;',

				'#endif',

				'#ifdef USE_INSTANCING_COLOR',

				'	attribute vec3 instanceColor;',

				'#endif',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_TANGENT',

				'	attribute vec4 tangent;',

				'#endif',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				generatePrecision( parameters ),

				'#define SHADER_NAME ' + parameters.shaderName,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
				parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
				parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
				parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

				parameters.sheen ? '#define USE_SHEEN' : '',
				parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

				parameters.vertexTangents ? '#define USE_TANGENT' : '',
				parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
				parameters.vertexUvs ? '#define USE_UV' : '',
				parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
				'uniform bool isOrthographic;',

				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

				parameters.dithering ? '#define DITHERING' : '',

				ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
				getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

				parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

			// GLSL 3.0 conversion for built-in materials and ShaderMaterial

			versionString = '#version 300 es\n';

			prefixVertex = [
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#define varying in',
				( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
				( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		const vertexGlsl = versionString + prefixVertex + vertexShader;
		const fragmentGlsl = versionString + prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		const glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		const glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			const programLog = gl.getProgramInfoLog( program ).trim();
			const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			let runnable = true;
			let haveDiagnostics = true;

			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

				runnable = false;

				const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// Clean up

		// Crashes in iOS9 and iOS10. #18402
		// gl.detachShader( program, glVertexShader );
		// gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		let cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		let cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			bindingStates.releaseStatesOfProgram( this );

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

		const programs = [];

		const isWebGL2 = capabilities.isWebGL2;
		const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		const floatVertexTextures = capabilities.floatVertexTextures;
		const maxVertexUniforms = capabilities.maxVertexUniforms;
		const vertexTextures = capabilities.vertexTextures;

		let precision = capabilities.precision;

		const shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		const parameterNames = [
			'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
			'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
			'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
			'roughnessMap', 'metalnessMap', 'gradientMap',
			'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
			'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
			'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals',
			'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha',
			'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
			'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
			'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
			'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
			'sheen', 'transmissionMap'
		];

		function getMaxBones( object ) {

			const skeleton = object.skeleton;
			const bones = skeleton.bones;

			if ( floatVertexTextures ) {

				return 1024;

			} else {

				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)

				const nVertexUniforms = maxVertexUniforms;
				const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

				const maxBones = Math.min( nVertexMatrices, bones.length );

				if ( maxBones < bones.length ) {

					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;

				}

				return maxBones;

			}

		}

		function getTextureEncodingFromMap( map ) {

			let encoding;

			if ( map && map.isTexture ) {

				encoding = map.encoding;

			} else if ( map && map.isWebGLRenderTarget ) {

				console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
				encoding = map.texture.encoding;

			} else {

				encoding = LinearEncoding;

			}

			return encoding;

		}

		function getParameters( material, lights, shadows, scene, object ) {

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;

			const envMap = cubemaps.get( material.envMap || environment );

			const shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			let vertexShader, fragmentShader;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];

				vertexShader = shader.vertexShader;
				fragmentShader = shader.fragmentShader;

			} else {

				vertexShader = material.vertexShader;
				fragmentShader = material.fragmentShader;

			}

			const currentRenderTarget = renderer.getRenderTarget();

			const parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: material.type,

				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: material.isRawShaderMaterial === true,
				glslVersion: material.glslVersion,

				precision: precision,

				instancing: object.isInstancedMesh === true,
				instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap ),
				envMap: !! envMap,
				envMapMode: envMap && envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( envMap ),
				envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatMap: !! material.clearcoatMap,
				clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
				clearcoatNormalMap: !! material.clearcoatNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				sheen: !! material.sheen,

				transmissionMap: !! material.transmissionMap,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: !! material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: clipping.numPlanes,
				numClipIntersection: clipping.numIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
				rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

				customProgramCacheKey: material.customProgramCacheKey()

			};

			return parameters;

		}

		function getProgramCacheKey( parameters ) {

			const array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.fragmentShader );
				array.push( parameters.vertexShader );

			}

			if ( parameters.defines !== undefined ) {

				for ( const name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			if ( parameters.isRawShaderMaterial === false ) {

				for ( let i = 0; i < parameterNames.length; i ++ ) {

					array.push( parameters[ parameterNames[ i ] ] );

				}

				array.push( renderer.outputEncoding );
				array.push( renderer.gammaFactor );

			}

			array.push( parameters.customProgramCacheKey );

			return array.join();

		}

		function getUniforms( material ) {

			const shaderID = shaderIDs[ material.type ];
			let uniforms;

			if ( shaderID ) {

				const shader = ShaderLib[ shaderID ];
				uniforms = UniformsUtils.clone( shader.uniforms );

			} else {

				uniforms = material.uniforms;

			}

			return uniforms;

		}

		function acquireProgram( parameters, cacheKey ) {

			let program;

			// Check if code has been already compiled
			for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

				const preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
				programs.push( program );

			}

			return program;

		}

		function releaseProgram( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				const i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		}

		return {
			getParameters: getParameters,
			getProgramCacheKey: getProgramCacheKey,
			getUniforms: getUniforms,
			acquireProgram: acquireProgram,
			releaseProgram: releaseProgram,
			// Exposed for resource monitoring & error feedback via renderer.info:
			programs: programs
		};

	}

	function WebGLProperties() {

		let properties = new WeakMap();

		function get( object ) {

			let map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList( properties ) {

		const renderItems = [];
		let renderItemsIndex = 0;

		const opaque = [];
		const transparent = [];

		const defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			let renderItem = renderItems[ renderItemsIndex ];
			const materialProperties = properties.get( material );

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: materialProperties.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = materialProperties.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				const renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;

			}

		}

		return {

			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists( properties ) {

		let lists = new WeakMap();

		function get( scene, renderCallDepth ) {

			let list;

			if ( lists.has( scene ) === false ) {

				list = new WebGLRenderList( properties );
				lists.set( scene, [ list ] );

			} else {

				if ( renderCallDepth >= lists.get( scene ).length ) {

					list = new WebGLRenderList( properties );
					lists.get( scene ).push( list );

				} else {

					list = lists.get( scene )[ renderCallDepth ];

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	function UniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color()
						};
						break;

					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0
						};
						break;

					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0
						};
						break;

					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;

					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
						};
						break;

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}

	function ShadowUniformsCache() {

		const lights = {};

		return {

			get: function ( light ) {

				if ( lights[ light.id ] !== undefined ) {

					return lights[ light.id ];

				}

				let uniforms;

				switch ( light.type ) {

					case 'DirectionalLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'SpotLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;

					case 'PointLight':
						uniforms = {
							shadowBias: 0,
							shadowNormalBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;

					// TODO (abelnation): set RectAreaLight shadow uniforms

				}

				lights[ light.id ] = uniforms;

				return uniforms;

			}

		};

	}



	let nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights( extensions, capabilities ) {

		const cache = new UniformsCache();

		const shadowCache = ShadowUniformsCache();

		const state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			rectAreaLTC1: null,
			rectAreaLTC2: null,
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );

		const vector3 = new Vector3();
		const matrix4 = new Matrix4();
		const matrix42 = new Matrix4();

		function setup( lights ) {

			let r = 0, g = 0, b = 0;

			for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			let numDirectionalShadows = 0;
			let numPointShadows = 0;
			let numSpotShadows = 0;

			lights.sort( shadowCastingLightsFirst );

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				const color = light.color;
				const intensity = light.intensity;
				const distance = light.distance;

				const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

				if ( light.isAmbientLight ) {

					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;

				} else if ( light.isLightProbe ) {

					for ( let j = 0; j < 9; j ++ ) {

						state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

					}

				} else if ( light.isDirectionalLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.directionalShadow[ directionalLength ] = shadowUniforms;
						state.directionalShadowMap[ directionalLength ] = shadowMap;
						state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

						numDirectionalShadows ++;

					}

					state.directional[ directionalLength ] = uniforms;

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = cache.get( light );

					uniforms.position.setFromMatrixPosition( light.matrixWorld );

					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;

					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;

						state.spotShadow[ spotLength ] = shadowUniforms;
						state.spotShadowMap[ spotLength ] = shadowMap;
						state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

						numSpotShadows ++;

					}

					state.spot[ spotLength ] = uniforms;

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = cache.get( light );

					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					state.rectArea[ rectAreaLength ] = uniforms;

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = cache.get( light );

					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;

					if ( light.castShadow ) {

						const shadow = light.shadow;

						const shadowUniforms = shadowCache.get( light );

						shadowUniforms.shadowBias = shadow.bias;
						shadowUniforms.shadowNormalBias = shadow.normalBias;
						shadowUniforms.shadowRadius = shadow.radius;
						shadowUniforms.shadowMapSize = shadow.mapSize;
						shadowUniforms.shadowCameraNear = shadow.camera.near;
						shadowUniforms.shadowCameraFar = shadow.camera.far;

						state.pointShadow[ pointLength ] = shadowUniforms;
						state.pointShadowMap[ pointLength ] = shadowMap;
						state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

						numPointShadows ++;

					}

					state.point[ pointLength ] = uniforms;

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = cache.get( light );

					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

					state.hemi[ hemiLength ] = uniforms;

					hemiLength ++;

				}

			}

			if ( rectAreaLength > 0 ) {

				if ( capabilities.isWebGL2 ) {

					// WebGL 2

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else {

					// WebGL 1

					if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
						state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

					} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

						state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
						state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

					} else {

						console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

					}

				}

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			const hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		function setupView( lights, camera ) {

			let directionalLength = 0;
			let pointLength = 0;
			let spotLength = 0;
			let rectAreaLength = 0;
			let hemiLength = 0;

			const viewMatrix = camera.matrixWorldInverse;

			for ( let i = 0, l = lights.length; i < l; i ++ ) {

				const light = lights[ i ];

				if ( light.isDirectionalLight ) {

					const uniforms = state.directional[ directionalLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					directionalLength ++;

				} else if ( light.isSpotLight ) {

					const uniforms = state.spot[ spotLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );

					spotLength ++;

				} else if ( light.isRectAreaLight ) {

					const uniforms = state.rectArea[ rectAreaLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );

					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );

					rectAreaLength ++;

				} else if ( light.isPointLight ) {

					const uniforms = state.point[ pointLength ];

					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );

					pointLength ++;

				} else if ( light.isHemisphereLight ) {

					const uniforms = state.hemi[ hemiLength ];

					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();

					hemiLength ++;

				}

			}

		}

		return {
			setup: setup,
			setupView: setupView,
			state: state
		};

	}

	function WebGLRenderState( extensions, capabilities ) {

		const lights = new WebGLLights( extensions, capabilities );

		const lightsArray = [];
		const shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights() {

			lights.setup( lightsArray );

		}

		function setupLightsView( camera ) {

			lights.setupView( lightsArray, camera );

		}

		const state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,
			setupLightsView: setupLightsView,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates( extensions, capabilities ) {

		let renderStates = new WeakMap();

		function get( scene, renderCallDepth = 0 ) {

			let renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.set( scene, [ renderState ] );

			} else {

				if ( renderCallDepth >= renderStates.get( scene ).length ) {

					renderState = new WebGLRenderState( extensions, capabilities );
					renderStates.get( scene ).push( renderState );

				} else {

					renderState = renderStates.get( scene )[ renderCallDepth ];

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	var vsm_frag = /* glsl */`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	float mean = 0.0;
	float squared_mean = 0.0;

	// This seems totally useless but it's a crazy work around for a Adreno compiler bug
	float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );

	for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean * HALF_SAMPLE_RATE;
	squared_mean = squared_mean * HALF_SAMPLE_RATE;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;

	var vsm_vert = /* glsl */`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`;

	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

		let _frustum = new Frustum();

		const _shadowMapSize = new Vector2(),
			_viewportSize = new Vector2(),

			_viewport = new Vector4(),

			_depthMaterials = [],
			_distanceMaterials = [],

			_materialCache = {};

		const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

		const shadowMaterialVertical = new ShaderMaterial( {

			defines: {
				SAMPLE_RATE: 2.0 / 8.0,
				HALF_SAMPLE_RATE: 1.0 / 8.0
			},

			uniforms: {
				shadow_pass: { value: null },
				resolution: { value: new Vector2() },
				radius: { value: 4.0 }
			},

			vertexShader: vsm_vert,

			fragmentShader: vsm_frag

		} );

		const shadowMaterialHorizontal = shadowMaterialVertical.clone();
		shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

		const fullScreenTri = new BufferGeometry();
		fullScreenTri.setAttribute(
			'position',
			new BufferAttribute(
				new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
				3
			)
		);

		const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

		const scope = this;

		this.enabled = false;

		this.autoUpdate = true;
		this.needsUpdate = false;

		this.type = PCFShadowMap;

		this.render = function ( lights, scene, camera ) {

			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

			if ( lights.length === 0 ) return;

			const currentRenderTarget = _renderer.getRenderTarget();
			const activeCubeFace = _renderer.getActiveCubeFace();
			const activeMipmapLevel = _renderer.getActiveMipmapLevel();

			const _state = _renderer.state;

			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );

			// render depth map

			for ( let i = 0, il = lights.length; i < il; i ++ ) {

				const light = lights[ i ];
				const shadow = light.shadow;

				if ( shadow === undefined ) {

					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;

				}

				if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

				_shadowMapSize.copy( shadow.mapSize );

				const shadowFrameExtents = shadow.getFrameExtents();

				_shadowMapSize.multiply( shadowFrameExtents );

				_viewportSize.copy( shadow.mapSize );

				if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

					if ( _shadowMapSize.x > maxTextureSize ) {

						_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
						_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
						shadow.mapSize.x = _viewportSize.x;

					}

					if ( _shadowMapSize.y > maxTextureSize ) {

						_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
						_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
						shadow.mapSize.y = _viewportSize.y;

					}

				}

				if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

					shadow.camera.updateProjectionMatrix();

				}

				if ( shadow.map === null ) {

					const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + '.shadowMap';

					shadow.camera.updateProjectionMatrix();

				}

				_renderer.setRenderTarget( shadow.map );
				_renderer.clear();

				const viewportCount = shadow.getViewportCount();

				for ( let vp = 0; vp < viewportCount; vp ++ ) {

					const viewport = shadow.getViewport( vp );

					_viewport.set(
						_viewportSize.x * viewport.x,
						_viewportSize.y * viewport.y,
						_viewportSize.x * viewport.z,
						_viewportSize.y * viewport.w
					);

					_state.viewport( _viewport );

					shadow.updateMatrices( light, vp );

					_frustum = shadow.getFrustum();

					renderObject( scene, camera, shadow.camera, light, this.type );

				}

				// do blur pass for VSM

				if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

					VSMPass( shadow, camera );

				}

				shadow.needsUpdate = false;

			}

			scope.needsUpdate = false;

			_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

		};

		function VSMPass( shadow, camera ) {

			const geometry = _objects.update( fullScreenMesh );

			// vertical pass

			shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
			shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialVertical.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.mapPass );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

			// horizontal pass

			shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
			shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
			shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();
			_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

		}

		function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			let material = _depthMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDepthMaterial( {

					depthPacking: RGBADepthPacking,

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_depthMaterials[ index ] = material;

			}

			return material;

		}

		function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

			const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

			let material = _distanceMaterials[ index ];

			if ( material === undefined ) {

				material = new MeshDistanceMaterial( {

					morphTargets: useMorphing,
					skinning: useSkinning

				} );

				_distanceMaterials[ index ] = material;

			}

			return material;

		}

		function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

			let result = null;

			let getMaterialVariant = getDepthMaterialVariant;
			let customMaterial = object.customDepthMaterial;

			if ( light.isPointLight === true ) {

				getMaterialVariant = getDistanceMaterialVariant;
				customMaterial = object.customDistanceMaterial;

			}

			if ( customMaterial === undefined ) {

				let useMorphing = false;

				if ( material.morphTargets === true ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				}

				let useSkinning = false;

				if ( object.isSkinnedMesh === true ) {

					if ( material.skinning === true ) {

						useSkinning = true;

					} else {

						console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

					}

				}

				const useInstancing = object.isInstancedMesh === true;

				result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

			} else {

				result = customMaterial;

			}

			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {

				// in this case we need a unique material instance reflecting the
				// appropriate state

				const keyA = result.uuid, keyB = material.uuid;

				let materialsForVariant = _materialCache[ keyA ];

				if ( materialsForVariant === undefined ) {

					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;

				}

				let cachedMaterial = materialsForVariant[ keyB ];

				if ( cachedMaterial === undefined ) {

					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;

				}

				result = cachedMaterial;

			}

			result.visible = material.visible;
			result.wireframe = material.wireframe;

			if ( type === VSMShadowMap ) {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

			} else {

				result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

			}

			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;

			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;

			if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

				result.referencePosition.setFromMatrixPosition( light.matrixWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;

			}

			return result;

		}

		function renderObject( object, camera, shadowCamera, light, type ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

				if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					const geometry = _objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

							const group = groups[ k ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else if ( material.visible ) {

						const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				renderObject( children[ i ], camera, shadowCamera, light, type );

			}

		}

	}

	function WebGLState( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			let locked = false;

			const color = new Vector4();
			let currentColorMask = null;
			const currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			let locked = false;

			let currentDepthMask = null;
			let currentDepthFunc = null;
			let currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( gl.DEPTH_TEST );

					} else {

						disable( gl.DEPTH_TEST );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( gl.NEVER );
									break;

								case AlwaysDepth:

									gl.depthFunc( gl.ALWAYS );
									break;

								case LessDepth:

									gl.depthFunc( gl.LESS );
									break;

								case LessEqualDepth:

									gl.depthFunc( gl.LEQUAL );
									break;

								case EqualDepth:

									gl.depthFunc( gl.EQUAL );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( gl.GEQUAL );
									break;

								case GreaterDepth:

									gl.depthFunc( gl.GREATER );
									break;

								case NotEqualDepth:

									gl.depthFunc( gl.NOTEQUAL );
									break;

								default:

									gl.depthFunc( gl.LEQUAL );

							}

						} else {

							gl.depthFunc( gl.LEQUAL );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			let locked = false;

			let currentStencilMask = null;
			let currentStencilFunc = null;
			let currentStencilRef = null;
			let currentStencilFuncMask = null;
			let currentStencilFail = null;
			let currentStencilZFail = null;
			let currentStencilZPass = null;
			let currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( gl.STENCIL_TEST );

						} else {

							disable( gl.STENCIL_TEST );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef !== stencilRef ||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail !== stencilFail ||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		const colorBuffer = new ColorBuffer();
		const depthBuffer = new DepthBuffer();
		const stencilBuffer = new StencilBuffer();

		let enabledCapabilities = {};

		let currentProgram = null;

		let currentBlendingEnabled = false;
		let currentBlending = null;
		let currentBlendEquation = null;
		let currentBlendSrc = null;
		let currentBlendDst = null;
		let currentBlendEquationAlpha = null;
		let currentBlendSrcAlpha = null;
		let currentBlendDstAlpha = null;
		let currentPremultipledAlpha = false;

		let currentFlipSided = null;
		let currentCullFace = null;

		let currentLineWidth = null;

		let currentPolygonOffsetFactor = null;
		let currentPolygonOffsetUnits = null;

		const maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );

		let lineWidthAvailable = false;
		let version = 0;
		const glVersion = gl.getParameter( gl.VERSION );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		let currentTextureSlot = null;
		let currentBoundTextures = {};

		const currentScissor = new Vector4();
		const currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			const texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
			gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

			for ( let i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

			}

			return texture;

		}

		const emptyTextures = {};
		emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
		emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		setBlending( NoBlending );

		//

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		const equationToGL = {
			[ AddEquation ]: gl.FUNC_ADD,
			[ SubtractEquation ]: gl.FUNC_SUBTRACT,
			[ ReverseSubtractEquation ]: gl.FUNC_REVERSE_SUBTRACT
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = gl.MIN;
			equationToGL[ MaxEquation ] = gl.MAX;

		} else {

			const extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		const factorToGL = {
			[ ZeroFactor ]: gl.ZERO,
			[ OneFactor ]: gl.ONE,
			[ SrcColorFactor ]: gl.SRC_COLOR,
			[ SrcAlphaFactor ]: gl.SRC_ALPHA,
			[ SrcAlphaSaturateFactor ]: gl.SRC_ALPHA_SATURATE,
			[ DstColorFactor ]: gl.DST_COLOR,
			[ DstAlphaFactor ]: gl.DST_ALPHA,
			[ OneMinusSrcColorFactor ]: gl.ONE_MINUS_SRC_COLOR,
			[ OneMinusSrcAlphaFactor ]: gl.ONE_MINUS_SRC_ALPHA,
			[ OneMinusDstColorFactor ]: gl.ONE_MINUS_DST_COLOR,
			[ OneMinusDstAlphaFactor ]: gl.ONE_MINUS_DST_ALPHA
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled === true ) {

					disable( gl.BLEND );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( currentBlendingEnabled === false ) {

				enable( gl.BLEND );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( gl.FUNC_ADD );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.ONE, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
								break;

							case AdditiveBlending:
								gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
								break;

							case SubtractiveBlending:
								gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
								break;

							case MultiplyBlending:
								gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( gl.CULL_FACE )
				: enable( gl.CULL_FACE );

			let flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			const stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( gl.CW );

				} else {

					gl.frontFace( gl.CCW );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( gl.CULL_FACE );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( gl.BACK );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( gl.FRONT );

					} else {

						gl.cullFace( gl.FRONT_AND_BACK );

					}

				}

			} else {

				disable( gl.CULL_FACE );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( gl.POLYGON_OFFSET_FILL );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( gl.POLYGON_OFFSET_FILL );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( gl.SCISSOR_TEST );

			} else {

				disable( gl.SCISSOR_TEST );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			let boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function unbindTexture() {

			const boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			// reset state

			gl.disable( gl.BLEND );
			gl.disable( gl.CULL_FACE );
			gl.disable( gl.DEPTH_TEST );
			gl.disable( gl.POLYGON_OFFSET_FILL );
			gl.disable( gl.SCISSOR_TEST );
			gl.disable( gl.STENCIL_TEST );

			gl.blendEquation( gl.FUNC_ADD );
			gl.blendFunc( gl.ONE, gl.ZERO );
			gl.blendFuncSeparate( gl.ONE, gl.ZERO, gl.ONE, gl.ZERO );

			gl.colorMask( true, true, true, true );
			gl.clearColor( 0, 0, 0, 0 );

			gl.depthMask( true );
			gl.depthFunc( gl.LESS );
			gl.clearDepth( 1 );

			gl.stencilMask( 0xffffffff );
			gl.stencilFunc( gl.ALWAYS, 0, 0xffffffff );
			gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );
			gl.clearStencil( 0 );

			gl.cullFace( gl.BACK );
			gl.frontFace( gl.CCW );

			gl.polygonOffset( 0, 0 );

			gl.activeTexture( gl.TEXTURE0 );

			gl.useProgram( null );

			gl.lineWidth( 1 );

			gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
			gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

			// reset internals

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlendingEnabled = false;
			currentBlending = null;
			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;
			currentPremultipledAlpha = false;

			currentFlipSided = null;
			currentCullFace = null;

			currentLineWidth = null;

			currentPolygonOffsetFactor = null;
			currentPolygonOffsetUnits = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			enable: enable,
			disable: disable,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		const isWebGL2 = capabilities.isWebGL2;
		const maxTextures = capabilities.maxTextures;
		const maxCubemapSize = capabilities.maxCubemapSize;
		const maxTextureSize = capabilities.maxTextureSize;
		const maxSamples = capabilities.maxSamples;

		const _videoTextures = new WeakMap();
		let _canvas;

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		let useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			let scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

					const width = floor( scale * image.width );
					const height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					const context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			const textureProperties = properties.get( texture );

			textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

		}

		function getInternalFormat( internalFormatName, glFormat, glType ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			let internalFormat = glFormat;

			if ( glFormat === _gl.RED ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.R32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.R16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.R8;

			}

			if ( glFormat === _gl.RGB ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGB32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGB16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGB8;

			}

			if ( glFormat === _gl.RGBA ) {

				if ( glType === _gl.FLOAT ) internalFormat = _gl.RGBA32F;
				if ( glType === _gl.HALF_FLOAT ) internalFormat = _gl.RGBA16F;
				if ( glType === _gl.UNSIGNED_BYTE ) internalFormat = _gl.RGBA8;

			}

			if ( internalFormat === _gl.R16F || internalFormat === _gl.R32F ||
				internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F ) {

				extensions.get( 'EXT_color_buffer_float' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return _gl.NEAREST;

			}

			return _gl.LINEAR;

		}

		//

		function onTextureDispose( event ) {

			const texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			if ( texture.isVideoTexture ) {

				_videoTextures.delete( texture );

			}

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			const renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			const textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				for ( let i = 0; i < 6; i ++ ) {

					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

				}

			} else {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
				if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
				if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
				if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

			}

			properties.remove( texture );
			properties.remove( renderTarget );

		}

		//

		let textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			const textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.isVideoTexture ) updateVideoTexture( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				const image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_3D, textureProperties.__webglTexture );

		}

		function setTextureCube( texture, slot ) {

			const textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadCubeTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

		}

		const wrappingToGL = {
			[ RepeatWrapping ]: _gl.REPEAT,
			[ ClampToEdgeWrapping ]: _gl.CLAMP_TO_EDGE,
			[ MirroredRepeatWrapping ]: _gl.MIRRORED_REPEAT
		};

		const filterToGL = {
			[ NearestFilter ]: _gl.NEAREST,
			[ NearestMipmapNearestFilter ]: _gl.NEAREST_MIPMAP_NEAREST,
			[ NearestMipmapLinearFilter ]: _gl.NEAREST_MIPMAP_LINEAR,

			[ LinearFilter ]: _gl.LINEAR,
			[ LinearMipmapNearestFilter ]: _gl.LINEAR_MIPMAP_NEAREST,
			[ LinearMipmapLinearFilter ]: _gl.LINEAR_MIPMAP_LINEAR
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[ texture.wrapT ] );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
				_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

				if ( textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY ) {

					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

				const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

				if ( texture.type === FloatType && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
				if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			let textureType = _gl.TEXTURE_2D;

			if ( texture.isDataTexture2DArray ) textureType = _gl.TEXTURE_2D_ARRAY;
			if ( texture.isDataTexture3D ) textureType = _gl.TEXTURE_3D;

			initTexture( textureProperties, texture );

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

			const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

			const supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format );

			let glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			let mipmap;
			const mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = _gl.DEPTH_COMPONENT;

				if ( isWebGL2 ) {

					if ( texture.type === FloatType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT32F;

					} else if ( texture.type === UnsignedIntType ) {

						glInternalFormat = _gl.DEPTH_COMPONENT24;

					} else if ( texture.type === UnsignedInt248Type ) {

						glInternalFormat = _gl.DEPTH24_STENCIL8;

					} else {

						glInternalFormat = _gl.DEPTH_COMPONENT16; // WebGL2 requires sized internalformat for glTexImage2D

					}

				} else {

					if ( texture.type === FloatType ) {

						console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

					}

				}

				// validation checks for WebGL 1

				if ( texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				if ( texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT ) {

					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					glInternalFormat = _gl.DEPTH_STENCIL;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				//

				state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( _gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( _gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( _gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( _gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		function uploadCubeTexture( textureProperties, texture, slot ) {

			if ( texture.image.length !== 6 ) return;

			initTexture( textureProperties, texture );

			state.activeTexture( _gl.TEXTURE0 + slot );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
			_gl.pixelStorei( _gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, _gl.NONE );

			const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
			const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

			const cubeImage = [];

			for ( let i = 0; i < 6; i ++ ) {

				if ( ! isCompressed && ! isDataTexture ) {

					cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

				} else {

					cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

				}

			}

			const image = cubeImage[ 0 ],
				supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

			let mipmaps;

			if ( isCompressed ) {

				for ( let i = 0; i < 6; i ++ ) {

					mipmaps = cubeImage[ i ].mipmaps;

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

							if ( glFormat !== null ) {

								state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {

								console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

							}

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				mipmaps = texture.mipmaps;

				for ( let i = 0; i < 6; i ++ ) {

					if ( isDataTexture ) {

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];
							const mipmapImage = mipmap.image[ i ].image;

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

						}

					} else {

						state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

						for ( let j = 0; j < mipmaps.length; j ++ ) {

							const mipmap = mipmaps[ j ];

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

						}

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length;

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				// We assume images for cube map have the same size.
				generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			const texture = renderTarget.texture;

			const glFormat = utils.convert( texture.format );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			if ( textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY ) {

				state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

			} else {

				state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				let glInternalFormat = _gl.DEPTH_COMPONENT16;

				if ( isMultisample ) {

					const depthTexture = renderTarget.depthTexture;

					if ( depthTexture && depthTexture.isDepthTexture ) {

						if ( depthTexture.type === FloatType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT32F;

						} else if ( depthTexture.type === UnsignedIntType ) {

							glInternalFormat = _gl.DEPTH_COMPONENT24;

						}

					}

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

			} else {

				const texture = renderTarget.texture;

				const glFormat = utils.convert( texture.format );
				const glType = utils.convert( texture.type );
				const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

				if ( isMultisample ) {

					const samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( _gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			const renderTargetProperties = properties.get( renderTarget );

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

			if ( renderTarget.depthTexture ) {

				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				if ( isCube ) {

					renderTargetProperties.__webglDepthbuffer = [];

					for ( let i = 0; i < 6; i ++ ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

					}

				} else {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

				}

			}

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			const texture = renderTarget.texture;

			const renderTargetProperties = properties.get( renderTarget );
			const textureProperties = properties.get( texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

			const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
			const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
			const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			// Handles WebGL2 RGBFormat fallback - #18858

			if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType || texture.type === HalfFloatType ) ) {

				texture.format = RGBAFormat;

				console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

			}

			// Setup framebuffer

			if ( isCube ) {

				renderTargetProperties.__webglFramebuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

				}

			} else {

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );

						const glFormat = utils.convert( texture.format );
						const glType = utils.convert( texture.type );
						const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
						const samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( _gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			if ( isCube ) {

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, supportsMips );

				for ( let i = 0; i < 6; i ++ ) {

					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

				}

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_CUBE_MAP, texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				let glTextureType = _gl.TEXTURE_2D;

				if ( isRenderTarget3D ) {

					// Render targets containing layers, i.e: Texture 3D and 2d arrays

					if ( isWebGL2 ) {

						const isTexture3D = texture.isDataTexture3D;
						glTextureType = isTexture3D ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;

					} else {

						console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

					}

				}

				state.bindTexture( glTextureType, textureProperties.__webglTexture );
				setTextureParameters( glTextureType, texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, glTextureType );

				if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

					generateMipmap( _gl.TEXTURE_2D, texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( _gl.TEXTURE_2D, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			const texture = renderTarget.texture;

			const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				const target = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
				const webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( isWebGL2 ) {

					const renderTargetProperties = properties.get( renderTarget );

					_gl.bindFramebuffer( _gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( _gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );

					const width = renderTarget.width;
					const height = renderTarget.height;
					let mask = _gl.COLOR_BUFFER_BIT;

					if ( renderTarget.depthBuffer ) mask |= _gl.DEPTH_BUFFER_BIT;
					if ( renderTarget.stencilBuffer ) mask |= _gl.STENCIL_BUFFER_BIT;

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST );

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( maxSamples, renderTarget.samples ) : 0;

		}

		function updateVideoTexture( texture ) {

			const frame = info.render.frame;

			// Check the last frame we updated the VideoTexture

			if ( _videoTextures.get( texture ) !== frame ) {

				_videoTextures.set( texture, frame );
				texture.update();

			}

		}

		// backwards compatibility

		let warnedTexture2D = false;
		let warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && texture.isWebGLCubeRenderTarget ) {

				if ( warnedTextureCube === false ) {

					console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}


			setTextureCube( texture, slot );

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	function WebGLUtils( gl, extensions, capabilities ) {

		const isWebGL2 = capabilities.isWebGL2;

		function convert( p ) {

			let extension;

			if ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;
			if ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;
			if ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;
			if ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;

			if ( p === ByteType ) return gl.BYTE;
			if ( p === ShortType ) return gl.SHORT;
			if ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;
			if ( p === IntType ) return gl.INT;
			if ( p === UnsignedIntType ) return gl.UNSIGNED_INT;
			if ( p === FloatType ) return gl.FLOAT;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return gl.HALF_FLOAT;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return gl.ALPHA;
			if ( p === RGBFormat ) return gl.RGB;
			if ( p === RGBAFormat ) return gl.RGBA;
			if ( p === LuminanceFormat ) return gl.LUMINANCE;
			if ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;
			if ( p === DepthFormat ) return gl.DEPTH_COMPONENT;
			if ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;
			if ( p === RedFormat ) return gl.RED;

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) return gl.RED_INTEGER;
			if ( p === RGFormat ) return gl.RG;
			if ( p === RGIntegerFormat ) return gl.RG_INTEGER;
			if ( p === RGBIntegerFormat ) return gl.RGB_INTEGER;
			if ( p === RGBAIntegerFormat ) return gl.RGBA_INTEGER;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

				}

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === RGBA_BPTC_Format ) {

				extension = extensions.get( 'EXT_texture_compression_bptc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return gl.UNSIGNED_INT_24_8;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

		}

		return { convert: convert };

	}

	function WebXRController() {

		this._targetRay = null;
		this._grip = null;
		this._hand = null;

	}

	Object.assign( WebXRController.prototype, {

		constructor: WebXRController,

		getHandSpace: function () {

			if ( this._hand === null ) {

				this._hand = new Group();
				this._hand.matrixAutoUpdate = false;
				this._hand.visible = false;

				this._hand.joints = {};
				this._hand.inputState = { pinching: false };

			}

			return this._hand;

		},

		getTargetRaySpace: function () {

			if ( this._targetRay === null ) {

				this._targetRay = new Group();
				this._targetRay.matrixAutoUpdate = false;
				this._targetRay.visible = false;

			}

			return this._targetRay;

		},

		getGripSpace: function () {

			if ( this._grip === null ) {

				this._grip = new Group();
				this._grip.matrixAutoUpdate = false;
				this._grip.visible = false;

			}

			return this._grip;

		},

		dispatchEvent: function ( event ) {

			if ( this._targetRay !== null ) {

				this._targetRay.dispatchEvent( event );

			}

			if ( this._grip !== null ) {

				this._grip.dispatchEvent( event );

			}

			if ( this._hand !== null ) {

				this._hand.dispatchEvent( event );

			}

			return this;

		},

		disconnect: function ( inputSource ) {

			this.dispatchEvent( { type: 'disconnected', data: inputSource } );

			if ( this._targetRay !== null ) {

				this._targetRay.visible = false;

			}

			if ( this._grip !== null ) {

				this._grip.visible = false;

			}

			if ( this._hand !== null ) {

				this._hand.visible = false;

			}

			return this;

		},

		update: function ( inputSource, frame, referenceSpace ) {

			let inputPose = null;
			let gripPose = null;
			let handPose = null;

			const targetRay = this._targetRay;
			const grip = this._grip;
			const hand = this._hand;

			if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

				if ( hand && inputSource.hand ) {

					handPose = true;

					for ( const inputjoint of inputSource.hand.values() ) {

						// Update the joints groups with the XRJoint poses
						const jointPose = frame.getJointPose( inputjoint, referenceSpace );

						if ( hand.joints[ inputjoint.jointName ] === undefined ) {

							// The transform of this joint will be updated with the joint pose on each frame
							const joint = new Group();
							joint.matrixAutoUpdate = false;
							joint.visible = false;
							hand.joints[ inputjoint.jointName ] = joint;
							// ??
							hand.add( joint );

						}

						const joint = hand.joints[ inputjoint.jointName ];

						if ( jointPose !== null ) {

							joint.matrix.fromArray( jointPose.transform.matrix );
							joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
							joint.jointRadius = jointPose.radius;

						}

						joint.visible = jointPose !== null;

					}

					// Custom events

					// Check pinchz
					const indexTip = hand.joints[ 'index-finger-tip' ];
					const thumbTip = hand.joints[ 'thumb-tip' ];
					const distance = indexTip.position.distanceTo( thumbTip.position );

					const distanceToPinch = 0.02;
					const threshold = 0.005;

					if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

						hand.inputState.pinching = false;
						this.dispatchEvent( {
							type: 'pinchend',
							handedness: inputSource.handedness,
							target: this
						} );

					} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

						hand.inputState.pinching = true;
						this.dispatchEvent( {
							type: 'pinchstart',
							handedness: inputSource.handedness,
							target: this
						} );

					}

				} else {

					if ( targetRay !== null ) {

						inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

						if ( inputPose !== null ) {

							targetRay.matrix.fromArray( inputPose.transform.matrix );
							targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

						}

					}

					if ( grip !== null && inputSource.gripSpace ) {

						gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

						if ( gripPose !== null ) {

							grip.matrix.fromArray( gripPose.transform.matrix );
							grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

						}

					}

				}

			}

			if ( targetRay !== null ) {

				targetRay.visible = ( inputPose !== null );

			}

			if ( grip !== null ) {

				grip.visible = ( gripPose !== null );

			}

			if ( hand !== null ) {

				hand.visible = ( handPose !== null );

			}

			return this;

		}

	} );

	function WebXRManager( renderer, gl ) {

		const scope = this;

		let session = null;

		let framebufferScaleFactor = 1.0;

		let referenceSpace = null;
		let referenceSpaceType = 'local-floor';

		let pose = null;

		const controllers = [];
		const inputSourcesMap = new Map();

		//

		const cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();

		const cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();

		const cameras = [ cameraL, cameraR ];

		const cameraVR = new ArrayCamera();
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );

		let _currentDepthNear = null;
		let _currentDepthFar = null;

		//

		this.enabled = false;

		this.isPresenting = false;

		this.getController = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getTargetRaySpace();

		};

		this.getControllerGrip = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getGripSpace();

		};

		this.getHand = function ( index ) {

			let controller = controllers[ index ];

			if ( controller === undefined ) {

				controller = new WebXRController();
				controllers[ index ] = controller;

			}

			return controller.getHandSpace();

		};

		//

		function onSessionEvent( event ) {

			const controller = inputSourcesMap.get( event.inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: event.type, data: event.inputSource } );

			}

		}

		function onSessionEnd() {

			inputSourcesMap.forEach( function ( controller, inputSource ) {

				controller.disconnect( inputSource );

			} );

			inputSourcesMap.clear();

			_currentDepthNear = null;
			_currentDepthFar = null;

			//

			renderer.setFramebuffer( null );
			renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
			animation.stop();

			scope.isPresenting = false;

			scope.dispatchEvent( { type: 'sessionend' } );

		}

		this.setFramebufferScaleFactor = function ( value ) {

			framebufferScaleFactor = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

			}

		};

		this.setReferenceSpaceType = function ( value ) {

			referenceSpaceType = value;

			if ( scope.isPresenting === true ) {

				console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

			}

		};

		this.getReferenceSpace = function () {

			return referenceSpace;

		};

		this.getSession = function () {

			return session;

		};

		this.setSession = async function ( value ) {

			session = value;

			if ( session !== null ) {

				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'squeeze', onSessionEvent );
				session.addEventListener( 'squeezestart', onSessionEvent );
				session.addEventListener( 'squeezeend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
				session.addEventListener( 'inputsourceschange', onInputSourcesChange );

				const attributes = gl.getContextAttributes();

				if ( attributes.xrCompatible !== true ) {

					await gl.makeXRCompatible();

				}

				const layerInit = {
					antialias: attributes.antialias,
					alpha: attributes.alpha,
					depth: attributes.depth,
					stencil: attributes.stencil,
					framebufferScaleFactor: framebufferScaleFactor
				};

				// eslint-disable-next-line no-undef
				const baseLayer = new XRWebGLLayer( session, gl, layerInit );

				session.updateRenderState( { baseLayer: baseLayer } );

				referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

				animation.setContext( session );
				animation.start();

				scope.isPresenting = true;

				scope.dispatchEvent( { type: 'sessionstart' } );

			}

		};

		function onInputSourcesChange( event ) {

			const inputSources = session.inputSources;

			// Assign inputSources to available controllers

			for ( let i = 0; i < controllers.length; i ++ ) {

				inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

			}

			// Notify disconnected

			for ( let i = 0; i < event.removed.length; i ++ ) {

				const inputSource = event.removed[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
					inputSourcesMap.delete( inputSource );

				}

			}

			// Notify connected

			for ( let i = 0; i < event.added.length; i ++ ) {

				const inputSource = event.added[ i ];
				const controller = inputSourcesMap.get( inputSource );

				if ( controller ) {

					controller.dispatchEvent( { type: 'connected', data: inputSource } );

				}

			}

		}

		//

		const cameraLPos = new Vector3();
		const cameraRPos = new Vector3();

		/**
		 * Assumes 2 cameras that are parallel and share an X-axis, and that
		 * the cameras' projection and world matrices have already been set.
		 * And that near and far planes are identical for both cameras.
		 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
		 */
		function setProjectionFromUnion( camera, cameraL, cameraR ) {

			cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
			cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

			const ipd = cameraLPos.distanceTo( cameraRPos );

			const projL = cameraL.projectionMatrix.elements;
			const projR = cameraR.projectionMatrix.elements;

			// VR systems will have identical far and near planes, and
			// most likely identical top and bottom frustum extents.
			// Use the left camera for these values.
			const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
			const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
			const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
			const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

			const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
			const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
			const left = near * leftFov;
			const right = near * rightFov;

			// Calculate the new camera's position offset from the
			// left camera. xOffset should be roughly half `ipd`.
			const zOffset = ipd / ( - leftFov + rightFov );
			const xOffset = zOffset * - leftFov;

			// TODO: Better way to apply this offset?
			cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
			camera.translateX( xOffset );
			camera.translateZ( zOffset );
			camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

			// Find the union of the frustum values of the cameras and scale
			// the values so that the near plane's position does not change in world space,
			// although must now be relative to the new union camera.
			const near2 = near + zOffset;
			const far2 = far + zOffset;
			const left2 = left - xOffset;
			const right2 = right + ( ipd - xOffset );
			const top2 = topFov * far / far2 * near2;
			const bottom2 = bottomFov * far / far2 * near2;

			camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

		}

		function updateCamera( camera, parent ) {

			if ( parent === null ) {

				camera.matrixWorld.copy( camera.matrix );

			} else {

				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

			}

			camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		}

		this.getCamera = function ( camera ) {

			cameraVR.near = cameraR.near = cameraL.near = camera.near;
			cameraVR.far = cameraR.far = cameraL.far = camera.far;

			if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

				// Note that the new renderState won't apply until the next frame. See #18320

				session.updateRenderState( {
					depthNear: cameraVR.near,
					depthFar: cameraVR.far
				} );

				_currentDepthNear = cameraVR.near;
				_currentDepthFar = cameraVR.far;

			}

			const parent = camera.parent;
			const cameras = cameraVR.cameras;

			updateCamera( cameraVR, parent );

			for ( let i = 0; i < cameras.length; i ++ ) {

				updateCamera( cameras[ i ], parent );

			}

			// update camera and its children

			camera.matrixWorld.copy( cameraVR.matrixWorld );
			camera.matrix.copy( cameraVR.matrix );
			camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

			const children = camera.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( true );

			}

			// update projection matrix for proper view frustum culling

			if ( cameras.length === 2 ) {

				setProjectionFromUnion( cameraVR, cameraL, cameraR );

			} else {

				// assume single camera setup (AR)

				cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

			}

			return cameraVR;

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time, frame ) {

			pose = frame.getViewerPose( referenceSpace );

			if ( pose !== null ) {

				const views = pose.views;
				const baseLayer = session.renderState.baseLayer;

				renderer.setFramebuffer( baseLayer.framebuffer );

				let cameraVRNeedsUpdate = false;

				// check if it's necessary to rebuild cameraVR's camera list

				if ( views.length !== cameraVR.cameras.length ) {

					cameraVR.cameras.length = 0;
					cameraVRNeedsUpdate = true;

				}

				for ( let i = 0; i < views.length; i ++ ) {

					const view = views[ i ];
					const viewport = baseLayer.getViewport( view );

					const camera = cameras[ i ];
					camera.matrix.fromArray( view.transform.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

					if ( i === 0 ) {

						cameraVR.matrix.copy( camera.matrix );

					}

					if ( cameraVRNeedsUpdate === true ) {

						cameraVR.cameras.push( camera );

					}

				}

			}

			//

			const inputSources = session.inputSources;

			for ( let i = 0; i < controllers.length; i ++ ) {

				const controller = controllers[ i ];
				const inputSource = inputSources[ i ];

				controller.update( inputSource, frame, referenceSpace );

			}

			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;

		};

		this.dispose = function () {};

	}

	Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

	function WebGLMaterials( properties ) {

		function refreshFogUniforms( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

			if ( material.isMeshBasicMaterial ) {

				refreshUniformsCommon( uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsLambert( uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsToon( uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsPhong( uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsCommon( uniforms, material );

				if ( material.isMeshPhysicalMaterial ) {

					refreshUniformsPhysical( uniforms, material );

				} else {

					refreshUniformsStandard( uniforms, material );

				}

			} else if ( material.isMeshMatcapMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsMatcap( uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDepth( uniforms, material );

			} else if ( material.isMeshDistanceMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsDistance( uniforms, material );

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsCommon( uniforms, material );
				refreshUniformsNormal( uniforms, material );

			} else if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( uniforms, material );

				if ( material.isLineDashedMaterial ) {

					refreshUniformsDash( uniforms, material );

				}

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( uniforms, material, pixelRatio, height );

			} else if ( material.isSpriteMaterial ) {

				refreshUniformsSprites( uniforms, material );

			} else if ( material.isShadowMaterial ) {

				uniforms.color.value.copy( material.color );
				uniforms.opacity.value = material.opacity;

			} else if ( material.isShaderMaterial ) {

				material.uniformsNeedUpdate = false; // #15581

			}

		}

		function refreshUniformsCommon( uniforms, material ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				uniforms.envMap.value = envMap;

				uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				const maxMipLevel = properties.get( envMap ).__maxMipLevel;

				if ( maxMipLevel !== undefined ) {

					uniforms.maxMipLevel.value = maxMipLevel;

				}

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. displacementMap map
			// 4. normal map
			// 5. bump map
			// 6. roughnessMap map
			// 7. metalnessMap map
			// 8. alphaMap map
			// 9. emissiveMap map
			// 10. clearcoat map
			// 11. clearcoat normal map
			// 12. clearcoat roughnessMap map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			} else if ( material.clearcoatMap ) {

				uvScaleMap = material.clearcoatMap;

			} else if ( material.clearcoatNormalMap ) {

				uvScaleMap = material.clearcoatNormalMap;

			} else if ( material.clearcoatRoughnessMap ) {

				uvScaleMap = material.clearcoatRoughnessMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			let uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * pixelRatio;
			uniforms.scale.value = height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			let uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsLambert( uniforms, material ) {

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

		}

		function refreshUniformsPhong( uniforms, material ) {

			uniforms.specular.value.copy( material.specular );
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsToon( uniforms, material ) {

			if ( material.gradientMap ) {

				uniforms.gradientMap.value = material.gradientMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsStandard( uniforms, material ) {

			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;

			if ( material.roughnessMap ) {

				uniforms.roughnessMap.value = material.roughnessMap;

			}

			if ( material.metalnessMap ) {

				uniforms.metalnessMap.value = material.metalnessMap;

			}

			if ( material.emissiveMap ) {

				uniforms.emissiveMap.value = material.emissiveMap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			const envMap = properties.get( material ).envMap;

			if ( envMap ) {

				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;

			}

		}

		function refreshUniformsPhysical( uniforms, material ) {

			refreshUniformsStandard( uniforms, material );

			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

			uniforms.clearcoat.value = material.clearcoat;
			uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
			if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

			if ( material.clearcoatMap ) {

				uniforms.clearcoatMap.value = material.clearcoatMap;

			}

			if ( material.clearcoatRoughnessMap ) {

				uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

			}

			if ( material.clearcoatNormalMap ) {

				uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
				uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

				if ( material.side === BackSide ) {

					uniforms.clearcoatNormalScale.value.negate();

				}

			}

			uniforms.transmission.value = material.transmission;

			if ( material.transmissionMap ) {

				uniforms.transmissionMap.value = material.transmissionMap;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDistance( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		return {
			refreshFogUniforms: refreshFogUniforms,
			refreshMaterialUniforms: refreshMaterialUniforms
		};

	}

	function createCanvasElement() {

		const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.style.display = 'block';
		return canvas;

	}

	function WebGLRenderer( parameters ) {

		parameters = parameters || {};

		const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		let currentRenderList = null;
		let currentRenderState = null;

		// render() can be called from within a callback triggered by another render.
		// We track this so that the nested render call gets its list and state isolated from the parent render call.

		const renderListStack = [];
		const renderStateStack = [];

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = NoToneMapping;
		this.toneMappingExposure = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		const _this = this;

		let _isContextLost = false;

		// internal state cache

		let _framebuffer = null;

		let _currentActiveCubeFace = 0;
		let _currentActiveMipmapLevel = 0;
		let _currentRenderTarget = null;
		let _currentFramebuffer = null;
		let _currentMaterialId = - 1;

		let _currentCamera = null;

		const _currentViewport = new Vector4();
		const _currentScissor = new Vector4();
		let _currentScissorTest = null;

		//

		let _width = _canvas.width;
		let _height = _canvas.height;

		let _pixelRatio = 1;
		let _opaqueSort = null;
		let _transparentSort = null;

		const _viewport = new Vector4( 0, 0, _width, _height );
		const _scissor = new Vector4( 0, 0, _width, _height );
		let _scissorTest = false;

		// frustum

		const _frustum = new Frustum();

		// clipping

		let _clippingEnabled = false;
		let _localClippingEnabled = false;

		// camera matrices cache

		const _projScreenMatrix = new Matrix4();

		const _vector3 = new Vector3();

		const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		let _gl = _context;

		function getContext( contextNames, contextAttributes ) {

			for ( let i = 0; i < contextNames.length; i ++ ) {

				const contextName = contextNames[ i ];
				const context = _canvas.getContext( contextName, contextAttributes );
				if ( context !== null ) return context;

			}

			return null;

		}

		try {

			const contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			if ( _gl === null ) {

				const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

				if ( _this.isWebGL1Renderer === true ) {

					contextNames.shift();

				}

				_gl = getContext( contextNames, contextAttributes );

				if ( _gl === null ) {

					if ( getContext( contextNames ) ) {

						throw new Error( 'Error creating WebGL context with your selected attributes.' );

					} else {

						throw new Error( 'Error creating WebGL context.' );

					}

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		let extensions, capabilities, state, info;
		let properties, textures, cubemaps, attributes, geometries, objects;
		let programCache, materials, renderLists, renderStates, clipping;

		let background, morphtargets, bufferRenderer, indexedBufferRenderer;

		let utils, bindingStates;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			extensions.init( capabilities );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			cubemaps = new WebGLCubeMaps( _this );
			attributes = new WebGLAttributes( _gl, capabilities );
			bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl );
			clipping = new WebGLClipping( properties );
			programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
			materials = new WebGLMaterials( properties );
			renderLists = new WebGLRenderLists( properties );
			renderStates = new WebGLRenderStates( extensions, capabilities );
			background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		const xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// shadow map

		const shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			const extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

				target = new Color();

			}

			return target.copy( background.getClearColor() );

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			let bits = 0;

			if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
			if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
			if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			cubemaps.dispose();
			objects.dispose();
			bindingStates.dispose();

			xr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			const material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			const programInfo = properties.get( material ).program;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			bindingStates.initAttributes();

			const buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			const programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
				_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

				bindingStates.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			bindingStates.disableUnusedAttributes();

			_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

			object.count = 0;

		};

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

			const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material, frontFaceCW );

			//

			let index = geometry.index;
			const position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) return;

			} else if ( index.count === 0 ) {

				return;

			}

			//

			let rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			if ( material.morphTargets || material.morphNormals ) {

				morphtargets.update( object, geometry, material, program );

			}

			bindingStates.setup( object, material, program, geometry, index );

			let attribute;
			let renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			//

			const dataCount = ( index !== null ) ? index.count : position.count;

			const rangeStart = geometry.drawRange.start * rangeFactor;
			const rangeCount = geometry.drawRange.count * rangeFactor;

			const groupStart = group !== null ? group.start * rangeFactor : 0;
			const groupCount = group !== null ? group.count * rangeFactor : Infinity;

			const drawStart = Math.max( rangeStart, groupStart );
			const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( _gl.LINES );

				} else {

					renderer.setMode( _gl.TRIANGLES );

				}

			} else if ( object.isLine ) {

				let lineWidth = material.linewidth;

				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

				state.setLineWidth( lineWidth * getTargetPixelRatio() );

				if ( object.isLineSegments ) {

					renderer.setMode( _gl.LINES );

				} else if ( object.isLineLoop ) {

					renderer.setMode( _gl.LINE_LOOP );

				} else {

					renderer.setMode( _gl.LINE_STRIP );

				}

			} else if ( object.isPoints ) {

				renderer.setMode( _gl.POINTS );

			} else if ( object.isSprite ) {

				renderer.setMode( _gl.TRIANGLES );

			}

			if ( object.isInstancedMesh ) {

				renderer.renderInstances( drawStart, drawCount, object.count );

			} else if ( geometry.isInstancedBufferGeometry ) {

				const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

				renderer.renderInstances( drawStart, drawCount, instanceCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene );
			currentRenderState.init();

			scene.traverseVisible( function ( object ) {

				if ( object.isLight && object.layers.test( camera.layers ) ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				}

			} );

			currentRenderState.setupLights();

			const compiled = new WeakMap();

			scene.traverse( function ( object ) {

				const material = object.material;

				if ( material ) {

					if ( Array.isArray( material ) ) {

						for ( let i = 0; i < material.length; i ++ ) {

							const material2 = material[ i ];

							if ( compiled.has( material2 ) === false ) {

								initMaterial( material2, scene, object );
								compiled.set( material2 );

							}

						}

					} else if ( compiled.has( material ) === false ) {

						initMaterial( material, scene, object );
						compiled.set( material );

					}

				}

			} );

		};

		// Animation Loop

		let onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( xr.isPresenting ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		const animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			( callback === null ) ? animation.stop() : animation.start();

		};

		// Rendering

		this.render = function ( scene, camera ) {

			let renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( camera !== undefined && camera.isCamera !== true ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost === true ) return;

			// reset caching for this frame

			bindingStates.resetDefaultState();
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( xr.enabled === true && xr.isPresenting === true ) {

				camera = xr.getCamera( camera );

			}

			//
			if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

			currentRenderState = renderStates.get( scene, renderStateStack.length );
			currentRenderState.init();

			renderStateStack.push( currentRenderState );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, renderListStack.length );
			currentRenderList.init();

			renderListStack.push( currentRenderList );

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled === true ) clipping.beginShadows();

			const shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights();
			currentRenderState.setupLightsView( camera );

			if ( _clippingEnabled === true ) clipping.endShadows();

			//

			if ( this.info.autoReset === true ) this.info.reset();

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			const opaqueObjects = currentRenderList.opaque;
			const transparentObjects = currentRenderList.transparent;

			if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
			if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

			//

			if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			// _gl.finish();

			renderStateStack.pop();

			if ( renderStateStack.length > 0 ) {

				currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

			} else {

				currentRenderState = null;

			}

			renderListStack.pop();

			if ( renderListStack.length > 0 ) {

				currentRenderList = renderListStack[ renderListStack.length - 1 ];

			} else {

				currentRenderList = null;

			}

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			const visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isLight ) {

					currentRenderState.pushLight( object );

					if ( object.castShadow ) {

						currentRenderState.pushShadow( object );

					}

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || object.isLine || object.isPoints ) {

					if ( object.isSkinnedMesh ) {

						// update skeleton only once in a frame

						if ( object.skeleton.frame !== info.render.frame ) {

							object.skeleton.update();
							object.skeleton.frame = info.render.frame;

						}

					}

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						const geometry = objects.update( object );
						const material = object.material;

						if ( Array.isArray( material ) ) {

							const groups = geometry.groups;

							for ( let i = 0, l = groups.length; i < l; i ++ ) {

								const group = groups[ i ];
								const groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			const children = object.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera ) {

			const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

			for ( let i = 0, l = renderList.length; i < l; i ++ ) {

				const renderItem = renderList[ i ];

				const object = renderItem.object;
				const geometry = renderItem.geometry;
				const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
				const group = renderItem.group;

				if ( camera.isArrayCamera ) {

					const cameras = camera.cameras;

					for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

						const camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							state.viewport( _currentViewport.copy( camera2.viewport ) );

							currentRenderState.setupLightsView( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				const program = setProgram( camera, scene, material, object );

				state.setMaterial( material );

				bindingStates.reset();

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );

		}

		function initMaterial( material, scene, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			const materialProperties = properties.get( material );

			const lights = currentRenderState.state.lights;
			const shadowsArray = currentRenderState.state.shadowsArray;

			const lightsStateVersion = lights.state.version;

			const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
			const programCacheKey = programCache.getProgramCacheKey( parameters );

			let program = materialProperties.program;
			let programChange = true;

			// always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change

			materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
			materialProperties.fog = scene.fog;
			materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.cacheKey !== programCacheKey ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				parameters.uniforms = programCache.getUniforms( material );

				material.onBeforeCompile( parameters, _this );

				program = programCache.acquireProgram( parameters, programCacheKey );

				materialProperties.program = program;
				materialProperties.uniforms = parameters.uniforms;
				materialProperties.outputEncoding = parameters.outputEncoding;

			}

			const uniforms = materialProperties.uniforms;

			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {

				materialProperties.numClippingPlanes = clipping.numPlanes;
				materialProperties.numIntersection = clipping.numIntersection;
				uniforms.clippingPlanes = clipping.uniform;

			}

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.ltc_1.value = lights.state.rectAreaLTC1;
				uniforms.ltc_2.value = lights.state.rectAreaLTC2;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			const progUniforms = materialProperties.program.getUniforms();
			const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, scene, material, object ) {

			if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

			textures.resetTextureUnits();

			const fog = scene.fog;
			const environment = material.isMeshStandardMaterial ? scene.environment : null;
			const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
			const envMap = cubemaps.get( material.envMap || environment );

			const materialProperties = properties.get( material );
			const lights = currentRenderState.state.lights;

			if ( _clippingEnabled === true ) {

				if ( _localClippingEnabled === true || camera !== _currentCamera ) {

					const useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					clipping.setState( material, camera, useCache );

				}

			}

			if ( material.version === materialProperties.__version ) {

				if ( material.fog && materialProperties.fog !== fog ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.environment !== environment ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== clipping.numPlanes ||
					materialProperties.numIntersection !== clipping.numIntersection ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.outputEncoding !== encoding ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.envMap !== envMap ) {

					initMaterial( material, scene, object );

				}

			} else {

				initMaterial( material, scene, object );
				materialProperties.__version = material.version;

			}

			let refreshProgram = false;
			let refreshMaterial = false;
			let refreshLights = false;

			const program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {

					const uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( material.isMeshPhongMaterial ||
					material.isMeshToonMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.isShadowMaterial ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				const skeleton = object.skeleton;

				if ( skeleton ) {

					const bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === null ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = MathUtils.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					materials.refreshFogUniforms( m_uniforms, fog );

				}

				materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

			}

			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial || material.isShadowMaterial ||
				( material.isShaderMaterial && material.lights === true );

		}

		//
		this.setFramebuffer = function ( value ) {

			if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( _gl.FRAMEBUFFER, value );

			_framebuffer = value;

		};

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			let framebuffer = _framebuffer;
			let isCube = false;
			let isRenderTarget3D = false;

			if ( renderTarget ) {

				const texture = renderTarget.texture;

				if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

					isRenderTarget3D = true;

				}

				const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLCubeRenderTarget ) {

					framebuffer = __webglFramebuffer[ activeCubeFace ];
					isCube = true;

				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

			if ( isCube ) {

				const textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

			} else if ( isRenderTarget3D ) {

				const textureProperties = properties.get( renderTarget.texture );
				const layer = activeCubeFace || 0;
				_gl.framebufferTextureLayer( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

			}

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

				framebuffer = framebuffer[ activeCubeFaceIndex ];

			}

			if ( framebuffer ) {

				let restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

					restore = true;

				}

				try {

					const texture = renderTarget.texture;
					const textureFormat = texture.format;
					const textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! halfFloatSupportedByExt ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

			const levelScale = Math.pow( 2, - level );
			const width = Math.floor( texture.image.width * levelScale );
			const height = Math.floor( texture.image.height * levelScale );
			const glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( _gl.TEXTURE_2D, level, glFormat, position.x, position.y, width, height, 0 );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

			const width = srcTexture.image.width;
			const height = srcTexture.image.height;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			// As another texture upload may have changed pixelStorei
			// parameters, make sure they are correct for the dstTexture
			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				if ( srcTexture.isCompressedTexture ) {

					_gl.compressedTexSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

				} else {

					_gl.texSubImage2D( _gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image );

				}

			}

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( _gl.TEXTURE_2D );

			state.unbindTexture();

		};

		this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

			if ( _this.isWebGL1Renderer ) {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
				return;

			}

			const { width, height, data } = srcTexture.image;
			const glFormat = utils.convert( dstTexture.format );
			const glType = utils.convert( dstTexture.type );
			let glTarget;

			if ( dstTexture.isDataTexture3D ) {

				textures.setTexture3D( dstTexture, 0 );
				glTarget = _gl.TEXTURE_3D;

			} else if ( dstTexture.isDataTexture2DArray ) {

				textures.setTexture2DArray( dstTexture, 0 );
				glTarget = _gl.TEXTURE_2D_ARRAY;

			} else {

				console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
				return;

			}

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment );

			const unpackRowLen = _gl.getParameter( _gl.UNPACK_ROW_LENGTH );
			const unpackImageHeight = _gl.getParameter( _gl.UNPACK_IMAGE_HEIGHT );
			const unpackSkipPixels = _gl.getParameter( _gl.UNPACK_SKIP_PIXELS );
			const unpackSkipRows = _gl.getParameter( _gl.UNPACK_SKIP_ROWS );
			const unpackSkipImages = _gl.getParameter( _gl.UNPACK_SKIP_IMAGES );

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, width );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, height );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, sourceBox.min.x );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, sourceBox.min.y );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, sourceBox.min.z );

			_gl.texSubImage3D(
				glTarget,
				level,
				position.x,
				position.y,
				position.z,
				sourceBox.max.x - sourceBox.min.x + 1,
				sourceBox.max.y - sourceBox.min.y + 1,
				sourceBox.max.z - sourceBox.min.z + 1,
				glFormat,
				glType,
				data
			);

			_gl.pixelStorei( _gl.UNPACK_ROW_LENGTH, unpackRowLen );
			_gl.pixelStorei( _gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight );
			_gl.pixelStorei( _gl.UNPACK_SKIP_PIXELS, unpackSkipPixels );
			_gl.pixelStorei( _gl.UNPACK_SKIP_ROWS, unpackSkipRows );
			_gl.pixelStorei( _gl.UNPACK_SKIP_IMAGES, unpackSkipImages );

			// Generate mipmaps only when copying level 0
			if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			textures.setTexture2D( texture, 0 );

			state.unbindTexture();

		};

		this.resetState = function () {

			state.reset();
			bindingStates.reset();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	/* global QUnit */

	//
	// HELPERS
	//

	function testEdges( vertList, idxList, numAfter, assert ) {

		var geoms = createGeometries( vertList, idxList );

		for ( var i = 0; i < geoms.length; i ++ ) {

			var geom = geoms[ i ];

			var numBefore = idxList.length;
			assert.equal( countEdges( geom ), numBefore, "Edges before!" );

			var egeom = new EdgesGeometry( geom );

			assert.equal( countEdges( egeom ), numAfter, "Edges after!" );

		}

	}

	function createGeometries( vertList, idxList ) {

		var geomIB = createIndexedBufferGeometry( vertList, idxList );
		var geomDC = addDrawCalls( geomIB.clone() );
		return [ geomIB, geomDC ];

	}

	function createIndexedBufferGeometry( vertList, idxList ) {

		var geom = new BufferGeometry();

		var indexTable = [];
		var numTris = idxList.length / 3;
		var numVerts = 0;

		var indices = new Uint32Array( numTris * 3 );
		var vertices = new Float32Array( vertList.length * 3 );

		for ( var i = 0; i < numTris; i ++ ) {

			for ( var j = 0; j < 3; j ++ ) {

				var idx = idxList[ 3 * i + j ];
				if ( indexTable[ idx ] === undefined ) {

					var v = vertList[ idx ];
					vertices[ 3 * numVerts ] = v.x;
					vertices[ 3 * numVerts + 1 ] = v.y;
					vertices[ 3 * numVerts + 2 ] = v.z;

					indexTable[ idx ] = numVerts;

					numVerts ++;

				}

				indices[ 3 * i + j ] = indexTable[ idx ];

			}

		}

		vertices = vertices.subarray( 0, 3 * numVerts );

		geom.setIndex( new BufferAttribute( indices, 1 ) );
		geom.setAttribute( 'position', new BufferAttribute( vertices, 3 ) );

		geom.computeFaceNormals();

		return geom;

	}

	function addDrawCalls( geometry ) {

		var numTris = geometry.index.count / 3;

		for ( var i = 0; i < numTris; i ++ ) {

			var start = i * 3;
			var count = 3;

			geometry.addGroup( start, count );

		}

		return geometry;

	}

	function countEdges( geom ) {

		if ( geom instanceof EdgesGeometry ) {

			return geom.getAttribute( 'position' ).count / 2;

		}

		if ( geom.faces !== undefined ) {

			return geom.faces.length * 3;

		}

		var indices = geom.index;
		if ( indices ) {

			return indices.count;

		}

		return geom.getAttribute( 'position' ).count;

	}
	new Scene();

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'EdgesGeometry', () => {

			var vertList = [
				new Vector3( 0, 0, 0 ),
				new Vector3( 1, 0, 0 ),
				new Vector3( 1, 1, 0 ),
				new Vector3( 0, 1, 0 ),
				new Vector3( 1, 1, 1 ),
			];

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( "singularity", ( assert ) => {

				testEdges( vertList, [ 1, 1, 1 ], 0, assert );

			} );

			QUnit.test( "needle", ( assert ) => {

				testEdges( vertList, [ 0, 0, 1 ], 0, assert );

			} );

			QUnit.test( "single triangle", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2 ], 3, assert );

			} );

			QUnit.test( "two isolated triangles", ( assert ) => {

				var vertList = [
					new Vector3( 0, 0, 0 ),
					new Vector3( 1, 0, 0 ),
					new Vector3( 1, 1, 0 ),
					new Vector3( 0, 0, 1 ),
					new Vector3( 1, 0, 1 ),
					new Vector3( 1, 1, 1 ),
				];

				testEdges( vertList, [ 0, 1, 2, 3, 4, 5 ], 6, assert );

			} );

			QUnit.test( "two flat triangles", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2, 0, 2, 3 ], 4, assert );

			} );

			QUnit.test( "two flat triangles, inverted", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2, 0, 3, 2 ], 5, assert );

			} );

			QUnit.test( "two non-coplanar triangles", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2, 0, 4, 2 ], 5, assert );

			} );

			QUnit.test( "three triangles, coplanar first", ( assert ) => {

				testEdges( vertList, [ 0, 2, 3, 0, 1, 2, 0, 4, 2 ], 7, assert );

			} );

			QUnit.test( "three triangles, coplanar last", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2, 0, 4, 2, 0, 2, 3 ], 6, assert ); // Should be 7

			} );

			QUnit.test( "tetrahedron", ( assert ) => {

				testEdges( vertList, [ 0, 1, 2, 0, 1, 4, 0, 4, 2, 1, 2, 4 ], 6, assert );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'ExtrudeGeometry', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'IcosahedronGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					detail: undefined
				};

				geometries = [
					new IcosahedronGeometry(),
					new IcosahedronGeometry( parameters.radius ),
					new IcosahedronGeometry( parameters.radius, parameters.detail ),
					new IcosahedronGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'LatheGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					points: [],
					segments: 0,
					phiStart: 0,
					phiLength: 0
				};

				geometries = [
					new LatheGeometry( parameters.points ),
					new LatheGeometry( parameters.points ),
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'OctahedronGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					detail: undefined
				};

				geometries = [
					new OctahedronGeometry(),
					new OctahedronGeometry( parameters.radius ),
					new OctahedronGeometry( parameters.radius, parameters.detail ),
					new OctahedronGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'ParametricGeometry', ( hooks ) => {
			hooks.beforeEach( function () {

				[
					new ParametricGeometry(),
					new ParametricGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.todo( 'Standard geometry tests', ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'PlaneGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					width: 10,
					height: 30,
					widthSegments: 3,
					heightSegments: 5
				};

				geometries = [
					new PlaneGeometry(),
					new PlaneGeometry( parameters.width ),
					new PlaneGeometry( parameters.width, parameters.height ),
					new PlaneGeometry( parameters.width, parameters.height, parameters.widthSegments ),
					new PlaneGeometry( parameters.width, parameters.height, parameters.widthSegments, parameters.heightSegments ),
					new PlaneGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'PolyhedronGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				var vertices = [
					1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
				];

				var indices = [
					2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
				];

				geometries = [
					new PolyhedronGeometry( vertices, indices ),
					new PolyhedronGeometry( vertices, indices )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'RingGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					innerRadius: 10,
					outerRadius: 60,
					thetaSegments: 12,
					phiSegments: 14,
					thetaStart: 0.1,
					thetaLength: 2.0
				};

				geometries = [
					new RingGeometry(),
					new RingGeometry( parameters.innerRadius ),
					new RingGeometry( parameters.innerRadius, parameters.outerRadius ),
					new RingGeometry( parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments ),
					new RingGeometry( parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments ),
					new RingGeometry( parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments, parameters.thetaStart ),
					new RingGeometry( parameters.innerRadius, parameters.outerRadius, parameters.thetaSegments, parameters.phiSegments, parameters.thetaStart, parameters.thetaLength ),
					new RingGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'ShapeGeometry', ( hooks ) => {
			hooks.beforeEach( function () {

				var triangleShape = new Shape();
				triangleShape.moveTo( 0, - 1 );
				triangleShape.lineTo( 1, 1 );
				triangleShape.lineTo( - 1, 1 );

				[
					new ShapeGeometry( triangleShape ),
					new ShapeGeometry( triangleShape )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.todo( 'Standard geometry tests', ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'SphereGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					widthSegments: 20,
					heightSegments: 30,
					phiStart: 0.5,
					phiLength: 1.0,
					thetaStart: 0.4,
					thetaLength: 2.0,
				};

				geometries = [
					new SphereGeometry(),
					new SphereGeometry( parameters.radius ),
					new SphereGeometry( parameters.radius, parameters.widthSegments ),
					new SphereGeometry( parameters.radius, parameters.widthSegments, parameters.heightSegments ),
					new SphereGeometry( parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart ),
					new SphereGeometry( parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength ),
					new SphereGeometry( parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart ),
					new SphereGeometry( parameters.radius, parameters.widthSegments, parameters.heightSegments, parameters.phiStart, parameters.phiLength, parameters.thetaStart, parameters.thetaLength ),
					new SphereGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'TetrahedronGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					detail: undefined
				};

				geometries = [
					new TetrahedronGeometry(),
					new TetrahedronGeometry( parameters.radius ),
					new TetrahedronGeometry( parameters.radius, parameters.detail ),
					new TetrahedronGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'TextGeometry', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.todo( 'Standard geometry tests', ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'TorusBufferGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					tube: 20,
					radialSegments: 30,
					tubularSegments: 10,
					arc: 2.0,
				};

				geometries = [
					new TorusGeometry(),
					new TorusGeometry( parameters.radius ),
					new TorusGeometry( parameters.radius, parameters.tube ),
					new TorusGeometry( parameters.radius, parameters.tube, parameters.radialSegments ),
					new TorusGeometry( parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments ),
					new TorusGeometry( parameters.radius, parameters.tube, parameters.radialSegments, parameters.tubularSegments, parameters.arc ),
					new TorusGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'TorusKnotGeometry', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					radius: 10,
					tube: 20,
					tubularSegments: 30,
					radialSegments: 10,
					p: 3,
					q: 2
				};

				geometries = [
					new TorusKnotGeometry(),
					new TorusKnotGeometry( parameters.radius ),
					new TorusKnotGeometry( parameters.radius, parameters.tube ),
					new TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments ),
					new TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments, parameters.radialSegments ),
					new TorusKnotGeometry( parameters.radius, parameters.tube, parameters.tubularSegments, parameters.radialSegments, parameters.p, parameters.q ),
					new TorusKnotGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'TubeGeometry', ( hooks ) => {
			hooks.beforeEach( function () {

				var path = new LineCurve3( new Vector3( 0, 0, 0 ), new Vector3( 0, 1, 0 ) );

				[
					new TubeGeometry( path ),
					new TubeGeometry( path )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.todo( 'Standard geometry tests', ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Geometries', () => {

		QUnit.module( 'WireframeGeometry', ( hooks ) => {
			hooks.beforeEach( function () {

				[
					new WireframeGeometry()
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.todo( 'Standard geometry tests', ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'ArrowHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "setDirection", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setColor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'AxesHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'Box3Helper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	const _box$3 = /*@__PURE__*/ new Box3();

	class BoxHelper extends LineSegments {

		constructor( object, color = 0xffff00 ) {

			const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			const positions = new Float32Array( 8 * 3 );

			const geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

			super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

			this.object = object;
			this.type = 'BoxHelper';

			this.matrixAutoUpdate = false;

			this.update();

		}

		update( object ) {

			if ( object !== undefined ) {

				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

			}

			if ( this.object !== undefined ) {

				_box$3.setFromObject( this.object );

			}

			if ( _box$3.isEmpty() ) return;

			const min = _box$3.min;
			const max = _box$3.max;

			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/

			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/

			const position = this.geometry.attributes.position;
			const array = position.array;

			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

			position.needsUpdate = true;

			this.geometry.computeBoundingSphere();


		}

		setFromObject( object ) {

			this.object = object;
			this.update();

			return this;

		}

		copy( source ) {

			LineSegments.prototype.copy.call( this, source );

			this.object = source.object;

			return this;

		}

	}

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'BoxHelper', ( hooks ) => {

			var geometries = undefined;
			hooks.beforeEach( function () {

				// Test with a normal cube and a box helper
				var boxGeometry = new BoxGeometry();
				var box = new Mesh( boxGeometry );
				var boxHelper = new BoxHelper( box );

				// The same should happen with a comparable sphere
				var sphereGeometry = new SphereGeometry();
				var sphere = new Mesh( sphereGeometry );
				var sphereBoxHelper = new BoxHelper( sphere );

				// Note that unlike what I'd like to, these doesn't check the equivalency of the two generated geometries
				geometries = [ boxHelper.geometry, sphereBoxHelper.geometry ];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setFromObject", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard geometry tests', ( assert ) => {

				runStdGeometryTests( assert, geometries );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'CameraHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'DirectionalLightHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'GridHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'HemisphereLightHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'PlaneHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'PointLightHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'PolarGridHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'SkeletonHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Helpers', () => {

		QUnit.module( 'SpotLightHelper', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'ArrowHelper', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.5
				};

				lights = [
					new AmbientLight(),
					new AmbientLight( parameters.color ),
					new AmbientLight( parameters.color, parameters.intensity )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isAmbiantLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'DirectionalLight', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.8
				};

				lights = [
					new DirectionalLight(),
					new DirectionalLight( parameters.color ),
					new DirectionalLight( parameters.color, parameters.intensity )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isDirectionalLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'DirectionalLightShadow', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( "clone/copy", ( assert ) => {

				var a = new DirectionalLightShadow();
				var b = new DirectionalLightShadow();
				var c;

				assert.notDeepEqual( a, b, "Newly instanced shadows are not equal" );

				c = a.clone();
				assert.smartEqual( a, c, "Shadows are identical after clone()" );

				c.mapSize.set( 1024, 1024 );
				assert.notDeepEqual( a, c, "Shadows are different again after change" );

				b.copy( a );
				assert.smartEqual( a, b, "Shadows are identical after copy()" );

				b.mapSize.set( 512, 512 );
				assert.notDeepEqual( a, b, "Shadows are different again after change" );

			} );

			QUnit.test( "toJSON", ( assert ) => {

				var light = new DirectionalLight();
				var shadow = new DirectionalLightShadow();

				shadow.bias = 10;
				shadow.radius = 5;
				shadow.mapSize.set( 1024, 1024 );
				light.shadow = shadow;

				var json = light.toJSON();
				var newLight = new ObjectLoader().parse( json );

				assert.smartEqual( newLight.shadow, light.shadow, "Reloaded shadow is identical to the original one" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'HemisphereLight', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					skyColor: 0x123456,
					groundColor: 0xabc012,
					intensity: 0.6
				};

				lights = [
					new HemisphereLight(),
					new HemisphereLight( parameters.skyColor ),
					new HemisphereLight( parameters.skyColor, parameters.groundColor ),
					new HemisphereLight( parameters.skyColor, parameters.groundColor, parameters.intensity ),
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isHemisphereLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'Light', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.5
				};

				lights = [
					new Light(),
					new Light( parameters.color ),
					new Light( parameters.color, parameters.intensity )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'LightShadow', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "clone/copy", ( assert ) => {

				var a = new LightShadow( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
				var b = new LightShadow( new OrthographicCamera( - 3, 3, 3, - 3, 0.3, 300 ) );
				var c;

				assert.notDeepEqual( a, b, "Newly instanced shadows are not equal" );

				c = a.clone();
				assert.smartEqual( a, c, "Shadows are identical after clone()" );

				c.mapSize.set( 256, 256 );
				assert.notDeepEqual( a, c, "Shadows are different again after change" );

				b.copy( a );
				assert.smartEqual( a, b, "Shadows are identical after copy()" );

				b.mapSize.set( 512, 512 );
				assert.notDeepEqual( a, b, "Shadows are different again after change" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'PointLight', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.5,
					distance: 100,
					decay: 2
				};

				lights = [
					new PointLight(),
					new PointLight( parameters.color ),
					new PointLight( parameters.color, parameters.intensity ),
					new PointLight( parameters.color, parameters.intensity, parameters.distance ),
					new PointLight( parameters.color, parameters.intensity, parameters.distance, parameters.decay )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.test( "power", ( assert ) => {

				var a = new PointLight( 0xaaaaaa );

				a.intensity = 100;
				assert.numEqual( a.power, 100 * Math.PI * 4, "Correct power for an intensity of 100" );

				a.intensity = 40;
				assert.numEqual( a.power, 40 * Math.PI * 4, "Correct power for an intensity of 40" );

				a.power = 100;
				assert.numEqual( a.intensity, 100 / ( 4 * Math.PI ), "Correct intensity for a power of 100" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isPointLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'RectAreaLight', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.5,
					width: 100,
					height: 50
				};

				lights = [
					new RectAreaLight( parameters.color ),
					new RectAreaLight( parameters.color, parameters.intensity ),
					new RectAreaLight( parameters.color, parameters.intensity, parameters.width ),
					new RectAreaLight( parameters.color, parameters.intensity, parameters.width, parameters.height )
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isRectAreaLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'SpotLight', ( hooks ) => {

			var lights = undefined;
			hooks.beforeEach( function () {

				const parameters = {
					color: 0xaaaaaa,
					intensity: 0.5,
					distance: 100,
					angle: 0.8,
					penumbra: 8,
					decay: 2
				};

				lights = [
					new SpotLight( parameters.color ),
					new SpotLight( parameters.color, parameters.intensity ),
					new SpotLight( parameters.color, parameters.intensity, parameters.distance ),
					new SpotLight( parameters.color, parameters.intensity, parameters.distance, parameters.angle ),
					new SpotLight( parameters.color, parameters.intensity, parameters.distance, parameters.angle, parameters.penumbra ),
					new SpotLight( parameters.color, parameters.intensity, parameters.distance, parameters.angle, parameters.penumbra, parameters.decay ),
				];

			} );

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.test( "power", ( assert ) => {

				var a = new SpotLight( 0xaaaaaa );

				a.intensity = 100;
				assert.numEqual( a.power, 100 * Math.PI, "Correct power for an intensity of 100" );

				a.intensity = 40;
				assert.numEqual( a.power, 40 * Math.PI, "Correct power for an intensity of 40" );

				a.power = 100;
				assert.numEqual( a.intensity, 100 / Math.PI, "Correct intensity for a power of 100" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSpotLight", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( 'Standard light tests', ( assert ) => {

				runStdLightTests( assert, lights );

			} );



		} );

	} );

	/* global QUnit */

	QUnit.module( 'Lights', () => {

		QUnit.module( 'SpotLightShadow', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSpotLightShadow", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// OTHERS
			QUnit.test( "clone/copy", ( assert ) => {

				var a = new SpotLightShadow();
				var b = new SpotLightShadow();
				var c;

				assert.notDeepEqual( a, b, "Newly instanced shadows are not equal" );

				c = a.clone();
				assert.smartEqual( a, c, "Shadows are identical after clone()" );

				c.mapSize.set( 256, 256 );
				assert.notDeepEqual( a, c, "Shadows are different again after change" );

				b.copy( a );
				assert.smartEqual( a, b, "Shadows are identical after copy()" );

				b.mapSize.set( 512, 512 );
				assert.notDeepEqual( a, b, "Shadows are different again after change" );

			} );

			QUnit.test( "toJSON", ( assert ) => {

				var light = new SpotLight();
				var shadow = new SpotLightShadow();

				shadow.bias = 10;
				shadow.radius = 5;
				shadow.mapSize.set( 128, 128 );
				light.shadow = shadow;

				var json = light.toJSON();
				var newLight = new ObjectLoader().parse( json );

				assert.smartEqual( newLight.shadow, light.shadow, "Reloaded shadow is equal to the original one" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'AnimationLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'AudioLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'BufferGeometryLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'Cache', () => {

			// PUBLIC STUFF
			QUnit.todo( "add", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "get", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "remove", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clear", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	class CompressedTexture extends Texture {

		constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

			super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;

			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )

			this.flipY = false;

			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files

			this.generateMipmaps = false;

		}

	}

	CompressedTexture.prototype.isCompressedTexture = true;

	/**
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function CompressedTextureLoader( manager ) {

		Loader.call( this, manager );

	}

	CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			const scope = this;

			const images = [];

			const texture = new CompressedTexture();

			const loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setWithCredentials( scope.withCredentials );

			let loaded = 0;

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					const texDatas = scope.parse( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

						texture.image = images;
						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				for ( let i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					const texDatas = scope.parse( buffer, true );

					if ( texDatas.isCubemap ) {

						const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( let f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

						texture.image = images;

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		}

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'CompressedTextureLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'CubeTextureLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setCrossOrigin", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/**
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function DataTextureLoader( manager ) {

		Loader.call( this, manager );

	}

	DataTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: DataTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			const scope = this;

			const texture = new DataTexture();

			const loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setRequestHeader( this.requestHeader );
			loader.setPath( this.path );
			loader.setWithCredentials( scope.withCredentials );
			loader.load( url, function ( buffer ) {

				const texData = scope.parse( buffer );

				if ( ! texData ) return;

				if ( texData.image !== undefined ) {

					texture.image = texData.image;

				} else if ( texData.data !== undefined ) {

					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;

				}

				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

				if ( texData.encoding !== undefined ) {

					texture.encoding = texData.encoding;

				}

				if ( texData.flipY !== undefined ) {

					texture.flipY = texData.flipY;

				}

				if ( texData.format !== undefined ) {

					texture.format = texData.format;

				}

				if ( texData.type !== undefined ) {

					texture.type = texData.type;

				}

				if ( texData.mipmaps !== undefined ) {

					texture.mipmaps = texData.mipmaps;
					texture.minFilter = LinearMipmapLinearFilter; // presumably...

				}

				if ( texData.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture, texData );

			}, onProgress, onError );


			return texture;

		}

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'DataTextureLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'FileLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setResponseType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setWithCredentials", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setMimeType", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setRequestHeader", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'FontLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'ImageLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setCrossOrigin", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'Loader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'LoaderUtils', () => {

			// INSTANCING
			QUnit.test( 'decodeText', ( assert ) => {

				var jsonArray = new Uint8Array( [ 123, 34, 106, 115, 111, 110, 34, 58, 32, 116, 114, 117, 101, 125 ] );
				assert.equal( '{"json": true}', LoaderUtils.decodeText( jsonArray ) );

				var multibyteArray = new Uint8Array( [ 230, 151, 165, 230, 156, 172, 229, 155, 189 ] );
				assert.equal( '', LoaderUtils.decodeText( multibyteArray ) );

			} );

			QUnit.test( 'extractUrlBase', ( assert ) => {

				assert.equal( '/path/to/', LoaderUtils.extractUrlBase( '/path/to/model.glb' ) );
				assert.equal( './', LoaderUtils.extractUrlBase( 'model.glb' ) );
				assert.equal( '/', LoaderUtils.extractUrlBase( '/model.glb' ) );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'LoadingManager', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "onStart", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onLoad", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onProgress", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onError", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "itemStart", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "itemEnd", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "itemError", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "getHandler", ( assert ) => {

				const loadingManager = new LoadingManager();
				const loader = new Loader();

				const regex1 = /\.jpg$/i;
				const regex2 = /\.jpg$/gi;

				loadingManager.addHandler( regex1, loader );

				assert.equal( loadingManager.getHandler( 'foo.jpg' ), loader, 'Returns the expected loader.' );
				assert.equal( loadingManager.getHandler( 'foo.jpg.png' ), null, 'Returns null since the correct file extension is not at the end of the file name.' );
				assert.equal( loadingManager.getHandler( 'foo.jpeg' ), null, 'Returns null since file extension is wrong.' );

				loadingManager.removeHandler( regex1 );
				loadingManager.addHandler( regex2, loader );

				assert.equal( loadingManager.getHandler( 'foo.jpg' ), loader, 'Returns the expected loader when using a regex with "g" flag.' );
				assert.equal( loadingManager.getHandler( 'foo.jpg' ), loader, 'Returns the expected loader when using a regex with "g" flag. Test twice, see #17920.' );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'MaterialLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setTextures", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'ObjectLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setTexturePath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setCrossOrigin", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parse", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseGeometries", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseMaterials", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseAnimations", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseImages", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseTextures", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "parseObject", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	function TextureLoader( manager ) {

		Loader.call( this, manager );

	}

	TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			const texture = new Texture();

			const loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	} );

	/* global QUnit */

	QUnit.module( 'Loaders', () => {

		QUnit.module( 'TextureLoader', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "load", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setCrossOrigin", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setPath", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'LineBasicMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLineBasicMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'LineDashedMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLineDashedMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'Material', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "onBeforeCompile", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setValues", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshBasicMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshBasicMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshDepthMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshDepthMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshDistanceMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshDistanceMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshLambertMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshLambertMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshNormalMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshNormalMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshPhongMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshPhongMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshPhysicalMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshPhysicalMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshStandardMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshStandardMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'MeshToonMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMeshToonMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'PointsMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isPointsMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'RawShaderMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isRawShaderMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'ShaderMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isShaderwMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'LineBasicMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isShadowMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Materials', () => {

		QUnit.module( 'SpriteMaterial', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSpriteMaterial", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	const _vector$8 = /*@__PURE__*/ new Vector2();

	class Box2 {

		constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

			this.min = min;
			this.max = max;

		}

		set( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		}

		setFromPoints( points ) {

			this.makeEmpty();

			for ( let i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		}

		setFromCenterAndSize( center, size ) {

			const halfSize = _vector$8.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

		copy( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		}

		makeEmpty() {

			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;

			return this;

		}

		isEmpty() {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		}

		getSize( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();

			}

			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

		}

		expandByPoint( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		}

		expandByVector( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		}

		expandByScalar( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		}

		containsPoint( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;

		}

		containsBox( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;

		}

		getParameter( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);

		}

		intersectsBox( box ) {

			// using 4 splitting planes to rule out intersections

			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

		}

		clampPoint( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();

			}

			return target.copy( point ).clamp( this.min, this.max );

		}

		distanceToPoint( point ) {

			const clampedPoint = _vector$8.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		}

		intersect( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			return this;

		}

		union( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		}

		translate( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		}

		equals( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	}

	Box2.prototype.isBox2 = true;

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Box2', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Box2();
				assert.ok( a.min.equals( posInf2 ), "Passed!" );
				assert.ok( a.max.equals( negInf2 ), "Passed!" );

				var a = new Box2( zero2.clone(), zero2.clone() );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( zero2 ), "Passed!" );

				var a = new Box2( zero2.clone(), one2.clone() );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( one2 ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Box2();

				a.set( zero2, one2 );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( one2 ), "Passed!" );

			} );

			QUnit.test( "setFromPoints", ( assert ) => {

				var a = new Box2();

				a.setFromPoints( [ zero2, one2, two2 ] );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( two2 ), "Passed!" );

				a.setFromPoints( [ one2 ] );
				assert.ok( a.min.equals( one2 ), "Passed!" );
				assert.ok( a.max.equals( one2 ), "Passed!" );

				a.setFromPoints( [] );
				assert.ok( a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "setFromCenterAndSize", ( assert ) => {

				var a = new Box2();

				a.setFromCenterAndSize( zero2, two2 );
				assert.ok( a.min.equals( negOne2 ), "Passed!" );
				assert.ok( a.max.equals( one2 ), "Passed!" );

				a.setFromCenterAndSize( one2, two2 );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( two2 ), "Passed!" );

				a.setFromCenterAndSize( zero2, zero2 );
				assert.ok( a.min.equals( zero2 ), "Passed!" );
				assert.ok( a.max.equals( zero2 ), "Passed!" );

			} );

			QUnit.test( "clone", ( assert ) => {


				var a = new Box2( zero2, zero2 );

				var b = a.clone();
				assert.ok( b.min.equals( zero2 ), "Passed!" );
				assert.ok( b.max.equals( zero2 ), "Passed!" );

				a = new Box2();
				var b = a.clone();
				assert.ok( b.min.equals( posInf2 ), "Passed!" );
				assert.ok( b.max.equals( negInf2 ), "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Box2( zero2.clone(), one2.clone() );
				var b = new Box2().copy( a );
				assert.ok( b.min.equals( zero2 ), "Passed!" );
				assert.ok( b.max.equals( one2 ), "Passed!" );

				// ensure that it is a true copy
				a.min = zero2;
				a.max = one2;
				assert.ok( b.min.equals( zero2 ), "Passed!" );
				assert.ok( b.max.equals( one2 ), "Passed!" );

			} );

			QUnit.test( "empty/makeEmpty", ( assert ) => {

				var a = new Box2();

				assert.ok( a.isEmpty(), "Passed!" );

				var a = new Box2( zero2.clone(), one2.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				a.makeEmpty();
				assert.ok( a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "isEmpty", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				var a = new Box2( zero2.clone(), one2.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				var a = new Box2( two2.clone(), one2.clone() );
				assert.ok( a.isEmpty(), "Passed!" );

				var a = new Box2( posInf2.clone(), negInf2.clone() );
				assert.ok( a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "getCenter", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var center = new Vector2();
				assert.ok( a.getCenter( center ).equals( zero2 ), "Passed!" );

				var a = new Box2( zero2, one2 );
				var midpoint = one2.clone().multiplyScalar( 0.5 );
				assert.ok( a.getCenter( center ).equals( midpoint ), "Passed!" );

			} );

			QUnit.test( "getSize", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var size = new Vector2();

				assert.ok( a.getSize( size ).equals( zero2 ), "Passed!" );

				var a = new Box2( zero2.clone(), one2.clone() );
				assert.ok( a.getSize( size ).equals( one2 ), "Passed!" );

			} );

			QUnit.test( "expandByPoint", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var size = new Vector2();
				var center = new Vector2();

				a.expandByPoint( zero2 );
				assert.ok( a.getSize( size ).equals( zero2 ), "Passed!" );

				a.expandByPoint( one2 );
				assert.ok( a.getSize( size ).equals( one2 ), "Passed!" );

				a.expandByPoint( one2.clone().negate() );
				assert.ok( a.getSize( size ).equals( one2.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero2 ), "Passed!" );

			} );

			QUnit.test( "expandByVector", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var size = new Vector2();
				var center = new Vector2();

				a.expandByVector( zero2 );
				assert.ok( a.getSize( size ).equals( zero2 ), "Passed!" );

				a.expandByVector( one2 );
				assert.ok( a.getSize( size ).equals( one2.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero2 ), "Passed!" );

			} );

			QUnit.test( "expandByScalar", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var size = new Vector2();
				var center = new Vector2();

				a.expandByScalar( 0 );
				assert.ok( a.getSize( size ).equals( zero2 ), "Passed!" );

				a.expandByScalar( 1 );
				assert.ok( a.getSize( size ).equals( one2.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero2 ), "Passed!" );

			} );

			QUnit.test( "containsPoint", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );

				assert.ok( a.containsPoint( zero2 ), "Passed!" );
				assert.ok( ! a.containsPoint( one2 ), "Passed!" );

				a.expandByScalar( 1 );
				assert.ok( a.containsPoint( zero2 ), "Passed!" );
				assert.ok( a.containsPoint( one2 ), "Passed!" );
				assert.ok( a.containsPoint( one2.clone().negate() ), "Passed!" );

			} );

			QUnit.test( "containsBox", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( zero2.clone(), one2.clone() );
				var c = new Box2( one2.clone().negate(), one2.clone() );

				assert.ok( a.containsBox( a ), "Passed!" );
				assert.ok( ! a.containsBox( b ), "Passed!" );
				assert.ok( ! a.containsBox( c ), "Passed!" );

				assert.ok( b.containsBox( a ), "Passed!" );
				assert.ok( c.containsBox( a ), "Passed!" );
				assert.ok( ! b.containsBox( c ), "Passed!" );

			} );

			QUnit.test( "getParameter", ( assert ) => {

				var a = new Box2( zero2.clone(), one2.clone() );
				var b = new Box2( one2.clone().negate(), one2.clone() );

				var parameter = new Vector2();

				a.getParameter( zero2, parameter );
				assert.ok( parameter.equals( zero2 ), "Passed!" );
				a.getParameter( one2, parameter );
				assert.ok( parameter.equals( one2 ), "Passed!" );

				b.getParameter( one2.clone().negate(), parameter );
				assert.ok( parameter.equals( zero2 ), "Passed!" );
				b.getParameter( zero2, parameter );
				assert.ok( parameter.equals( new Vector2( 0.5, 0.5 ) ), "Passed!" );
				b.getParameter( one2, parameter );
				assert.ok( parameter.equals( one2 ), "Passed!" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( zero2.clone(), one2.clone() );
				var c = new Box2( one2.clone().negate(), one2.clone() );

				assert.ok( a.intersectsBox( a ), "Passed!" );
				assert.ok( a.intersectsBox( b ), "Passed!" );
				assert.ok( a.intersectsBox( c ), "Passed!" );

				assert.ok( b.intersectsBox( a ), "Passed!" );
				assert.ok( c.intersectsBox( a ), "Passed!" );
				assert.ok( b.intersectsBox( c ), "Passed!" );

				b.translate( two2 );
				assert.ok( ! a.intersectsBox( b ), "Passed!" );
				assert.ok( ! b.intersectsBox( a ), "Passed!" );
				assert.ok( ! b.intersectsBox( c ), "Passed!" );

			} );

			QUnit.test( "clampPoint", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( one2.clone().negate(), one2.clone() );

				var point = new Vector2();

				a.clampPoint( zero2, point );
				assert.ok( point.equals( new Vector2( 0, 0 ) ), "Passed!" );
				a.clampPoint( one2, point );
				assert.ok( point.equals( new Vector2( 0, 0 ) ), "Passed!" );
				a.clampPoint( one2.clone().negate(), point );
				assert.ok( point.equals( new Vector2( 0, 0 ) ), "Passed!" );

				b.clampPoint( two2, point );
				assert.ok( point.equals( new Vector2( 1, 1 ) ), "Passed!" );
				b.clampPoint( one2, point );
				assert.ok( point.equals( new Vector2( 1, 1 ) ), "Passed!" );
				b.clampPoint( zero2, point );
				assert.ok( point.equals( new Vector2( 0, 0 ) ), "Passed!" );
				b.clampPoint( one2.clone().negate(), point );
				assert.ok( point.equals( new Vector2( - 1, - 1 ) ), "Passed!" );
				b.clampPoint( two2.clone().negate(), point );
				assert.ok( point.equals( new Vector2( - 1, - 1 ) ), "Passed!" );

			} );

			QUnit.test( "distanceToPoint", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( one2.clone().negate(), one2.clone() );

				assert.ok( a.distanceToPoint( new Vector2( 0, 0 ) ) == 0, "Passed!" );
				assert.ok( a.distanceToPoint( new Vector2( 1, 1 ) ) == Math.sqrt( 2 ), "Passed!" );
				assert.ok( a.distanceToPoint( new Vector2( - 1, - 1 ) ) == Math.sqrt( 2 ), "Passed!" );

				assert.ok( b.distanceToPoint( new Vector2( 2, 2 ) ) == Math.sqrt( 2 ), "Passed!" );
				assert.ok( b.distanceToPoint( new Vector2( 1, 1 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector2( 0, 0 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector2( - 1, - 1 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector2( - 2, - 2 ) ) == Math.sqrt( 2 ), "Passed!" );

			} );

			QUnit.test( "intersect", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( zero2.clone(), one2.clone() );
				var c = new Box2( one2.clone().negate(), one2.clone() );

				assert.ok( a.clone().intersect( a ).equals( a ), "Passed!" );
				assert.ok( a.clone().intersect( b ).equals( a ), "Passed!" );
				assert.ok( b.clone().intersect( b ).equals( b ), "Passed!" );
				assert.ok( a.clone().intersect( c ).equals( a ), "Passed!" );
				assert.ok( b.clone().intersect( c ).equals( b ), "Passed!" );
				assert.ok( c.clone().intersect( c ).equals( c ), "Passed!" );

			} );

			QUnit.test( "union", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( zero2.clone(), one2.clone() );
				var c = new Box2( one2.clone().negate(), one2.clone() );

				assert.ok( a.clone().union( a ).equals( a ), "Passed!" );
				assert.ok( a.clone().union( b ).equals( b ), "Passed!" );
				assert.ok( a.clone().union( c ).equals( c ), "Passed!" );
				assert.ok( b.clone().union( c ).equals( c ), "Passed!" );

			} );

			QUnit.test( "translate", ( assert ) => {

				var a = new Box2( zero2.clone(), zero2.clone() );
				var b = new Box2( zero2.clone(), one2.clone() );
				new Box2( one2.clone().negate(), one2.clone() );
				var d = new Box2( one2.clone().negate(), zero2.clone() );

				assert.ok( a.clone().translate( one2 ).equals( new Box2( one2, one2 ) ), "Passed!" );
				assert.ok( a.clone().translate( one2 ).translate( one2.clone().negate() ).equals( a ), "Passed!" );
				assert.ok( d.clone().translate( one2 ).equals( b ), "Passed!" );
				assert.ok( b.clone().translate( one2.clone().negate() ).equals( d ), "Passed!" );

			} );

			QUnit.test( "equals", ( assert ) => {


				var a = new Box2();
				var b = new Box2();
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box2( one2, two2 );
				b = new Box2( one2, two2 );
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box2( one2, two2 );
				b = a.clone();
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box2( one2, two2 );
				b = new Box2( one2, one2 );
				assert.ok( ! b.equals( a ), "Passed!" );
				assert.ok( ! a.equals( b ), "Passed!" );

				a = new Box2();
				b = new Box2( one2, one2 );
				assert.ok( ! b.equals( a ), "Passed!" );
				assert.ok( ! a.equals( b ), "Passed!" );

				a = new Box2( one2, two2 );
				b = new Box2( one2, one2 );
				assert.ok( ! b.equals( a ), "Passed!" );
				assert.ok( ! a.equals( b ), "Passed!" );

			} );

		} );

	} );

	/* global QUnit */

	function compareBox( a, b, threshold ) {

		threshold = threshold || 0.0001;
		return ( a.min.distanceTo( b.min ) < threshold &&
		a.max.distanceTo( b.max ) < threshold );

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Box3', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Box3();
				assert.ok( a.min.equals( posInf3 ), "Passed!" );
				assert.ok( a.max.equals( negInf3 ), "Passed!" );

				var a = new Box3( zero3.clone(), zero3.clone() );
				assert.ok( a.min.equals( zero3 ), "Passed!" );
				assert.ok( a.max.equals( zero3 ), "Passed!" );

				var a = new Box3( zero3.clone(), one3.clone() );
				assert.ok( a.min.equals( zero3 ), "Passed!" );
				assert.ok( a.max.equals( one3 ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "isBox3", ( assert ) => {

				var a = new Box3();
				assert.ok( a.isBox3 === true, "Passed!" );

				var b = new Sphere();
				assert.ok( ! b.isBox3, "Passed!" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Box3();

				a.set( zero3, one3 );
				assert.ok( a.min.equals( zero3 ), "Passed!" );
				assert.ok( a.max.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "setFromArray", ( assert ) => {

				var a = new Box3();

				a.setFromArray( [ 0, 0, 0, 1, 1, 1, 2, 2, 2 ] );
				assert.ok( a.min.equals( zero3 ), "Passed!" );
				assert.ok( a.max.equals( two3 ), "Passed!" );

			} );

			QUnit.test( "setFromBufferAttribute", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var bigger = new BufferAttribute( new Float32Array( [
					- 2, - 2, - 2, 2, 2, 2, 1.5, 1.5, 1.5, 0, 0, 0
				] ), 3 );
				var smaller = new BufferAttribute( new Float32Array( [
					- 0.5, - 0.5, - 0.5, 0.5, 0.5, 0.5, 0, 0, 0
				] ), 3 );
				var newMin = new Vector3( - 2, - 2, - 2 );
				var newMax = new Vector3( 2, 2, 2 );

				a.setFromBufferAttribute( bigger );
				assert.ok( a.min.equals( newMin ), "Bigger box: correct new minimum" );
				assert.ok( a.max.equals( newMax ), "Bigger box: correct new maximum" );

				newMin.set( - 0.5, - 0.5, - 0.5 );
				newMax.set( 0.5, 0.5, 0.5 );

				a.setFromBufferAttribute( smaller );
				assert.ok( a.min.equals( newMin ), "Smaller box: correct new minimum" );
				assert.ok( a.max.equals( newMax ), "Smaller box: correct new maximum" );

			} );

			QUnit.test( "setFromPoints", ( assert ) => {

				var a = new Box3();

				a.setFromPoints( [ zero3, one3, two3 ] );
				assert.ok( a.min.equals( zero3 ), "Passed!" );
				assert.ok( a.max.equals( two3 ), "Passed!" );

				a.setFromPoints( [ one3 ] );
				assert.ok( a.min.equals( one3 ), "Passed!" );
				assert.ok( a.max.equals( one3 ), "Passed!" );

				a.setFromPoints( [] );
				assert.ok( a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "setFromCenterAndSize", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = a.clone();
				var centerA = new Vector3();
				var sizeA = new Vector3();
				var sizeB = new Vector3();
				var newCenter = one3;
				var newSize = two3;

				a.getCenter( centerA );
				a.getSize( sizeA );
				a.setFromCenterAndSize( centerA, sizeA );
				assert.ok( a.equals( b ), "Same values: no changes" );

				a.setFromCenterAndSize( newCenter, sizeA );
				a.getCenter( centerA );
				a.getSize( sizeA );
				b.getSize( sizeB );

				assert.ok( centerA.equals( newCenter ), "Move center: correct new center" );
				assert.ok( sizeA.equals( sizeB ), "Move center: no change in size" );
				assert.notOk( a.equals( b ), "Move center: no longer equal to old values" );

				a.setFromCenterAndSize( centerA, newSize );
				a.getCenter( centerA );
				a.getSize( sizeA );
				assert.ok( centerA.equals( newCenter ), "Resize: no change to center" );
				assert.ok( sizeA.equals( newSize ), "Resize: correct new size" );
				assert.notOk( a.equals( b ), "Resize: no longer equal to old values" );

			} );

			QUnit.test( "setFromObject/BufferGeometry", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var object = new Mesh( new BoxGeometry( 2, 2, 2 ) );
				var child = new Mesh( new BoxGeometry( 1, 1, 1 ) );
				object.add( child );

				a.setFromObject( object );
				assert.ok( a.min.equals( new Vector3( - 1, - 1, - 1 ) ), "Correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 1, 1, 1 ) ), "Correct new maximum" );

			} );

			QUnit.test( "clone", ( assert ) => {


				var a = new Box3( zero3.clone(), one3.clone() );

				var b = a.clone();
				assert.ok( b.min.equals( zero3 ), "Passed!" );
				assert.ok( b.max.equals( one3 ), "Passed!" );

				a = new Box3();
				var b = a.clone();
				assert.ok( b.min.equals( posInf3 ), "Passed!" );
				assert.ok( b.max.equals( negInf3 ), "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = new Box3().copy( a );
				assert.ok( b.min.equals( zero3 ), "Passed!" );
				assert.ok( b.max.equals( one3 ), "Passed!" );

				// ensure that it is a true copy
				a.min = zero3;
				a.max = one3;
				assert.ok( b.min.equals( zero3 ), "Passed!" );
				assert.ok( b.max.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "empty/makeEmpty", ( assert ) => {

				var a = new Box3();

				assert.ok( a.isEmpty(), "Passed!" );

				var a = new Box3( zero3.clone(), one3.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				a.makeEmpty();
				assert.ok( a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "isEmpty", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				var a = new Box3( zero3.clone(), one3.clone() );
				assert.ok( ! a.isEmpty(), "Passed!" );

				var a = new Box3( two3.clone(), one3.clone() );
				assert.ok( a.isEmpty(), "Passed!" );

				var a = new Box3( posInf3.clone(), negInf3.clone() );
				assert.ok( a.isEmpty(), "Passed!" );


			} );

			QUnit.test( "getCenter", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var center = new Vector3();

				assert.ok( a.getCenter( center ).equals( zero3 ), "Passed!" );

				var a = new Box3( zero3.clone(), one3.clone() );
				var midpoint = one3.clone().multiplyScalar( 0.5 );
				assert.ok( a.getCenter( center ).equals( midpoint ), "Passed!" );

			} );

			QUnit.test( "getSize", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var size = new Vector3();

				assert.ok( a.getSize( size ).equals( zero3 ), "Passed!" );

				var a = new Box3( zero3.clone(), one3.clone() );
				assert.ok( a.getSize( size ).equals( one3 ), "Passed!" );

			} );

			QUnit.test( "expandByPoint", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var center = new Vector3();
				var size = new Vector3();

				a.expandByPoint( zero3 );
				assert.ok( a.getSize( size ).equals( zero3 ), "Passed!" );

				a.expandByPoint( one3 );
				assert.ok( a.getSize( size ).equals( one3 ), "Passed!" );

				a.expandByPoint( one3.clone().negate() );
				assert.ok( a.getSize( size ).equals( one3.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero3 ), "Passed!" );

			} );

			QUnit.test( "expandByVector", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var center = new Vector3();
				var size = new Vector3();

				a.expandByVector( zero3 );
				assert.ok( a.getSize( size ).equals( zero3 ), "Passed!" );

				a.expandByVector( one3 );
				assert.ok( a.getSize( size ).equals( one3.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero3 ), "Passed!" );

			} );

			QUnit.test( "expandByScalar", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var center = new Vector3();
				var size = new Vector3();

				a.expandByScalar( 0 );
				assert.ok( a.getSize( size ).equals( zero3 ), "Passed!" );

				a.expandByScalar( 1 );
				assert.ok( a.getSize( size ).equals( one3.clone().multiplyScalar( 2 ) ), "Passed!" );
				assert.ok( a.getCenter( center ).equals( zero3 ), "Passed!" );

			} );

			QUnit.test( "expandByObject", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = a.clone();
				var bigger = new Mesh( new BoxGeometry( 2, 2, 2 ) );
				var smaller = new Mesh( new BoxGeometry( 0.5, 0.5, 0.5 ) );
				var child = new Mesh( new BoxGeometry( 1, 1, 1 ) );

				// just a bigger box to begin with
				a.expandByObject( bigger );
				assert.ok( a.min.equals( new Vector3( - 1, - 1, - 1 ) ), "Bigger box: correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 1, 1, 1 ) ), "Bigger box: correct new maximum" );

				// a translated, bigger box
				a.copy( b );
				bigger.translateX( 2 );
				a.expandByObject( bigger );
				assert.ok( a.min.equals( new Vector3( 0, - 1, - 1 ) ), "Translated, bigger box: correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 3, 1, 1 ) ), "Translated, bigger box: correct new maximum" );

				// a translated, bigger box with child
				a.copy( b );
				bigger.add( child );
				a.expandByObject( bigger );
				assert.ok( a.min.equals( new Vector3( 0, - 1, - 1 ) ), "Translated, bigger box with child: correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 3, 1, 1 ) ), "Translated, bigger box with child: correct new maximum" );

				// a translated, bigger box with a translated child
				a.copy( b );
				child.translateX( 2 );
				a.expandByObject( bigger );
				assert.ok( a.min.equals( new Vector3( 0, - 1, - 1 ) ), "Translated, bigger box with translated child: correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 4.5, 1, 1 ) ), "Translated, bigger box with translated child: correct new maximum" );

				// a smaller box
				a.copy( b );
				a.expandByObject( smaller );
				assert.ok( a.min.equals( new Vector3( - 0.25, - 0.25, - 0.25 ) ), "Smaller box: correct new minimum" );
				assert.ok( a.max.equals( new Vector3( 1, 1, 1 ) ), "Smaller box: correct new maximum" );

				//
				assert.ok( new Box3().expandByObject( new Mesh() ).isEmpty() === true, "The AABB of a mesh with inital geometry is empty." );

			} );

			QUnit.test( "containsPoint", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );

				assert.ok( a.containsPoint( zero3 ), "Passed!" );
				assert.ok( ! a.containsPoint( one3 ), "Passed!" );

				a.expandByScalar( 1 );
				assert.ok( a.containsPoint( zero3 ), "Passed!" );
				assert.ok( a.containsPoint( one3 ), "Passed!" );
				assert.ok( a.containsPoint( one3.clone().negate() ), "Passed!" );

			} );

			QUnit.test( "containsBox", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );

				assert.ok( a.containsBox( a ), "Passed!" );
				assert.ok( ! a.containsBox( b ), "Passed!" );
				assert.ok( ! a.containsBox( c ), "Passed!" );

				assert.ok( b.containsBox( a ), "Passed!" );
				assert.ok( c.containsBox( a ), "Passed!" );
				assert.ok( ! b.containsBox( c ), "Passed!" );

			} );

			QUnit.test( "getParameter", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = new Box3( one3.clone().negate(), one3.clone() );
				var parameter = new Vector3();

				a.getParameter( zero3, parameter );
				assert.ok( parameter.equals( zero3 ), "Passed!" );
				a.getParameter( one3, parameter );
				assert.ok( parameter.equals( one3 ), "Passed!" );

				b.getParameter( one3.clone().negate(), parameter );
				assert.ok( parameter.equals( zero3 ), "Passed!" );
				b.getParameter( zero3, parameter );
				assert.ok( parameter.equals( new Vector3( 0.5, 0.5, 0.5 ) ), "Passed!" );
				b.getParameter( one3, parameter );
				assert.ok( parameter.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );

				assert.ok( a.intersectsBox( a ), "Passed!" );
				assert.ok( a.intersectsBox( b ), "Passed!" );
				assert.ok( a.intersectsBox( c ), "Passed!" );

				assert.ok( b.intersectsBox( a ), "Passed!" );
				assert.ok( c.intersectsBox( a ), "Passed!" );
				assert.ok( b.intersectsBox( c ), "Passed!" );

				b.translate( new Vector3( 2, 2, 2 ) );
				assert.ok( ! a.intersectsBox( b ), "Passed!" );
				assert.ok( ! b.intersectsBox( a ), "Passed!" );
				assert.ok( ! b.intersectsBox( c ), "Passed!" );

			} );

			QUnit.test( "intersectsSphere", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = new Sphere( zero3.clone(), 1 );

				assert.ok( a.intersectsSphere( b ), "Passed!" );

				b.translate( new Vector3( 2, 2, 2 ) );
				assert.ok( ! a.intersectsSphere( b ), "Passed!" );

			} );

			QUnit.test( "intersectsPlane", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = new Plane( new Vector3( 0, 1, 0 ), 1 );
				var c = new Plane( new Vector3( 0, 1, 0 ), 1.25 );
				var d = new Plane( new Vector3( 0, - 1, 0 ), 1.25 );
				var e = new Plane( new Vector3( 0, 1, 0 ), 0.25 );
				var f = new Plane( new Vector3( 0, 1, 0 ), - 0.25 );
				var g = new Plane( new Vector3( 0, 1, 0 ), - 0.75 );
				var h = new Plane( new Vector3( 0, 1, 0 ), - 1 );
				var i = new Plane( new Vector3( 1, 1, 1 ).normalize(), - 1.732 );
				var j = new Plane( new Vector3( 1, 1, 1 ).normalize(), - 1.733 );

				assert.ok( ! a.intersectsPlane( b ), "Passed!" );
				assert.ok( ! a.intersectsPlane( c ), "Passed!" );
				assert.ok( ! a.intersectsPlane( d ), "Passed!" );
				assert.ok( ! a.intersectsPlane( e ), "Passed!" );
				assert.ok( a.intersectsPlane( f ), "Passed!" );
				assert.ok( a.intersectsPlane( g ), "Passed!" );
				assert.ok( a.intersectsPlane( h ), "Passed!" );
				assert.ok( a.intersectsPlane( i ), "Passed!" );
				assert.ok( ! a.intersectsPlane( j ), "Passed!" );

			} );

			QUnit.test( "intersectsTriangle", ( assert ) => {

				var a = new Box3( one3.clone(), two3.clone() );
				var b = new Triangle( new Vector3( 1.5, 1.5, 2.5 ), new Vector3( 2.5, 1.5, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var c = new Triangle( new Vector3( 1.5, 1.5, 3.5 ), new Vector3( 3.5, 1.5, 1.5 ), new Vector3( 1.5, 1.5, 1.5 ) );
				var d = new Triangle( new Vector3( 1.5, 1.75, 3 ), new Vector3( 3, 1.75, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var e = new Triangle( new Vector3( 1.5, 1.8, 3 ), new Vector3( 3, 1.8, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var f = new Triangle( new Vector3( 1.5, 2.5, 3 ), new Vector3( 3, 2.5, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );

				assert.ok( a.intersectsTriangle( b ), "Passed!" );
				assert.ok( a.intersectsTriangle( c ), "Passed!" );
				assert.ok( a.intersectsTriangle( d ), "Passed!" );
				assert.ok( ! a.intersectsTriangle( e ), "Passed!" );
				assert.ok( ! a.intersectsTriangle( f ), "Passed!" );

			} );

			QUnit.test( "clampPoint", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( one3.clone().negate(), one3.clone() );
				var point = new Vector3();

				a.clampPoint( zero3, point );
				assert.ok( point.equals( zero3 ), "Passed!" );
				a.clampPoint( one3, point );
				assert.ok( point.equals( zero3 ), "Passed!" );
				a.clampPoint( one3.clone().negate(), point );
				assert.ok( point.equals( zero3 ), "Passed!" );

				b.clampPoint( new Vector3( 2, 2, 2 ), point );
				assert.ok( point.equals( one3 ), "Passed!" );
				b.clampPoint( one3, point );
				assert.ok( point.equals( one3 ), "Passed!" );
				b.clampPoint( zero3, point );
				assert.ok( point.equals( zero3 ), "Passed!" );
				b.clampPoint( one3.clone().negate(), point );
				assert.ok( point.equals( one3.clone().negate() ), "Passed!" );
				b.clampPoint( new Vector3( - 2, - 2, - 2 ), point );
				assert.ok( point.equals( one3.clone().negate() ), "Passed!" );

			} );

			QUnit.test( "distanceToPoint", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( one3.clone().negate(), one3.clone() );

				assert.ok( a.distanceToPoint( new Vector3( 0, 0, 0 ) ) == 0, "Passed!" );
				assert.ok( a.distanceToPoint( new Vector3( 1, 1, 1 ) ) == Math.sqrt( 3 ), "Passed!" );
				assert.ok( a.distanceToPoint( new Vector3( - 1, - 1, - 1 ) ) == Math.sqrt( 3 ), "Passed!" );

				assert.ok( b.distanceToPoint( new Vector3( 2, 2, 2 ) ) == Math.sqrt( 3 ), "Passed!" );
				assert.ok( b.distanceToPoint( new Vector3( 1, 1, 1 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector3( 0, 0, 0 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector3( - 1, - 1, - 1 ) ) == 0, "Passed!" );
				assert.ok( b.distanceToPoint( new Vector3( - 2, - 2, - 2 ) ) == Math.sqrt( 3 ), "Passed!" );

			} );

			QUnit.test( "getBoundingSphere", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );
				var sphere = new Sphere();

				assert.ok( a.getBoundingSphere( sphere ).equals( new Sphere( zero3, 0 ) ), "Passed!" );
				assert.ok( b.getBoundingSphere( sphere ).equals( new Sphere( one3.clone().multiplyScalar( 0.5 ), Math.sqrt( 3 ) * 0.5 ) ), "Passed!" );
				assert.ok( c.getBoundingSphere( sphere ).equals( new Sphere( zero3, Math.sqrt( 12 ) * 0.5 ) ), "Passed!" );

			} );

			QUnit.test( "intersect", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );

				assert.ok( a.clone().intersect( a ).equals( a ), "Passed!" );
				assert.ok( a.clone().intersect( b ).equals( a ), "Passed!" );
				assert.ok( b.clone().intersect( b ).equals( b ), "Passed!" );
				assert.ok( a.clone().intersect( c ).equals( a ), "Passed!" );
				assert.ok( b.clone().intersect( c ).equals( b ), "Passed!" );
				assert.ok( c.clone().intersect( c ).equals( c ), "Passed!" );

			} );

			QUnit.test( "union", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );

				assert.ok( a.clone().union( a ).equals( a ), "Passed!" );
				assert.ok( a.clone().union( b ).equals( b ), "Passed!" );
				assert.ok( a.clone().union( c ).equals( c ), "Passed!" );
				assert.ok( b.clone().union( c ).equals( c ), "Passed!" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				var c = new Box3( one3.clone().negate(), one3.clone() );
				var d = new Box3( one3.clone().negate(), zero3.clone() );

				var m = new Matrix4().makeTranslation( 1, - 2, 1 );
				var t1 = new Vector3( 1, - 2, 1 );

				assert.ok( compareBox( a.clone().applyMatrix4( m ), a.clone().translate( t1 ) ), "Passed!" );
				assert.ok( compareBox( b.clone().applyMatrix4( m ), b.clone().translate( t1 ) ), "Passed!" );
				assert.ok( compareBox( c.clone().applyMatrix4( m ), c.clone().translate( t1 ) ), "Passed!" );
				assert.ok( compareBox( d.clone().applyMatrix4( m ), d.clone().translate( t1 ) ), "Passed!" );

			} );

			QUnit.test( "translate", ( assert ) => {

				var a = new Box3( zero3.clone(), zero3.clone() );
				var b = new Box3( zero3.clone(), one3.clone() );
				new Box3( one3.clone().negate(), one3.clone() );
				var d = new Box3( one3.clone().negate(), zero3.clone() );

				assert.ok( a.clone().translate( one3 ).equals( new Box3( one3, one3 ) ), "Passed!" );
				assert.ok( a.clone().translate( one3 ).translate( one3.clone().negate() ).equals( a ), "Passed!" );
				assert.ok( d.clone().translate( one3 ).equals( b ), "Passed!" );
				assert.ok( b.clone().translate( one3.clone().negate() ).equals( d ), "Passed!" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Box3();
				var b = new Box3();
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box3( one3, two3 );
				b = new Box3( one3, two3 );
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box3( one3, two3 );
				b = a.clone();
				assert.ok( b.equals( a ), "Passed!" );
				assert.ok( a.equals( b ), "Passed!" );

				a = new Box3( one3, two3 );
				b = new Box3( one3, one3 );
				assert.ok( ! b.equals( a ), "Passed!" );
				assert.ok( ! a.equals( b ), "Passed!" );

				a = new Box3();
				b = new Box3( one3, one3 );
				assert.ok( ! b.equals( a ), "Passed!" );
				assert.ok( ! a.equals( b ), "Passed!" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Color', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				// default ctor
				var c = new Color();
				assert.ok( c.r, "Red: " + c.r );
				assert.ok( c.g, "Green: " + c.g );
				assert.ok( c.b, "Blue: " + c.b );

				// rgb ctor
				var c = new Color( 1, 1, 1 );
				assert.ok( c.r == 1, "Passed" );
				assert.ok( c.g == 1, "Passed" );
				assert.ok( c.b == 1, "Passed" );

			} );

			// EXPOSED CONSTANTS
			QUnit.test( "Color.NAMES", ( assert ) => {

				assert.ok( Color.NAMES.aliceblue == 0xF0F8FF, "Exposed Color.NAMES" );

			} );

			// PUBLIC STUFF
			QUnit.test( "isColor", ( assert ) => {

				var a = new Color();
				assert.ok( a.isColor === true, "Passed!" );

				var b = new Object();
				assert.ok( ! b.isColor, "Passed!" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Color();
				var b = new Color( 0.5, 0, 0 );
				var c = new Color( 0xFF0000 );
				var d = new Color( 0, 1.0, 0 );

				a.set( b );
				assert.ok( a.equals( b ), "Set with Color instance" );

				a.set( 0xFF0000 );
				assert.ok( a.equals( c ), "Set with number" );

				a.set( "rgb(0,255,0)" );
				assert.ok( a.equals( d ), "Set with style" );

			} );

			QUnit.test( "setScalar", ( assert ) => {

				var c = new Color();
				c.setScalar( 0.5 );
				assert.ok( c.r == 0.5, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.5, "Blue: " + c.b );

			} );

			QUnit.test( "setHex", ( assert ) => {

				var c = new Color();
				c.setHex( 0xFA8072 );
				assert.ok( c.getHex() == 0xFA8072, "Hex: " + c.getHex() );
				assert.ok( c.r == 0xFA / 0xFF, "Red: " + c.r );
				assert.ok( c.g == 0x80 / 0xFF, "Green: " + c.g );
				assert.ok( c.b == 0x72 / 0xFF, "Blue: " + c.b );

			} );

			QUnit.test( "setRGB", ( assert ) => {

				var c = new Color();
				c.setRGB( 0.3, 0.5, 0.7 );
				assert.ok( c.r == 0.3, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.7, "Blue: " + c.b );

			} );

			QUnit.test( "setHSL", ( assert ) => {

				var c = new Color();
				var hsl = { h: 0, s: 0, l: 0 };
				c.setHSL( 0.75, 1.0, 0.25 );
				c.getHSL( hsl );

				assert.ok( hsl.h == 0.75, "hue: " + hsl.h );
				assert.ok( hsl.s == 1.00, "saturation: " + hsl.s );
				assert.ok( hsl.l == 0.25, "lightness: " + hsl.l );

			} );

			QUnit.test( "setStyle", ( assert ) => {

				var a = new Color();

				var b = new Color( 8 / 255, 25 / 255, 178 / 255 );
				a.setStyle( "rgb(8,25,178)" );
				assert.ok( a.equals( b ), "Passed" );

				b = new Color( 8 / 255, 25 / 255, 178 / 255 );
				a.setStyle( "rgba(8,25,178,200)" );
				assert.ok( a.equals( b ), "Passed" );

				var hsl = { h: 0, s: 0, l: 0 };
				a.setStyle( "hsl(270,50%,75%)" );
				a.getHSL( hsl );
				assert.ok( hsl.h == 0.75, "hue: " + hsl.h );
				assert.ok( hsl.s == 0.5, "saturation: " + hsl.s );
				assert.ok( hsl.l == 0.75, "lightness: " + hsl.l );

				hsl = { h: 0, s: 0, l: 0 };
				a.setStyle( "hsl(270,50%,75%)" );
				a.getHSL( hsl );
				assert.ok( hsl.h == 0.75, "hue: " + hsl.h );
				assert.ok( hsl.s == 0.5, "saturation: " + hsl.s );
				assert.ok( hsl.l == 0.75, "lightness: " + hsl.l );

				a.setStyle( "#F8A" );
				assert.ok( a.r == 0xFF / 255, "Red: " + a.r );
				assert.ok( a.g == 0x88 / 255, "Green: " + a.g );
				assert.ok( a.b == 0xAA / 255, "Blue: " + a.b );

				a.setStyle( "#F8ABC1" );
				assert.ok( a.r == 0xF8 / 255, "Red: " + a.r );
				assert.ok( a.g == 0xAB / 255, "Green: " + a.g );
				assert.ok( a.b == 0xC1 / 255, "Blue: " + a.b );

				a.setStyle( "aliceblue" );
				assert.ok( a.r == 0xF0 / 255, "Red: " + a.r );
				assert.ok( a.g == 0xF8 / 255, "Green: " + a.g );
				assert.ok( a.b == 0xFF / 255, "Blue: " + a.b );

			} );

			QUnit.test( "setColorName", ( assert ) => {

				var c = new Color();
				var res = c.setColorName( "aliceblue" );

				assert.ok( c.getHex() == 0xF0F8FF, "Hex: " + c.getHex() );
				assert.ok( c == res, "Returns Self" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var c = new Color( 'teal' );
				var c2 = c.clone();
				assert.ok( c2.getHex() == 0x008080, "Hex c2: " + c2.getHex() );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Color( 'teal' );
				var b = new Color();
				b.copy( a );
				assert.ok( b.r == 0x00 / 255, "Red: " + b.r );
				assert.ok( b.g == 0x80 / 255, "Green: " + b.g );
				assert.ok( b.b == 0x80 / 255, "Blue: " + b.b );

			} );

			QUnit.test( "copyGammaToLinear", ( assert ) => {

				var c = new Color();
				var c2 = new Color();
				c2.setRGB( 0.3, 0.5, 0.9 );
				c.copyGammaToLinear( c2 );
				assert.ok( c.r == 0.09, "Red c: " + c.r + " Red c2: " + c2.r );
				assert.ok( c.g == 0.25, "Green c: " + c.g + " Green c2: " + c2.g );
				assert.ok( c.b == 0.81, "Blue c: " + c.b + " Blue c2: " + c2.b );

			} );

			QUnit.test( "copyLinearToGamma", ( assert ) => {

				var c = new Color();
				var c2 = new Color();
				c2.setRGB( 0.09, 0.25, 0.81 );
				c.copyLinearToGamma( c2 );
				assert.ok( c.r == 0.3, "Red c: " + c.r + " Red c2: " + c2.r );
				assert.ok( c.g == 0.5, "Green c: " + c.g + " Green c2: " + c2.g );
				assert.ok( c.b == 0.9, "Blue c: " + c.b + " Blue c2: " + c2.b );

			} );

			QUnit.test( "convertGammaToLinear", ( assert ) => {

				var c = new Color();
				c.setRGB( 0.3, 0.5, 0.9 );
				c.convertGammaToLinear();
				assert.ok( c.r == 0.09, "Red: " + c.r );
				assert.ok( c.g == 0.25, "Green: " + c.g );
				assert.ok( c.b == 0.81, "Blue: " + c.b );

			} );

			QUnit.test( "convertLinearToGamma", ( assert ) => {

				var c = new Color();
				c.setRGB( 4, 9, 16 );
				c.convertLinearToGamma();
				assert.ok( c.r == 2, "Red: " + c.r );
				assert.ok( c.g == 3, "Green: " + c.g );
				assert.ok( c.b == 4, "Blue: " + c.b );

			} );

			QUnit.test( "getHex", ( assert ) => {

				var c = new Color( 'red' );
				var res = c.getHex();
				assert.ok( res == 0xFF0000, "Hex: " + res );

			} );

			QUnit.test( "getHexString", ( assert ) => {

				var c = new Color( 'tomato' );
				var res = c.getHexString();
				assert.ok( res == 'ff6347', "Hex: " + res );

			} );

			QUnit.test( "getHSL", ( assert ) => {

				var c = new Color( 0x80ffff );
				var hsl = { h: 0, s: 0, l: 0 };
				c.getHSL( hsl );

				assert.ok( hsl.h == 0.5, "hue: " + hsl.h );
				assert.ok( hsl.s == 1.0, "saturation: " + hsl.s );
				assert.ok( ( Math.round( parseFloat( hsl.l ) * 100 ) / 100 ) == 0.75, "lightness: " + hsl.l );

			} );

			QUnit.test( "getStyle", ( assert ) => {

				var c = new Color( 'plum' );
				var res = c.getStyle();
				assert.ok( res == 'rgb(221,160,221)', "style: " + res );

			} );

			QUnit.test( "offsetHSL", ( assert ) => {

				var a = new Color( "hsl(120,50%,50%)" );
				var b = new Color( 0.36, 0.84, 0.648 );

				a.offsetHSL( 0.1, 0.1, 0.1 );

				assert.ok( Math.abs( a.r - b.r ) <= eps, "Check r" );
				assert.ok( Math.abs( a.g - b.g ) <= eps, "Check g" );
				assert.ok( Math.abs( a.b - b.b ) <= eps, "Check b" );

			} );

			QUnit.test( "add", ( assert ) => {

				var a = new Color( 0x0000FF );
				var b = new Color( 0xFF0000 );
				var c = new Color( 0xFF00FF );

				a.add( b );

				assert.ok( a.equals( c ), "Check new value" );

			} );

			QUnit.test( "addColors", ( assert ) => {

				var a = new Color( 0x0000FF );
				var b = new Color( 0xFF0000 );
				var c = new Color( 0xFF00FF );
				var d = new Color();

				d.addColors( a, b );

				assert.ok( d.equals( c ), "Passed" );


			} );

			QUnit.test( "addScalar", ( assert ) => {

				var a = new Color( 0.1, 0.0, 0.0 );
				var b = new Color( 0.6, 0.5, 0.5 );

				a.addScalar( 0.5 );

				assert.ok( a.equals( b ), "Check new value" );

			} );

			QUnit.test( "sub", ( assert ) => {

				var a = new Color( 0x0000CC );
				var b = new Color( 0xFF0000 );
				var c = new Color( 0x0000AA );

				a.sub( b );
				assert.strictEqual( a.getHex(), 0xCC, "Difference too large" );

				a.sub( c );
				assert.strictEqual( a.getHex(), 0x22, "Difference fine" );

			} );

			QUnit.test( "multiply", ( assert ) => {

				var a = new Color( 1, 0, 0.5 );
				var b = new Color( 0.5, 1, 0.5 );
				var c = new Color( 0.5, 0, 0.25 );

				a.multiply( b );
				assert.ok( a.equals( c ), "Check new value" );

			} );

			QUnit.test( "multiplyScalar", ( assert ) => {

				var a = new Color( 0.25, 0, 0.5 );
				var b = new Color( 0.5, 0, 1 );

				a.multiplyScalar( 2 );
				assert.ok( a.equals( b ), "Check new value" );

			} );

			QUnit.test( "copyHex", ( assert ) => {

				var c = new Color();
				var c2 = new Color( 0xF5FFFA );
				c.copy( c2 );
				assert.ok( c.getHex() == c2.getHex(), "Hex c: " + c.getHex() + " Hex c2: " + c2.getHex() );

			} );

			QUnit.test( "copyColorString", ( assert ) => {

				var c = new Color();
				var c2 = new Color( 'ivory' );
				c.copy( c2 );
				assert.ok( c.getHex() == c2.getHex(), "Hex c: " + c.getHex() + " Hex c2: " + c2.getHex() );

			} );

			QUnit.test( "lerp", ( assert ) => {

				var c = new Color();
				var c2 = new Color();
				c.setRGB( 0, 0, 0 );
				c.lerp( c2, 0.2 );
				assert.ok( c.r == 0.2, "Red: " + c.r );
				assert.ok( c.g == 0.2, "Green: " + c.g );
				assert.ok( c.b == 0.2, "Blue: " + c.b );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Color( 0.5, 0.0, 1.0 );
				var b = new Color( 0.5, 1.0, 0.0 );

				assert.strictEqual( a.r, b.r, "Components: r is equal" );
				assert.notStrictEqual( a.g, b.g, "Components: g is not equal" );
				assert.notStrictEqual( a.b, b.b, "Components: b is not equal" );

				assert.notOk( a.equals( b ), "equals(): a not equal b" );
				assert.notOk( b.equals( a ), "equals(): b not equal a" );

				a.copy( b );
				assert.strictEqual( a.r, b.r, "Components after copy(): r is equal" );
				assert.strictEqual( a.g, b.g, "Components after copy(): g is equal" );
				assert.strictEqual( a.b, b.b, "Components after copy(): b is equal" );

				assert.ok( a.equals( b ), "equals() after copy(): a equals b" );
				assert.ok( b.equals( a ), "equals() after copy(): b equals a" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Color();
				var array = [ 0.5, 0.6, 0.7, 0, 1, 0 ];

				a.fromArray( array );
				assert.strictEqual( a.r, 0.5, "No offset: check r" );
				assert.strictEqual( a.g, 0.6, "No offset: check g" );
				assert.strictEqual( a.b, 0.7, "No offset: check b" );

				a.fromArray( array, 3 );
				assert.strictEqual( a.r, 0, "With offset: check r" );
				assert.strictEqual( a.g, 1, "With offset: check g" );
				assert.strictEqual( a.b, 0, "With offset: check b" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var r = 0.5, g = 1.0, b = 0.0;
				var a = new Color( r, g, b );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], r, "No array, no offset: check r" );
				assert.strictEqual( array[ 1 ], g, "No array, no offset: check g" );
				assert.strictEqual( array[ 2 ], b, "No array, no offset: check b" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], r, "With array, no offset: check r" );
				assert.strictEqual( array[ 1 ], g, "With array, no offset: check g" );
				assert.strictEqual( array[ 2 ], b, "With array, no offset: check b" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], r, "With array and offset: check r" );
				assert.strictEqual( array[ 2 ], g, "With array and offset: check g" );
				assert.strictEqual( array[ 3 ], b, "With array and offset: check b" );

			} );

			QUnit.test( "toJSON", ( assert ) => {

				var a = new Color( 0.0, 0.0, 0.0 );
				var b = new Color( 0.0, 0.5, 0.0 );
				var c = new Color( 1.0, 0.0, 0.0 );
				var d = new Color( 1.0, 1.0, 1.0 );

				assert.strictEqual( a.toJSON(), 0x000000, "Check black" );
				assert.strictEqual( b.toJSON(), 0x007F00, "Check half-blue" );
				assert.strictEqual( c.toJSON(), 0xFF0000, "Check red" );
				assert.strictEqual( d.toJSON(), 0xFFFFFF, "Check white" );

			} );

			// OTHERS
			QUnit.test( "setWithNum", ( assert ) => {

				var c = new Color();
				c.set( 0xFF0000 );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setWithString", ( assert ) => {

				var c = new Color();
				c.set( 'silver' );
				assert.ok( c.getHex() == 0xC0C0C0, "Hex c: " + c.getHex() );

			} );

			QUnit.test( "setStyleRGBRed", ( assert ) => {

				var c = new Color();
				c.setStyle( 'rgb(255,0,0)' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBARed", ( assert ) => {

				var c = new Color();

				console.level = CONSOLE_LEVEL.ERROR;
				c.setStyle( 'rgba(255,0,0,0.5)' );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBRedWithSpaces", ( assert ) => {

				var c = new Color();
				c.setStyle( 'rgb( 255 , 0,   0 )' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBARedWithSpaces", ( assert ) => {

				var c = new Color();
				c.setStyle( 'rgba( 255,  0,  0  , 1 )' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBPercent", ( assert ) => {

				var c = new Color();
				c.setStyle( 'rgb(100%,50%,10%)' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.1, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBAPercent", ( assert ) => {

				var c = new Color();

				console.level = CONSOLE_LEVEL.ERROR;
				c.setStyle( 'rgba(100%,50%,10%, 0.5)' );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.1, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBPercentWithSpaces", ( assert ) => {

				var c = new Color();
				c.setStyle( 'rgb( 100% ,50%  , 10% )' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.1, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleRGBAPercentWithSpaces", ( assert ) => {

				var c = new Color();

				console.level = CONSOLE_LEVEL.ERROR;
				c.setStyle( 'rgba( 100% ,50%  ,  10%, 0.5 )' );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g == 0.5, "Green: " + c.g );
				assert.ok( c.b == 0.1, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleHSLRed", ( assert ) => {

				var c = new Color();
				c.setStyle( 'hsl(360,100%,50%)' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleHSLARed", ( assert ) => {

				var c = new Color();

				console.level = CONSOLE_LEVEL.ERROR;
				c.setStyle( 'hsla(360,100%,50%,0.5)' );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleHSLRedWithSpaces", ( assert ) => {

				var c = new Color();
				c.setStyle( 'hsl(360,  100% , 50% )' );
				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleHSLARedWithSpaces", ( assert ) => {

				var c = new Color();

				console.level = CONSOLE_LEVEL.ERROR;
				c.setStyle( 'hsla( 360,  100% , 50%,  0.5 )' );
				console.level = CONSOLE_LEVEL.DEFAULT;

				assert.ok( c.r == 1, "Red: " + c.r );
				assert.ok( c.g === 0, "Green: " + c.g );
				assert.ok( c.b === 0, "Blue: " + c.b );

			} );

			QUnit.test( "setStyleHexSkyBlue", ( assert ) => {

				var c = new Color();
				c.setStyle( '#87CEEB' );
				assert.ok( c.getHex() == 0x87CEEB, "Hex c: " + c.getHex() );

			} );

			QUnit.test( "setStyleHexSkyBlueMixed", ( assert ) => {

				var c = new Color();
				c.setStyle( '#87cEeB' );
				assert.ok( c.getHex() == 0x87CEEB, "Hex c: " + c.getHex() );

			} );

			QUnit.test( "setStyleHex2Olive", ( assert ) => {

				var c = new Color();
				c.setStyle( '#F00' );
				assert.ok( c.getHex() == 0xFF0000, "Hex c: " + c.getHex() );

			} );

			QUnit.test( "setStyleHex2OliveMixed", ( assert ) => {

				var c = new Color();
				c.setStyle( '#f00' );
				assert.ok( c.getHex() == 0xFF0000, "Hex c: " + c.getHex() );

			} );

			QUnit.test( "setStyleColorName", ( assert ) => {

				var c = new Color();
				c.setStyle( 'powderblue' );
				assert.ok( c.getHex() == 0xB0E0E6, "Hex c: " + c.getHex() );

			} );


		} );

	} );

	/**
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 */

	class Cylindrical {

		constructor( radius = 1, theta = 0, y = 0 ) {

			this.radius = radius; // distance from the origin to a point in the x-z plane
			this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = y; // height above the x-z plane

			return this;

		}

		set( radius, theta, y ) {

			this.radius = radius;
			this.theta = theta;
			this.y = y;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Cylindrical', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Cylindrical();
				var radius = 10.0;
				var theta = Math.PI;
				var y = 5;

				assert.strictEqual( a.radius, 1.0, "Default values: check radius" );
				assert.strictEqual( a.theta, 0, "Default values: check theta" );
				assert.strictEqual( a.y, 0, "Default values: check y" );

				var a = new Cylindrical( radius, theta, y );
				assert.strictEqual( a.radius, radius, "Custom values: check radius" );
				assert.strictEqual( a.theta, theta, "Custom values: check theta" );
				assert.strictEqual( a.y, y, "Custom values: check y" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Cylindrical();
				var radius = 10.0;
				var theta = Math.PI;
				var y = 5;

				a.set( radius, theta, y );
				assert.strictEqual( a.radius, radius, "Check radius" );
				assert.strictEqual( a.theta, theta, "Check theta" );
				assert.strictEqual( a.y, y, "Check y" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var radius = 10.0;
				var theta = Math.PI;
				var y = 5;
				var a = new Cylindrical( radius, theta, y );
				var b = a.clone();

				assert.propEqual( a, b, "Check a and b are equal after clone()" );

				a.radius = 1;
				assert.notPropEqual( a, b, "Check a and b are not equal after modification" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var radius = 10.0;
				var theta = Math.PI;
				var y = 5;
				var a = new Cylindrical( radius, theta, y );
				var b = new Cylindrical().copy( a );

				assert.propEqual( a, b, "Check a and b are equal after copy()" );

				a.radius = 1;
				assert.notPropEqual( a, b, "Check a and b are not equal after modification" );

			} );

			QUnit.test( "setFromVector3", ( assert ) => {

				var a = new Cylindrical( 1, 1, 1 );
				var b = new Vector3( 0, 0, 0 );
				var c = new Vector3( 3, - 1, - 3 );
				var expected = new Cylindrical( Math.sqrt( 9 + 9 ), Math.atan2( 3, - 3 ), - 1 );

				a.setFromVector3( b );
				assert.strictEqual( a.radius, 0, "Zero-length vector: check radius" );
				assert.strictEqual( a.theta, 0, "Zero-length vector: check theta" );
				assert.strictEqual( a.y, 0, "Zero-length vector: check y" );

				a.setFromVector3( c );
				assert.ok( Math.abs( a.radius - expected.radius ) <= eps, "Normal vector: check radius" );
				assert.ok( Math.abs( a.theta - expected.theta ) <= eps, "Normal vector: check theta" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Normal vector: check y" );

			} );

		} );

	} );

	/* global QUnit */

	const eulerZero = new Euler( 0, 0, 0, "XYZ" );
	const eulerAxyz = new Euler( 1, 0, 0, "XYZ" );
	const eulerAzyx = new Euler( 0, 1, 0, "ZYX" );

	function matrixEquals4$1( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		if ( a.elements.length != b.elements.length ) {

			return false;

		}

		for ( var i = 0, il = a.elements.length; i < il; i ++ ) {

			var delta = a.elements[ i ] - b.elements[ i ];
			if ( delta > tolerance ) {

				return false;

			}

		}

		return true;

	}

	function eulerEquals( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		var diff = Math.abs( a.x - b.x ) + Math.abs( a.y - b.y ) + Math.abs( a.z - b.z );

		return ( diff < tolerance );

	}

	function quatEquals( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		var diff = Math.abs( a.x - b.x ) + Math.abs( a.y - b.y ) + Math.abs( a.z - b.z ) + Math.abs( a.w - b.w );

		return ( diff < tolerance );

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Euler', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Euler();
				assert.ok( a.equals( eulerZero ), "Passed!" );
				assert.ok( ! a.equals( eulerAxyz ), "Passed!" );
				assert.ok( ! a.equals( eulerAzyx ), "Passed!" );

			} );

			// STATIC STUFF
			QUnit.test( "RotationOrders", ( assert ) => {

				assert.ok( Array.isArray( Euler.RotationOrders ), "Passed!" );
				assert.deepEqual( Euler.RotationOrders, [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ], "Passed!" );

			} );

			QUnit.test( "DefaultOrder", ( assert ) => {

				assert.equal( Euler.DefaultOrder, "XYZ", "Passed!" );


			} );

			// PROPERTIES STUFF
			QUnit.test( "x", ( assert ) => {

				var a = new Euler();
				assert.ok( a.x === 0, "Passed!" );

				a = new Euler( 1, 2, 3 );
				assert.ok( a.x === 1, "Passed!" );

				a = new Euler( 4, 5, 6, "XYZ" );
				assert.ok( a.x === 4, "Passed!" );

				a = new Euler( 7, 8, 9, "XYZ" );
				a.x = 10;
				assert.ok( a.x === 10, "Passed!" );

				a = new Euler( 11, 12, 13, "XYZ" );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				a.x = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.x === 14, "Passed!" );

			} );

			QUnit.test( "y", ( assert ) => {


				var a = new Euler();
				assert.ok( a.y === 0, "Passed!" );

				a = new Euler( 1, 2, 3 );
				assert.ok( a.y === 2, "Passed!" );

				a = new Euler( 4, 5, 6, "XYZ" );
				assert.ok( a.y === 5, "Passed!" );

				a = new Euler( 7, 8, 9, "XYZ" );
				a.y = 10;
				assert.ok( a.y === 10, "Passed!" );

				a = new Euler( 11, 12, 13, "XYZ" );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				a.y = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.y === 14, "Passed!" );

			} );

			QUnit.test( "z", ( assert ) => {


				var a = new Euler();
				assert.ok( a.z === 0, "Passed!" );

				a = new Euler( 1, 2, 3 );
				assert.ok( a.z === 3, "Passed!" );

				a = new Euler( 4, 5, 6, "XYZ" );
				assert.ok( a.z === 6, "Passed!" );

				a = new Euler( 7, 8, 9, "XYZ" );
				a.z = 10;
				assert.ok( a.z === 10, "Passed!" );

				a = new Euler( 11, 12, 13, "XYZ" );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				a.z = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.z === 14, "Passed!" );

			} );

			QUnit.test( "order", ( assert ) => {


				var a = new Euler();
				assert.ok( a.order === Euler.DefaultOrder, "Passed!" );

				a = new Euler( 1, 2, 3 );
				assert.ok( a.order === Euler.DefaultOrder, "Passed!" );

				a = new Euler( 4, 5, 6, "YZX" );
				assert.ok( a.order === "YZX", "Passed!" );

				a = new Euler( 7, 8, 9, "YZX" );
				a.order = "ZXY";
				assert.ok( a.order === "ZXY", "Passed!" );

				a = new Euler( 11, 12, 13, "YZX" );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				a.order = "ZXY";
				assert.ok( b, "Passed!" );
				assert.ok( a.order === "ZXY", "Passed!" );


			} );

			// PUBLIC STUFF
			QUnit.test( "isEuler", ( assert ) => {

				var a = new Euler();
				assert.ok( a.isEuler, "Passed!" );
				var b = new Vector3();
				assert.ok( ! b.isEuler, "Passed!" );


			} );

			QUnit.test( "set/setFromVector3/toVector3", ( assert ) => {

				var a = new Euler();

				a.set( 0, 1, 0, "ZYX" );
				assert.ok( a.equals( eulerAzyx ), "Passed!" );
				assert.ok( ! a.equals( eulerAxyz ), "Passed!" );
				assert.ok( ! a.equals( eulerZero ), "Passed!" );

				var vec = new Vector3( 0, 1, 0 );

				var b = new Euler().setFromVector3( vec, "ZYX" );
				assert.ok( a.equals( b ), "Passed!" );

				var c = b.toVector3();
				assert.ok( c.equals( vec ), "Passed!" );

			} );

			QUnit.test( "clone/copy/equals", ( assert ) => {

				var a = eulerAxyz.clone();
				assert.ok( a.equals( eulerAxyz ), "Passed!" );
				assert.ok( ! a.equals( eulerZero ), "Passed!" );
				assert.ok( ! a.equals( eulerAzyx ), "Passed!" );

				a.copy( eulerAzyx );
				assert.ok( a.equals( eulerAzyx ), "Passed!" );
				assert.ok( ! a.equals( eulerAxyz ), "Passed!" );
				assert.ok( ! a.equals( eulerZero ), "Passed!" );

			} );

			QUnit.test( "Quaternion.setFromEuler/Euler.fromQuaternion", ( assert ) => {

				var testValues = [ eulerZero, eulerAxyz, eulerAzyx ];
				for ( var i = 0; i < testValues.length; i ++ ) {

					var v = testValues[ i ];
					var q = new Quaternion().setFromEuler( v );

					var v2 = new Euler().setFromQuaternion( q, v.order );
					var q2 = new Quaternion().setFromEuler( v2 );
					assert.ok( quatEquals( q, q2 ), "Passed!" );

				}

			} );

			QUnit.test( "Matrix4.setFromEuler/Euler.fromRotationMatrix", ( assert ) => {

				var testValues = [ eulerZero, eulerAxyz, eulerAzyx ];
				for ( var i = 0; i < testValues.length; i ++ ) {

					var v = testValues[ i ];
					var m = new Matrix4().makeRotationFromEuler( v );

					var v2 = new Euler().setFromRotationMatrix( m, v.order );
					var m2 = new Matrix4().makeRotationFromEuler( v2 );
					assert.ok( matrixEquals4$1( m, m2, 0.0001 ), "Passed!" );

				}

			} );

			QUnit.test( "reorder", ( assert ) => {

				var testValues = [ eulerZero, eulerAxyz, eulerAzyx ];
				for ( var i = 0; i < testValues.length; i ++ ) {

					var v = testValues[ i ];
					var q = new Quaternion().setFromEuler( v );

					v.reorder( 'YZX' );
					var q2 = new Quaternion().setFromEuler( v );
					assert.ok( quatEquals( q, q2 ), "Passed!" );

					v.reorder( 'ZXY' );
					var q3 = new Quaternion().setFromEuler( v );
					assert.ok( quatEquals( q, q3 ), "Passed!" );

				}

			} );

			QUnit.test( "set/get properties, check callbacks", ( assert ) => {

				var a = new Euler();
				a._onChange( function () {

					assert.step( "set: onChange called" );

				} );

				a.x = 1;
				a.y = 2;
				a.z = 3;
				a.order = "ZYX";

				assert.strictEqual( a.x, 1, "get: check x" );
				assert.strictEqual( a.y, 2, "get: check y" );
				assert.strictEqual( a.z, 3, "get: check z" );
				assert.strictEqual( a.order, "ZYX", "get: check order" );

				assert.verifySteps( Array( 4 ).fill( "set: onChange called" ) );

			} );

			QUnit.test( "clone/copy, check callbacks", ( assert ) => {

				var a = new Euler( 1, 2, 3, "ZXY" );
				var b = new Euler( 4, 5, 6, "XZY" );
				var cbSucceed = function () {

					assert.ok( true );
					assert.step( "onChange called" );

				};
				var cbFail = function () {

					assert.ok( false );

				};
				a._onChange( cbFail );
				b._onChange( cbFail );

				// clone doesn't trigger onChange
				a = b.clone();
				assert.ok( a.equals( b ), "clone: check if a equals b" );

				// copy triggers onChange once
				a = new Euler( 1, 2, 3, "ZXY" );
				a._onChange( cbSucceed );
				a.copy( b );
				assert.ok( a.equals( b ), "copy: check if a equals b" );
				assert.verifySteps( [ "onChange called" ] );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var order = "YXZ";
				var a = new Euler( x, y, z, order );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], x, "No array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "No array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "No array, no offset: check z" );
				assert.strictEqual( array[ 3 ], order, "No array, no offset: check order" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], x, "With array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "With array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "With array, no offset: check z" );
				assert.strictEqual( array[ 3 ], order, "With array, no offset: check order" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], x, "With array and offset: check x" );
				assert.strictEqual( array[ 2 ], y, "With array and offset: check y" );
				assert.strictEqual( array[ 3 ], z, "With array and offset: check z" );
				assert.strictEqual( array[ 4 ], order, "With array and offset: check order" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Euler();
				var array = [ x, y, z ];
				var cb = function () {

					assert.step( "onChange called" );

				};
				a._onChange( cb );

				a.fromArray( array );
				assert.strictEqual( a.x, x, "No order: check x" );
				assert.strictEqual( a.y, y, "No order: check y" );
				assert.strictEqual( a.z, z, "No order: check z" );
				assert.strictEqual( a.order, "XYZ", "No order: check order" );

				a = new Euler();
				array = [ x, y, z, "ZXY" ];
				a._onChange( cb );
				a.fromArray( array );
				assert.strictEqual( a.x, x, "With order: check x" );
				assert.strictEqual( a.y, y, "With order: check y" );
				assert.strictEqual( a.z, z, "With order: check z" );
				assert.strictEqual( a.order, "ZXY", "With order: check order" );

				assert.verifySteps( Array( 2 ).fill( "onChange called" ) );

			} );

			QUnit.test( "_onChange", ( assert ) => {

				var f = function () {

				};

				var a = new Euler( 11, 12, 13, "XYZ" );
				a._onChange( f );
				assert.ok( a._onChangeCallback === f, "Passed!" );

			} );

			QUnit.test( "_onChangeCallback", ( assert ) => {

				var b = false;
				var a = new Euler( 11, 12, 13, "XYZ" );
				var f = function () {

					b = true;
					assert.ok( a === this, "Passed!" );

				};

				a._onChangeCallback = f;
				assert.ok( a._onChangeCallback === f, "Passed!" );


				a._onChangeCallback();
				assert.ok( b, "Passed!" );

			} );

			// OTHERS
			QUnit.test( "gimbalLocalQuat", ( assert ) => {

				// known problematic quaternions
				var q1 = new Quaternion( 0.5207769385244341, - 0.4783214164122354, 0.520776938524434, 0.47832141641223547 );

				var eulerOrder = "ZYX";

				// create Euler directly from a Quaternion
				var eViaQ1 = new Euler().setFromQuaternion( q1, eulerOrder ); // there is likely a bug here

				// create Euler from Quaternion via an intermediate Matrix4
				var mViaQ1 = new Matrix4().makeRotationFromQuaternion( q1 );
				var eViaMViaQ1 = new Euler().setFromRotationMatrix( mViaQ1, eulerOrder );

				// the results here are different
				assert.ok( eulerEquals( eViaQ1, eViaMViaQ1 ), "Passed!" ); // this result is correct

			} );

		} );

	} );

	/* global QUnit */

	const unit3 = new Vector3( 1, 0, 0 );

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Frustum', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Frustum();

				assert.ok( a.planes !== undefined, "Passed!" );
				assert.ok( a.planes.length === 6, "Passed!" );

				var pDefault = new Plane();
				for ( var i = 0; i < 6; i ++ ) {

					assert.ok( a.planes[ i ].equals( pDefault ), "Passed!" );

				}

				var p0 = new Plane( unit3, - 1 );
				var p1 = new Plane( unit3, 1 );
				var p2 = new Plane( unit3, 2 );
				var p3 = new Plane( unit3, 3 );
				var p4 = new Plane( unit3, 4 );
				var p5 = new Plane( unit3, 5 );

				var a = new Frustum( p0, p1, p2, p3, p4, p5 );
				assert.ok( a.planes[ 0 ].equals( p0 ), "Passed!" );
				assert.ok( a.planes[ 1 ].equals( p1 ), "Passed!" );
				assert.ok( a.planes[ 2 ].equals( p2 ), "Passed!" );
				assert.ok( a.planes[ 3 ].equals( p3 ), "Passed!" );
				assert.ok( a.planes[ 4 ].equals( p4 ), "Passed!" );
				assert.ok( a.planes[ 5 ].equals( p5 ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Frustum();
				var p0 = new Plane( unit3, - 1 );
				var p1 = new Plane( unit3, 1 );
				var p2 = new Plane( unit3, 2 );
				var p3 = new Plane( unit3, 3 );
				var p4 = new Plane( unit3, 4 );
				var p5 = new Plane( unit3, 5 );

				a.set( p0, p1, p2, p3, p4, p5 );

				assert.ok( a.planes[ 0 ].equals( p0 ), "Check plane #0" );
				assert.ok( a.planes[ 1 ].equals( p1 ), "Check plane #1" );
				assert.ok( a.planes[ 2 ].equals( p2 ), "Check plane #2" );
				assert.ok( a.planes[ 3 ].equals( p3 ), "Check plane #3" );
				assert.ok( a.planes[ 4 ].equals( p4 ), "Check plane #4" );
				assert.ok( a.planes[ 5 ].equals( p5 ), "Check plane #5" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var p0 = new Plane( unit3, - 1 );
				var p1 = new Plane( unit3, 1 );
				var p2 = new Plane( unit3, 2 );
				var p3 = new Plane( unit3, 3 );
				var p4 = new Plane( unit3, 4 );
				var p5 = new Plane( unit3, 5 );

				var b = new Frustum( p0, p1, p2, p3, p4, p5 );
				var a = b.clone();
				assert.ok( a.planes[ 0 ].equals( p0 ), "Passed!" );
				assert.ok( a.planes[ 1 ].equals( p1 ), "Passed!" );
				assert.ok( a.planes[ 2 ].equals( p2 ), "Passed!" );
				assert.ok( a.planes[ 3 ].equals( p3 ), "Passed!" );
				assert.ok( a.planes[ 4 ].equals( p4 ), "Passed!" );
				assert.ok( a.planes[ 5 ].equals( p5 ), "Passed!" );

				// ensure it is a true copy by modifying source
				a.planes[ 0 ].copy( p1 );
				assert.ok( b.planes[ 0 ].equals( p0 ), "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var p0 = new Plane( unit3, - 1 );
				var p1 = new Plane( unit3, 1 );
				var p2 = new Plane( unit3, 2 );
				var p3 = new Plane( unit3, 3 );
				var p4 = new Plane( unit3, 4 );
				var p5 = new Plane( unit3, 5 );

				var b = new Frustum( p0, p1, p2, p3, p4, p5 );
				var a = new Frustum().copy( b );
				assert.ok( a.planes[ 0 ].equals( p0 ), "Passed!" );
				assert.ok( a.planes[ 1 ].equals( p1 ), "Passed!" );
				assert.ok( a.planes[ 2 ].equals( p2 ), "Passed!" );
				assert.ok( a.planes[ 3 ].equals( p3 ), "Passed!" );
				assert.ok( a.planes[ 4 ].equals( p4 ), "Passed!" );
				assert.ok( a.planes[ 5 ].equals( p5 ), "Passed!" );

				// ensure it is a true copy by modifying source
				b.planes[ 0 ] = p1;
				assert.ok( a.planes[ 0 ].equals( p0 ), "Passed!" );

			} );

			QUnit.test( "setFromProjectionMatrix/makeOrthographic/containsPoint", ( assert ) => {

				var m = new Matrix4().makeOrthographic( - 1, 1, - 1, 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );

				assert.ok( ! a.containsPoint( new Vector3( 0, 0, 0 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 50 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( - 1, - 1, - 1.001 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 1.1, - 1.1, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 1, 1, - 1.001 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 1.1, 1.1, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 100 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( - 1, - 1, - 100 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 1.1, - 1.1, - 100.1 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 1, 1, - 100 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 1.1, 1.1, - 100.1 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 0, 0, - 101 ) ), "Passed!" );

			} );

			QUnit.test( "setFromProjectionMatrix/makePerspective/containsPoint", ( assert ) => {

				var m = new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );

				assert.ok( ! a.containsPoint( new Vector3( 0, 0, 0 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 50 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( - 1, - 1, - 1.001 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 1.1, - 1.1, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 1, 1, - 1.001 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 1.1, 1.1, - 1.001 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 0, 0, - 99.999 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( - 99.999, - 99.999, - 99.999 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 100.1, - 100.1, - 100.1 ) ), "Passed!" );
				assert.ok( a.containsPoint( new Vector3( 99.999, 99.999, - 99.999 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 100.1, 100.1, - 100.1 ) ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( 0, 0, - 101 ) ), "Passed!" );

			} );

			QUnit.test( "setFromProjectionMatrix/makePerspective/intersectsSphere", ( assert ) => {

				var m = new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );

				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( 0, 0, 0 ), 0 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( 0, 0, 0 ), 0.9 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 0, 0, 0 ), 1.1 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 0, 0, - 50 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 0, 0, - 1.001 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( - 1, - 1, - 1.001 ), 0 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( - 1.1, - 1.1, - 1.001 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( - 1.1, - 1.1, - 1.001 ), 0.5 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 1, 1, - 1.001 ), 0 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( 1.1, 1.1, - 1.001 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 1.1, 1.1, - 1.001 ), 0.5 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 0, 0, - 99.999 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( - 99.999, - 99.999, - 99.999 ), 0 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( - 100.1, - 100.1, - 100.1 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( - 100.1, - 100.1, - 100.1 ), 0.5 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 99.999, 99.999, - 99.999 ), 0 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( 100.1, 100.1, - 100.1 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 100.1, 100.1, - 100.1 ), 0.2 ) ), "Passed!" );
				assert.ok( ! a.intersectsSphere( new Sphere( new Vector3( 0, 0, - 101 ), 0 ) ), "Passed!" );
				assert.ok( a.intersectsSphere( new Sphere( new Vector3( 0, 0, - 101 ), 1.1 ) ), "Passed!" );

			} );

			QUnit.test( "intersectsObject", ( assert ) => {

				var m = new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );
				var object = new Mesh( new BoxGeometry( 1, 1, 1 ) );
				var intersects;

				intersects = a.intersectsObject( object );
				assert.notOk( intersects, "No intersection" );

				object.position.set( - 1, - 1, - 1 );
				object.updateMatrixWorld();

				intersects = a.intersectsObject( object );
				assert.ok( intersects, "Successful intersection" );

				object.position.set( 1, 1, 1 );
				object.updateMatrixWorld();

				intersects = a.intersectsObject( object );
				assert.notOk( intersects, "No intersection" );

			} );

			QUnit.test( "intersectsSprite", ( assert ) => {

				var m = new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );
				var sprite = new Sprite();
				var intersects;

				intersects = a.intersectsSprite( sprite );
				assert.notOk( intersects, "No intersection" );

				sprite.position.set( - 1, - 1, - 1 );
				sprite.updateMatrixWorld();

				intersects = a.intersectsSprite( sprite );
				assert.ok( intersects, "Successful intersection" );

			} );

			QUnit.todo( "intersectsSphere", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var m = new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 100 );
				var a = new Frustum().setFromProjectionMatrix( m );
				var box = new Box3( zero3.clone(), one3.clone() );
				var intersects;

				intersects = a.intersectsBox( box );
				assert.notOk( intersects, "No intersection" );

				// add eps so that we prevent box touching the frustum, which might intersect depending on floating point numerics
				box.translate( new Vector3( - 1 - eps, - 1 - eps, - 1 - eps ) );

				intersects = a.intersectsBox( box );
				assert.ok( intersects, "Successful intersection" );

			} );

			QUnit.todo( "containsPoint", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Interpolant', () => {

			// Since this is an abstract base class, we have to make it concrete in order
			// to QUnit.test its functionality...

			function Mock( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

				Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

			}

			Mock.prototype = Object.create( Interpolant.prototype );

			Mock.prototype.intervalChanged_ = function intervalChanged( i1, t0, t1 ) {

				if ( Mock.calls !== null ) {

					Mock.calls.push( {
						func: 'intervalChanged',
						args: [ i1, t0, t1 ]
					} );

				}

			};

			Mock.prototype.interpolate_ = function interpolate( i1, t0, t, t1 ) {

				if ( Mock.calls !== null ) {

					Mock.calls.push( {
						func: 'interpolate',
						args: [ i1, t0, t, t1 ]
					} );

				}

				return this.copySampleValue_( i1 - 1 );

			};

			Mock.prototype.beforeStart_ = function beforeStart( i, t, t0 ) {

				if ( Mock.calls !== null ) {

					Mock.calls.push( {
						func: 'beforeStart',
						args: [ i, t, t0 ]
					} );

				}

				return this.copySampleValue_( i );

			};

			Mock.prototype.afterEnd_ = function afterEnd( i, tN, t ) {

				if ( Mock.calls !== null ) {

					Mock.calls.push( {
						func: 'afterEnd',
						args: [ i, tN, t ]
					} );

				}

				return this.copySampleValue_( i );

			};

			// Call capturing facility

			Mock.calls = null;

			Mock.captureCall = function ( args ) {

				if ( Mock.calls !== null ) {

					Mock.calls.push( {
						func: Mock.captureCall.caller.name,
						args: Array.prototype.slice.call( args )
					} );

				}

			};

			// Tests

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "evaluate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PRIVATE STUFF
			QUnit.test( "copySampleValue_", ( assert ) => {

				var interpolant = new Mock( null, [ 1, 11, 2, 22, 3, 33 ], 2, [] );

				assert.deepEqual( interpolant.copySampleValue_( 0 ), [ 1, 11 ], "sample fetch (0)" );
				assert.deepEqual( interpolant.copySampleValue_( 1 ), [ 2, 22 ], "sample fetch (1)" );
				assert.deepEqual( interpolant.copySampleValue_( 2 ), [ 3, 33 ], "first sample (2)" );

			} );

			QUnit.test( "evaluate -> intervalChanged_ / interpolate_", ( assert ) => {

				var actual, expect;

				var interpolant = new Mock( [ 11, 22, 33, 44, 55, 66, 77, 88, 99 ], null, 0, null );

				Mock.calls = [];
				interpolant.evaluate( 11 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 12 ); // same interval

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 12, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 22 ); // step forward

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 2, 22, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 2, 22, 22, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2 );

				Mock.calls = [];
				interpolant.evaluate( 21 ); // step back

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 21, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 20 ); // same interval

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 20, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 43 ); // two steps forward

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 3, 33, 44 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 3, 33, 43, 44 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 12 ); // two steps back

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 12, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 77 ); // random access

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 7, 77, 88 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 7, 77, 77, 88 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 80 ); // same interval

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'interpolate',
					args: [ 7, 77, 80, 88 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 36 ); // random access

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 3, 33, 44 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 3, 33, 36, 44 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 24 ); // fast reset / loop (2nd)

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 2, 22, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 2, 22, 24, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				Mock.calls = [];
				interpolant.evaluate( 16 ); // fast reset / loop (2nd)

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 16, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

			} );

			QUnit.test( "evaulate -> beforeStart_ [once]", ( assert ) => {

				var actual, expect;

				var interpolant = new Mock( [ 11, 22, 33 ], null, 0, null );

				Mock.calls = [];
				interpolant.evaluate( 10 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'beforeStart',
					args: [ 0, 10, 11 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				// Check operation resumes normally and intervalChanged gets called
				Mock.calls = [];
				interpolant.evaluate( 11 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				// Back off-bounds
				Mock.calls = [];
				interpolant.evaluate( 10 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'beforeStart',
					args: [ 0, 10, 11 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

			} );

			QUnit.test( "evaluate -> beforeStart_ [twice]", ( assert ) => {

				var actual, expect;

				var interpolant = new Mock( [ 11, 22, 33 ], null, 0, null );

				Mock.calls = [];
				interpolant.evaluate( 10 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'beforeStart',
					args: [ 0, 10, 11 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				Mock.calls = []; // again - consider changed state
				interpolant.evaluate( 10 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'beforeStart',
					args: [ 0, 10, 11 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				// Check operation resumes normally and intervalChanged gets called
				Mock.calls = [];
				interpolant.evaluate( 11 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 1, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 1, 11, 11, 22 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

			} );

			QUnit.test( "evaluate -> afterEnd_ [once]", ( assert ) => {

				var actual, expect;

				var interpolant = new Mock( [ 11, 22, 33 ], null, 0, null );

				Mock.calls = [];
				interpolant.evaluate( 33 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'afterEnd',
					args: [ 2, 33, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				// Check operation resumes normally and intervalChanged gets called
				Mock.calls = [];
				interpolant.evaluate( 32 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 2, 22, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 2, 22, 32, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

				// Back off-bounds
				Mock.calls = [];
				interpolant.evaluate( 33 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'afterEnd',
					args: [ 2, 33, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

			} );

			QUnit.test( "evaluate -> afterEnd_ [twice]", ( assert ) => {

				var actual, expect;

				var interpolant = new Mock( [ 11, 22, 33 ], null, 0, null );

				Mock.calls = [];
				interpolant.evaluate( 33 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'afterEnd',
					args: [ 2, 33, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				Mock.calls = []; // again - consider changed state
				interpolant.evaluate( 33 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'afterEnd',
					args: [ 2, 33, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 1, "no further calls" );

				// Check operation resumes normally and intervalChanged gets called
				Mock.calls = [];
				interpolant.evaluate( 32 );

				actual = Mock.calls[ 0 ];
				expect = {
					func: 'intervalChanged',
					args: [ 2, 22, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				actual = Mock.calls[ 1 ];
				expect = {
					func: 'interpolate',
					args: [ 2, 22, 32, 33 ]
				};
				assert.deepEqual( actual, expect, JSON.stringify( expect ) );

				assert.ok( Mock.calls.length === 2, "no further calls" );

			} );

		} );

	} );

	const _startP = /*@__PURE__*/ new Vector3();
	const _startEnd = /*@__PURE__*/ new Vector3();

	class Line3 {

		constructor( start = new Vector3(), end = new Vector3() ) {

			this.start = start;
			this.end = end;

		}

		set( start, end ) {

			this.start.copy( start );
			this.end.copy( end );

			return this;

		}

		copy( line ) {

			this.start.copy( line.start );
			this.end.copy( line.end );

			return this;

		}

		getCenter( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

		}

		delta( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();

			}

			return target.subVectors( this.end, this.start );

		}

		distanceSq() {

			return this.start.distanceToSquared( this.end );

		}

		distance() {

			return this.start.distanceTo( this.end );

		}

		at( t, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		closestPointToPointParameter( point, clampToLine ) {

			_startP.subVectors( point, this.start );
			_startEnd.subVectors( this.end, this.start );

			const startEnd2 = _startEnd.dot( _startEnd );
			const startEnd_startP = _startEnd.dot( _startP );

			let t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = MathUtils.clamp( t, 0, 1 );

			}

			return t;

		}

		closestPointToPoint( point, clampToLine, target ) {

			const t = this.closestPointToPointParameter( point, clampToLine );

			if ( target === undefined ) {

				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			return this.delta( target ).multiplyScalar( t ).add( this.start );

		}

		applyMatrix4( matrix ) {

			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );

			return this;

		}

		equals( line ) {

			return line.start.equals( this.start ) && line.end.equals( this.end );

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Line3', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Line3();
				assert.ok( a.start.equals( zero3 ), "Passed!" );
				assert.ok( a.end.equals( zero3 ), "Passed!" );

				var a = new Line3( two3.clone(), one3.clone() );
				assert.ok( a.start.equals( two3 ), "Passed!" );
				assert.ok( a.end.equals( one3 ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Line3();

				a.set( one3, one3 );
				assert.ok( a.start.equals( one3 ), "Passed!" );
				assert.ok( a.end.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "copy/equals", ( assert ) => {

				var a = new Line3( zero3.clone(), one3.clone() );
				var b = new Line3().copy( a );
				assert.ok( b.start.equals( zero3 ), "Passed!" );
				assert.ok( b.end.equals( one3 ), "Passed!" );

				// ensure that it is a true copy
				a.start = zero3;
				a.end = one3;
				assert.ok( b.start.equals( zero3 ), "Passed!" );
				assert.ok( b.end.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "clone/equal", ( assert ) => {

				var a = new Line3();
				var b = new Line3( zero3, new Vector3( 1, 1, 1 ) );
				var c = new Line3( zero3, new Vector3( 1, 1, 0 ) );

				assert.notOk( a.equals( b ), "Check a and b aren't equal" );
				assert.notOk( a.equals( c ), "Check a and c aren't equal" );
				assert.notOk( b.equals( c ), "Check b and c aren't equal" );

				var a = b.clone();
				assert.ok( a.equals( b ), "Check a and b are equal after clone()" );
				assert.notOk( a.equals( c ), "Check a and c aren't equal after clone()" );

				a.set( zero3, zero3 );
				assert.notOk( a.equals( b ), "Check a and b are not equal after modification" );

			} );

			QUnit.test( "getCenter", ( assert ) => {

				var center = new Vector3();

				var a = new Line3( zero3.clone(), two3.clone() );
				assert.ok( a.getCenter( center ).equals( one3.clone() ), "Passed" );

			} );

			QUnit.test( "delta", ( assert ) => {

				var delta = new Vector3();

				var a = new Line3( zero3.clone(), two3.clone() );
				assert.ok( a.delta( delta ).equals( two3.clone() ), "Passed" );

			} );

			QUnit.test( "distanceSq", ( assert ) => {

				var a = new Line3( zero3, zero3 );
				var b = new Line3( zero3, one3 );
				var c = new Line3( one3.clone().negate(), one3 );
				var d = new Line3( two3.clone().multiplyScalar( - 2 ), two3.clone().negate() );

				assert.numEqual( a.distanceSq(), 0, "Check squared distance for zero-length line" );
				assert.numEqual( b.distanceSq(), 3, "Check squared distance for simple line" );
				assert.numEqual( c.distanceSq(), 12, "Check squared distance for negative to positive endpoints" );
				assert.numEqual( d.distanceSq(), 12, "Check squared distance for negative to negative endpoints" );


			} );

			QUnit.test( "distance", ( assert ) => {

				var a = new Line3( zero3, zero3 );
				var b = new Line3( zero3, one3 );
				var c = new Line3( one3.clone().negate(), one3 );
				var d = new Line3( two3.clone().multiplyScalar( - 2 ), two3.clone().negate() );

				assert.numEqual( a.distance(), 0, "Check distance for zero-length line" );
				assert.numEqual( b.distance(), Math.sqrt( 3 ), "Check distance for simple line" );
				assert.numEqual( c.distance(), Math.sqrt( 12 ), "Check distance for negative to positive endpoints" );
				assert.numEqual( d.distance(), Math.sqrt( 12 ), "Check distance for negative to negative endpoints" );

			} );

			QUnit.test( "at", ( assert ) => {

				var a = new Line3( one3.clone(), new Vector3( 1, 1, 2 ) );
				var point = new Vector3();

				a.at( - 1, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 0 ) ) < 0.0001, "Passed!" );
				a.at( 0, point );
				assert.ok( point.distanceTo( one3.clone() ) < 0.0001, "Passed!" );
				a.at( 1, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 2 ) ) < 0.0001, "Passed!" );
				a.at( 2, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 3 ) ) < 0.0001, "Passed!" );

			} );

			QUnit.test( "closestPointToPoint/closestPointToPointParameter", ( assert ) => {

				var a = new Line3( one3.clone(), new Vector3( 1, 1, 2 ) );
				var point = new Vector3();

				// nearby the ray
				assert.ok( a.closestPointToPointParameter( zero3.clone(), true ) == 0, "Passed!" );
				a.closestPointToPoint( zero3.clone(), true, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 1 ) ) < 0.0001, "Passed!" );

				// nearby the ray
				assert.ok( a.closestPointToPointParameter( zero3.clone(), false ) == - 1, "Passed!" );
				 a.closestPointToPoint( zero3.clone(), false, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 0 ) ) < 0.0001, "Passed!" );

				// nearby the ray
				assert.ok( a.closestPointToPointParameter( new Vector3( 1, 1, 5 ), true ) == 1, "Passed!" );
				a.closestPointToPoint( new Vector3( 1, 1, 5 ), true, point );
				assert.ok( point.distanceTo( new Vector3( 1, 1, 2 ) ) < 0.0001, "Passed!" );

				// exactly on the ray
				assert.ok( a.closestPointToPointParameter( one3.clone(), true ) == 0, "Passed!" );
				a.closestPointToPoint( one3.clone(), true, point );
				assert.ok( point.distanceTo( one3.clone() ) < 0.0001, "Passed!" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Line3( zero3.clone(), two3.clone() );
				var b = new Vector4( two3.x, two3.y, two3.z, 1 );
				var m = new Matrix4().makeTranslation( x, y, z );
				var v = new Vector3( x, y, z );

				a.applyMatrix4( m );
				assert.ok( a.start.equals( v ), "Translation: check start" );
				assert.ok( a.end.equals( new Vector3( 2 + x, 2 + y, 2 + z ) ), "Translation: check start" );

				// reset starting conditions
				a.set( zero3.clone(), two3.clone() );
				m.makeRotationX( Math.PI );

				a.applyMatrix4( m );
				b.applyMatrix4( m );

				assert.ok( a.start.equals( zero3 ), "Rotation: check start" );
				assert.numEqual( a.end.x, b.x / b.w, "Rotation: check end.x" );
				assert.numEqual( a.end.y, b.y / b.w, "Rotation: check end.y" );
				assert.numEqual( a.end.z, b.z / b.w, "Rotation: check end.z" );

				// reset starting conditions
				a.set( zero3.clone(), two3.clone() );
				b.set( two3.x, two3.y, two3.z, 1 );
				m.setPosition( v );

				a.applyMatrix4( m );
				b.applyMatrix4( m );

				assert.ok( a.start.equals( v ), "Both: check start" );
				assert.numEqual( a.end.x, b.x / b.w, "Both: check end.x" );
				assert.numEqual( a.end.y, b.y / b.w, "Both: check end.y" );
				assert.numEqual( a.end.z, b.z / b.w, "Both: check end.z" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Line3( zero3.clone(), zero3.clone() );
				var b = new Line3();
				assert.ok( a.equals( b ), "Passed" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Math', () => {

			// PUBLIC STUFF
			QUnit.test( "generateUUID", ( assert ) => {

				var a = MathUtils.generateUUID();
				var regex = /[A-Z0-9]{8}-[A-Z0-9]{4}-4[A-Z0-9]{3}-[A-Z0-9]{4}-[A-Z0-9]{12}/i;
				// note the fixed '4' here ----------^

				assert.ok( regex.test( a ), "Generated UUID matches the expected pattern" );

			} );

			QUnit.test( "clamp", ( assert ) => {

				assert.strictEqual( MathUtils.clamp( 0.5, 0, 1 ), 0.5, "Value already within limits" );
				assert.strictEqual( MathUtils.clamp( 0, 0, 1 ), 0, "Value equal to one limit" );
				assert.strictEqual( MathUtils.clamp( - 0.1, 0, 1 ), 0, "Value too low" );
				assert.strictEqual( MathUtils.clamp( 1.1, 0, 1 ), 1, "Value too high" );

			} );

			QUnit.test( "euclideanModulo", ( assert ) => {

				assert.ok( isNaN( MathUtils.euclideanModulo( 6, 0 ) ), "Division by zero returns NaN" );
				assert.strictEqual( MathUtils.euclideanModulo( 6, 1 ), 0, "Divison by trivial divisor" );
				assert.strictEqual( MathUtils.euclideanModulo( 6, 2 ), 0, "Divison by non-trivial divisor" );
				assert.strictEqual( MathUtils.euclideanModulo( 6, 5 ), 1, "Divison by itself - 1" );
				assert.strictEqual( MathUtils.euclideanModulo( 6, 6 ), 0, "Divison by itself" );
				assert.strictEqual( MathUtils.euclideanModulo( 6, 7 ), 6, "Divison by itself + 1" );

			} );

			QUnit.test( "mapLinear", ( assert ) => {

				assert.strictEqual( MathUtils.mapLinear( 0.5, 0, 1, 0, 10 ), 5, "Value within range" );
				assert.strictEqual( MathUtils.mapLinear( 0.0, 0, 1, 0, 10 ), 0, "Value equal to lower boundary" );
				assert.strictEqual( MathUtils.mapLinear( 1.0, 0, 1, 0, 10 ), 10, "Value equal to upper boundary" );

			} );

			QUnit.test( "lerp", ( assert ) => {


				assert.strictEqual( MathUtils.lerp( 1, 2, 0 ), 1, "Value equal to lower boundary" );
				assert.strictEqual( MathUtils.lerp( 1, 2, 1 ), 2, "Value equal to upper boundary" );
				assert.strictEqual( MathUtils.lerp( 1, 2, 0.4 ), 1.4, "Value within range" );


			} );

			QUnit.test( "damp", ( assert ) => {

				assert.strictEqual( MathUtils.damp( 1, 2, 0, 0.016 ), 1, "Value equal to lower boundary" );
				assert.strictEqual( MathUtils.damp( 1, 2, 10, 0.016 ), 1.1478562110337887, "Value within range" );

			} );

			QUnit.test( "smoothstep", ( assert ) => {

				assert.strictEqual( MathUtils.smoothstep( - 1, 0, 2 ), 0, "Value lower than minimum" );
				assert.strictEqual( MathUtils.smoothstep( 0, 0, 2 ), 0, "Value equal to minimum" );
				assert.strictEqual( MathUtils.smoothstep( 0.5, 0, 2 ), 0.15625, "Value within limits" );
				assert.strictEqual( MathUtils.smoothstep( 1, 0, 2 ), 0.5, "Value within limits" );
				assert.strictEqual( MathUtils.smoothstep( 1.5, 0, 2 ), 0.84375, "Value within limits" );
				assert.strictEqual( MathUtils.smoothstep( 2, 0, 2 ), 1, "Value equal to maximum" );
				assert.strictEqual( MathUtils.smoothstep( 3, 0, 2 ), 1, "Value highter than maximum" );

			} );

			QUnit.test( "smootherstep", ( assert ) => {

				assert.strictEqual( MathUtils.smootherstep( - 1, 0, 2 ), 0, "Value lower than minimum" );
				assert.strictEqual( MathUtils.smootherstep( 0, 0, 2 ), 0, "Value equal to minimum" );
				assert.strictEqual( MathUtils.smootherstep( 0.5, 0, 2 ), 0.103515625, "Value within limits" );
				assert.strictEqual( MathUtils.smootherstep( 1, 0, 2 ), 0.5, "Value within limits" );
				assert.strictEqual( MathUtils.smootherstep( 1.5, 0, 2 ), 0.896484375, "Value within limits" );
				assert.strictEqual( MathUtils.smootherstep( 2, 0, 2 ), 1, "Value equal to maximum" );
				assert.strictEqual( MathUtils.smootherstep( 3, 0, 2 ), 1, "Value highter than maximum" );

			} );

			QUnit.test( "randInt", ( assert ) => {

				var low = 1, high = 3;
				var a = MathUtils.randInt( low, high );

				assert.ok( a >= low, "Value equal to or higher than lower limit" );
				assert.ok( a <= high, "Value equal to or lower than upper limit" );

			} );

			QUnit.test( "randFloat", ( assert ) => {

				var low = 1, high = 3;
				var a = MathUtils.randFloat( low, high );

				assert.ok( a >= low, "Value equal to or higher than lower limit" );
				assert.ok( a <= high, "Value equal to or lower than upper limit" );

			} );

			QUnit.test( "randFloatSpread", ( assert ) => {

				var a = MathUtils.randFloatSpread( 3 );

				assert.ok( a > - 3 / 2, "Value higher than lower limit" );
				assert.ok( a < 3 / 2, "Value lower than upper limit" );

			} );

			QUnit.test( "degToRad", ( assert ) => {

				assert.strictEqual( MathUtils.degToRad( 0 ), 0, "0 degrees" );
				assert.strictEqual( MathUtils.degToRad( 90 ), Math.PI / 2, "90 degrees" );
				assert.strictEqual( MathUtils.degToRad( 180 ), Math.PI, "180 degrees" );
				assert.strictEqual( MathUtils.degToRad( 360 ), Math.PI * 2, "360 degrees" );

			} );

			QUnit.test( "radToDeg", ( assert ) => {

				assert.strictEqual( MathUtils.radToDeg( 0 ), 0, "0 radians" );
				assert.strictEqual( MathUtils.radToDeg( Math.PI / 2 ), 90, "Math.PI / 2 radians" );
				assert.strictEqual( MathUtils.radToDeg( Math.PI ), 180, "Math.PI radians" );
				assert.strictEqual( MathUtils.radToDeg( Math.PI * 2 ), 360, "Math.PI * 2 radians" );

			} );

			QUnit.test( "isPowerOfTwo", ( assert ) => {

				assert.strictEqual( MathUtils.isPowerOfTwo( 0 ), false, "0 is not a PoT" );
				assert.strictEqual( MathUtils.isPowerOfTwo( 1 ), true, "1 is a PoT" );
				assert.strictEqual( MathUtils.isPowerOfTwo( 2 ), true, "2 is a PoT" );
				assert.strictEqual( MathUtils.isPowerOfTwo( 3 ), false, "3 is not a PoT" );
				assert.strictEqual( MathUtils.isPowerOfTwo( 4 ), true, "4 is a PoT" );

			} );

			QUnit.test( "ceilPowerOfTwo", ( assert ) => {

				assert.strictEqual( MathUtils.ceilPowerOfTwo( 1 ), 1, "Closest higher PoT to 1 is 1" );
				assert.strictEqual( MathUtils.ceilPowerOfTwo( 3 ), 4, "Closest higher PoT to 3 is 4" );
				assert.strictEqual( MathUtils.ceilPowerOfTwo( 4 ), 4, "Closest higher PoT to 4 is 4" );

			} );

			QUnit.test( "floorPowerOfTwo", ( assert ) => {

				assert.strictEqual( MathUtils.floorPowerOfTwo( 1 ), 1, "Closest lower PoT to 1 is 1" );
				assert.strictEqual( MathUtils.floorPowerOfTwo( 3 ), 2, "Closest lower PoT to 3 is 2" );
				assert.strictEqual( MathUtils.floorPowerOfTwo( 4 ), 4, "Closest lower PoT to 4 is 4" );

			} );


			QUnit.test( "pingpong", ( assert ) => {

				assert.strictEqual( MathUtils.pingpong( 2.5 ), 0.5, "Value at 2.5 is 0.5" );
				assert.strictEqual( MathUtils.pingpong( 2.5, 2 ), 1.5, "Value at 2.5 with length of 2 is 1.5" );
				assert.strictEqual( MathUtils.pingpong( - 1.5 ), 0.5, "Value at -1.5 is 0.5" );

			} );

		} );

	} );

	/* global QUnit */

	function matrixEquals3( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		if ( a.elements.length != b.elements.length ) {

			return false;

		}

		for ( var i = 0, il = a.elements.length; i < il; i ++ ) {

			var delta = a.elements[ i ] - b.elements[ i ];
			if ( delta > tolerance ) {

				return false;

			}

		}

		return true;

	}

	function toMatrix4( m3 ) {

		var result = new Matrix4();
		var re = result.elements;
		var me = m3.elements;
		re[ 0 ] = me[ 0 ];
		re[ 1 ] = me[ 1 ];
		re[ 2 ] = me[ 2 ];
		re[ 4 ] = me[ 3 ];
		re[ 5 ] = me[ 4 ];
		re[ 6 ] = me[ 5 ];
		re[ 8 ] = me[ 6 ];
		re[ 9 ] = me[ 7 ];
		re[ 10 ] = me[ 8 ];

		return result;

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Matrix3', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Matrix3();
				assert.ok( a.determinant() == 1, "Passed!" );

				var b = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 3 );
				assert.ok( b.elements[ 2 ] == 6 );
				assert.ok( b.elements[ 3 ] == 1 );
				assert.ok( b.elements[ 4 ] == 4 );
				assert.ok( b.elements[ 5 ] == 7 );
				assert.ok( b.elements[ 6 ] == 2 );
				assert.ok( b.elements[ 7 ] == 5 );
				assert.ok( b.elements[ 8 ] == 8 );

				assert.ok( ! matrixEquals3( a, b ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "isMatrix3", ( assert ) => {

				var a = new Matrix3();
				assert.ok( a.isMatrix3 === true, "Passed!" );

				var b = new Matrix4();
				assert.ok( ! b.isMatrix3, "Passed!" );

			} );

			QUnit.test( "set", ( assert ) => {

				var b = new Matrix3();
				assert.ok( b.determinant() == 1, "Passed!" );

				b.set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 3 );
				assert.ok( b.elements[ 2 ] == 6 );
				assert.ok( b.elements[ 3 ] == 1 );
				assert.ok( b.elements[ 4 ] == 4 );
				assert.ok( b.elements[ 5 ] == 7 );
				assert.ok( b.elements[ 6 ] == 2 );
				assert.ok( b.elements[ 7 ] == 5 );
				assert.ok( b.elements[ 8 ] == 8 );

			} );

			QUnit.test( "identity", ( assert ) => {

				var b = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 3 );
				assert.ok( b.elements[ 2 ] == 6 );
				assert.ok( b.elements[ 3 ] == 1 );
				assert.ok( b.elements[ 4 ] == 4 );
				assert.ok( b.elements[ 5 ] == 7 );
				assert.ok( b.elements[ 6 ] == 2 );
				assert.ok( b.elements[ 7 ] == 5 );
				assert.ok( b.elements[ 8 ] == 8 );

				var a = new Matrix3();
				assert.ok( ! matrixEquals3( a, b ), "Passed!" );

				b.identity();
				assert.ok( matrixEquals3( a, b ), "Passed!" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var a = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				var b = a.clone();

				assert.ok( matrixEquals3( a, b ), "Passed!" );

				// ensure that it is a true copy
				a.elements[ 0 ] = 2;
				assert.ok( ! matrixEquals3( a, b ), "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				var b = new Matrix3().copy( a );

				assert.ok( matrixEquals3( a, b ), "Passed!" );

				// ensure that it is a true copy
				a.elements[ 0 ] = 2;
				assert.ok( ! matrixEquals3( a, b ), "Passed!" );

			} );

			QUnit.test( "setFromMatrix4", ( assert ) => {


				var a = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				var b = new Matrix3();
				var c = new Matrix3().set( 0, 1, 2, 4, 5, 6, 8, 9, 10 );
				b.setFromMatrix4( a );
				assert.ok( b.equals( c ) );

			} );

			QUnit.test( "multiply/premultiply", ( assert ) => {

				// both simply just wrap multiplyMatrices
				var a = new Matrix3().set( 2, 3, 5, 7, 11, 13, 17, 19, 23 );
				var b = new Matrix3().set( 29, 31, 37, 41, 43, 47, 53, 59, 61 );
				var expectedMultiply = [ 446, 1343, 2491, 486, 1457, 2701, 520, 1569, 2925 ];
				var expectedPremultiply = [ 904, 1182, 1556, 1131, 1489, 1967, 1399, 1845, 2435 ];

				a.multiply( b );
				assert.deepEqual( a.elements, expectedMultiply, "multiply: check result" );

				a.set( 2, 3, 5, 7, 11, 13, 17, 19, 23 );
				a.premultiply( b );
				assert.deepEqual( a.elements, expectedPremultiply, "premultiply: check result" );

			} );

			QUnit.test( "multiplyMatrices", ( assert ) => {

				// Reference:
				//
				// #!/usr/bin/env python
				// from __future__ import print_function
				// import numpy as np
				// print(
				//     np.dot(
				//         np.reshape([2, 3, 5, 7, 11, 13, 17, 19, 23], (3, 3)),
				//         np.reshape([29, 31, 37, 41, 43, 47, 53, 59, 61], (3, 3))
				//     )
				// )
				//
				// [[ 446  486  520]
				//  [1343 1457 1569]
				//  [2491 2701 2925]]
				var lhs = new Matrix3().set( 2, 3, 5, 7, 11, 13, 17, 19, 23 );
				var rhs = new Matrix3().set( 29, 31, 37, 41, 43, 47, 53, 59, 61 );
				var ans = new Matrix3();

				ans.multiplyMatrices( lhs, rhs );

				assert.ok( ans.elements[ 0 ] == 446 );
				assert.ok( ans.elements[ 1 ] == 1343 );
				assert.ok( ans.elements[ 2 ] == 2491 );
				assert.ok( ans.elements[ 3 ] == 486 );
				assert.ok( ans.elements[ 4 ] == 1457 );
				assert.ok( ans.elements[ 5 ] == 2701 );
				assert.ok( ans.elements[ 6 ] == 520 );
				assert.ok( ans.elements[ 7 ] == 1569 );
				assert.ok( ans.elements[ 8 ] == 2925 );

			} );

			QUnit.test( "multiplyScalar", ( assert ) => {

				var b = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 3 );
				assert.ok( b.elements[ 2 ] == 6 );
				assert.ok( b.elements[ 3 ] == 1 );
				assert.ok( b.elements[ 4 ] == 4 );
				assert.ok( b.elements[ 5 ] == 7 );
				assert.ok( b.elements[ 6 ] == 2 );
				assert.ok( b.elements[ 7 ] == 5 );
				assert.ok( b.elements[ 8 ] == 8 );

				b.multiplyScalar( 2 );
				assert.ok( b.elements[ 0 ] == 0 * 2 );
				assert.ok( b.elements[ 1 ] == 3 * 2 );
				assert.ok( b.elements[ 2 ] == 6 * 2 );
				assert.ok( b.elements[ 3 ] == 1 * 2 );
				assert.ok( b.elements[ 4 ] == 4 * 2 );
				assert.ok( b.elements[ 5 ] == 7 * 2 );
				assert.ok( b.elements[ 6 ] == 2 * 2 );
				assert.ok( b.elements[ 7 ] == 5 * 2 );
				assert.ok( b.elements[ 8 ] == 8 * 2 );

			} );

			QUnit.test( "determinant", ( assert ) => {

				var a = new Matrix3();
				assert.ok( a.determinant() == 1, "Passed!" );

				a.elements[ 0 ] = 2;
				assert.ok( a.determinant() == 2, "Passed!" );

				a.elements[ 0 ] = 0;
				assert.ok( a.determinant() == 0, "Passed!" );

				// calculated via http://www.euclideanspace.com/maths/algebra/matrix/functions/determinant/threeD/index.htm
				a.set( 2, 3, 4, 5, 13, 7, 8, 9, 11 );
				assert.ok( a.determinant() == - 73, "Passed!" );

			} );

			QUnit.test( "invert", ( assert ) => {

				var zero = new Matrix3().set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );
				var identity4 = new Matrix4();
				var a = new Matrix3().set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );
				var b = new Matrix3();

				b.copy( a ).invert();
				assert.ok( matrixEquals3( b, zero ), "Matrix a is zero matrix" );

				var testMatrices = [
					new Matrix4().makeRotationX( 0.3 ),
					new Matrix4().makeRotationX( - 0.3 ),
					new Matrix4().makeRotationY( 0.3 ),
					new Matrix4().makeRotationY( - 0.3 ),
					new Matrix4().makeRotationZ( 0.3 ),
					new Matrix4().makeRotationZ( - 0.3 ),
					new Matrix4().makeScale( 1, 2, 3 ),
					new Matrix4().makeScale( 1 / 8, 1 / 2, 1 / 3 )
				];

				for ( var i = 0, il = testMatrices.length; i < il; i ++ ) {

					var m = testMatrices[ i ];

					a.setFromMatrix4( m );
					var mInverse3 = b.copy( a ).invert();

					var mInverse = toMatrix4( mInverse3 );

					// the determinant of the inverse should be the reciprocal
					assert.ok( Math.abs( a.determinant() * mInverse3.determinant() - 1 ) < 0.0001, "Passed!" );
					assert.ok( Math.abs( m.determinant() * mInverse.determinant() - 1 ) < 0.0001, "Passed!" );

					var mProduct = new Matrix4().multiplyMatrices( m, mInverse );
					assert.ok( Math.abs( mProduct.determinant() - 1 ) < 0.0001, "Passed!" );
					assert.ok( matrixEquals3( mProduct, identity4 ), "Passed!" );

				}

			} );

			QUnit.test( "transpose", ( assert ) => {

				var a = new Matrix3();
				var b = a.clone().transpose();
				assert.ok( matrixEquals3( a, b ), "Passed!" );

				var b = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				var c = b.clone().transpose();
				assert.ok( ! matrixEquals3( b, c ), "Passed!" );
				c.transpose();
				assert.ok( matrixEquals3( b, c ), "Passed!" );

			} );

			QUnit.test( "getNormalMatrix", ( assert ) => {

				var a = new Matrix3();
				var b = new Matrix4().set(
					2, 3, 5, 7,
					11, 13, 17, 19,
					23, 29, 31, 37,
					41, 43, 47, 57
				);
				var expected = new Matrix3().set(
					- 1.2857142857142856, 0.7142857142857143, 0.2857142857142857,
					0.7428571428571429, - 0.7571428571428571, 0.15714285714285714,
					- 0.19999999999999998, 0.3, - 0.09999999999999999
				);

				a.getNormalMatrix( b );
				assert.ok( matrixEquals3( a, expected ), "Check resulting Matrix3" );

			} );

			QUnit.test( "transposeIntoArray", ( assert ) => {

				var a = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				var b = [];
				a.transposeIntoArray( b );

				assert.ok( b[ 0 ] == 0 );
				assert.ok( b[ 1 ] == 1 );
				assert.ok( b[ 2 ] == 2 );
				assert.ok( b[ 3 ] == 3 );
				assert.ok( b[ 4 ] == 4 );
				assert.ok( b[ 5 ] == 5 );
				assert.ok( b[ 5 ] == 5 );
				assert.ok( b[ 6 ] == 6 );
				assert.ok( b[ 7 ] == 7 );
				assert.ok( b[ 8 ] == 8 );

			} );

			QUnit.test( "setUvTransform", ( assert ) => {

				var a = new Matrix3().set(
					0.1767766952966369, 0.17677669529663687, 0.32322330470336313,
					- 0.17677669529663687, 0.1767766952966369, 0.5,
					0, 0, 1
				);
				var b = new Matrix3();
				var params = {
					centerX: 0.5,
					centerY: 0.5,
					offsetX: 0,
					offsetY: 0,
					repeatX: 0.25,
					repeatY: 0.25,
					rotation: 0.7753981633974483
				};
				var expected = new Matrix3().set(
					0.1785355940258599, 0.17500011904519763, 0.32323214346447127,
					- 0.17500011904519763, 0.1785355940258599, 0.4982322625096689,
					0, 0, 1
				);

				a.setUvTransform(
					params.offsetX, params.offsetY,
					params.repeatX, params.repeatY,
					params.rotation,
					params.centerX, params.centerY
				);

				b.identity()
				 .translate( - params.centerX, - params.centerY )
				 .rotate( params.rotation )
				 .scale( params.repeatX, params.repeatY )
				 .translate( params.centerX, params.centerY )
				 .translate( params.offsetX, params.offsetY );

				assert.ok( matrixEquals3( a, expected ), "Check direct method" );
				assert.ok( matrixEquals3( b, expected ), "Check indirect method" );

			} );

			QUnit.test( "scale", ( assert ) => {

				var a = new Matrix3().set( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
				var expected = new Matrix3().set(
					0.25, 0.5, 0.75,
					1, 1.25, 1.5,
					7, 8, 9
				);

				a.scale( 0.25, 0.25 );
				assert.ok( matrixEquals3( a, expected ), "Check scaling result" );

			} );

			QUnit.test( "rotate", ( assert ) => {

				var a = new Matrix3().set( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
				var expected = new Matrix3().set(
					3.5355339059327373, 4.949747468305833, 6.363961030678928,
					2.121320343559643, 2.121320343559643, 2.1213203435596433,
					7, 8, 9
				);

				a.rotate( Math.PI / 4 );
				assert.ok( matrixEquals3( a, expected ), "Check rotated result" );

			} );

			QUnit.test( "translate", ( assert ) => {

				var a = new Matrix3().set( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
				var expected = new Matrix3().set( 22, 26, 30, 53, 61, 69, 7, 8, 9 );

				a.translate( 3, 7 );
				assert.ok( matrixEquals3( a, expected ), "Check translation result" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Matrix3().set( 0, 1, 2, 3, 4, 5, 6, 7, 8 );
				var b = new Matrix3().set( 0, - 1, 2, 3, 4, 5, 6, 7, 8 );

				assert.notOk( a.equals( b ), "Check that a does not equal b" );
				assert.notOk( b.equals( a ), "Check that b does not equal a" );

				a.copy( b );
				assert.ok( a.equals( b ), "Check that a equals b after copy()" );
				assert.ok( b.equals( a ), "Check that b equals a after copy()" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var b = new Matrix3();
				b.fromArray( [ 0, 1, 2, 3, 4, 5, 6, 7, 8 ] );

				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 1 );
				assert.ok( b.elements[ 2 ] == 2 );
				assert.ok( b.elements[ 3 ] == 3 );
				assert.ok( b.elements[ 4 ] == 4 );
				assert.ok( b.elements[ 5 ] == 5 );
				assert.ok( b.elements[ 6 ] == 6 );
				assert.ok( b.elements[ 7 ] == 7 );
				assert.ok( b.elements[ 8 ] == 8 );

				b = new Matrix3();
				b.fromArray( [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18 ], 10 );

				assert.ok( b.elements[ 0 ] == 10 );
				assert.ok( b.elements[ 1 ] == 11 );
				assert.ok( b.elements[ 2 ] == 12 );
				assert.ok( b.elements[ 3 ] == 13 );
				assert.ok( b.elements[ 4 ] == 14 );
				assert.ok( b.elements[ 5 ] == 15 );
				assert.ok( b.elements[ 6 ] == 16 );
				assert.ok( b.elements[ 7 ] == 17 );
				assert.ok( b.elements[ 8 ] == 18 );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Matrix3().set( 1, 2, 3, 4, 5, 6, 7, 8, 9 );
				var noOffset = [ 1, 4, 7, 2, 5, 8, 3, 6, 9 ];
				var withOffset = [ undefined, 1, 4, 7, 2, 5, 8, 3, 6, 9 ];

				var array = a.toArray();
				assert.deepEqual( array, noOffset, "No array, no offset" );

				var array = [];
				a.toArray( array );
				assert.deepEqual( array, noOffset, "With array, no offset" );

				var array = [];
				a.toArray( array, 1 );
				assert.deepEqual( array, withOffset, "With array, with offset" );

			} );

		} );

	} );

	/* global QUnit */


	function matrixEquals4$2( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		if ( a.elements.length != b.elements.length ) {

			return false;

		}

		for ( var i = 0, il = a.elements.length; i < il; i ++ ) {

			var delta = a.elements[ i ] - b.elements[ i ];
			if ( delta > tolerance ) {

				return false;

			}

		}

		return true;

	}

	// from Euler.js
	function eulerEquals$1( a, b, tolerance ) {

		tolerance = tolerance || 0.0001;
		var diff = Math.abs( a.x - b.x ) + Math.abs( a.y - b.y ) + Math.abs( a.z - b.z );
		return ( diff < tolerance );

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Matrix4', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Matrix4();
				assert.ok( a.determinant() == 1, "Passed!" );

				var b = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 4 );
				assert.ok( b.elements[ 2 ] == 8 );
				assert.ok( b.elements[ 3 ] == 12 );
				assert.ok( b.elements[ 4 ] == 1 );
				assert.ok( b.elements[ 5 ] == 5 );
				assert.ok( b.elements[ 6 ] == 9 );
				assert.ok( b.elements[ 7 ] == 13 );
				assert.ok( b.elements[ 8 ] == 2 );
				assert.ok( b.elements[ 9 ] == 6 );
				assert.ok( b.elements[ 10 ] == 10 );
				assert.ok( b.elements[ 11 ] == 14 );
				assert.ok( b.elements[ 12 ] == 3 );
				assert.ok( b.elements[ 13 ] == 7 );
				assert.ok( b.elements[ 14 ] == 11 );
				assert.ok( b.elements[ 15 ] == 15 );

				assert.ok( ! matrixEquals4$2( a, b ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "isMatrix4", ( assert ) => {

				var a = new Matrix4();
				assert.ok( a.isMatrix4 === true, "Passed!" );

				var b = new Vector3();
				assert.ok( ! b.isMatrix4, "Passed!" );

			} );

			QUnit.test( "set", ( assert ) => {

				var b = new Matrix4();
				assert.ok( b.determinant() == 1, "Passed!" );

				b.set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 4 );
				assert.ok( b.elements[ 2 ] == 8 );
				assert.ok( b.elements[ 3 ] == 12 );
				assert.ok( b.elements[ 4 ] == 1 );
				assert.ok( b.elements[ 5 ] == 5 );
				assert.ok( b.elements[ 6 ] == 9 );
				assert.ok( b.elements[ 7 ] == 13 );
				assert.ok( b.elements[ 8 ] == 2 );
				assert.ok( b.elements[ 9 ] == 6 );
				assert.ok( b.elements[ 10 ] == 10 );
				assert.ok( b.elements[ 11 ] == 14 );
				assert.ok( b.elements[ 12 ] == 3 );
				assert.ok( b.elements[ 13 ] == 7 );
				assert.ok( b.elements[ 14 ] == 11 );
				assert.ok( b.elements[ 15 ] == 15 );

			} );

			QUnit.test( "identity", ( assert ) => {

				var b = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 4 );
				assert.ok( b.elements[ 2 ] == 8 );
				assert.ok( b.elements[ 3 ] == 12 );
				assert.ok( b.elements[ 4 ] == 1 );
				assert.ok( b.elements[ 5 ] == 5 );
				assert.ok( b.elements[ 6 ] == 9 );
				assert.ok( b.elements[ 7 ] == 13 );
				assert.ok( b.elements[ 8 ] == 2 );
				assert.ok( b.elements[ 9 ] == 6 );
				assert.ok( b.elements[ 10 ] == 10 );
				assert.ok( b.elements[ 11 ] == 14 );
				assert.ok( b.elements[ 12 ] == 3 );
				assert.ok( b.elements[ 13 ] == 7 );
				assert.ok( b.elements[ 14 ] == 11 );
				assert.ok( b.elements[ 15 ] == 15 );

				var a = new Matrix4();
				assert.ok( ! matrixEquals4$2( a, b ), "Passed!" );

				b.identity();
				assert.ok( matrixEquals4$2( a, b ), "Passed!" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var a = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				var b = a.clone();

				assert.ok( matrixEquals4$2( a, b ), "Passed!" );

				// ensure that it is a true copy
				a.elements[ 0 ] = 2;
				assert.ok( ! matrixEquals4$2( a, b ), "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				var b = new Matrix4().copy( a );

				assert.ok( matrixEquals4$2( a, b ), "Passed!" );

				// ensure that it is a true copy
				a.elements[ 0 ] = 2;
				assert.ok( ! matrixEquals4$2( a, b ), "Passed!" );

			} );

			QUnit.test( "setFromMatrix4", ( assert ) => {

				var a = new Matrix3().set(
					0, 1, 2,
					3, 4, 5,
					6, 7, 8
				);
				var b = new Matrix4();
				var c = new Matrix4().set(
					0, 1, 2, 0,
					3, 4, 5, 0,
					6, 7, 8, 0,
					0, 0, 0, 1
				);
				b.setFromMatrix3( a );
				assert.ok( b.equals( c ) );

			} );

			QUnit.test( "copyPosition", ( assert ) => {

				var a = new Matrix4().set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				var b = new Matrix4().set( 1, 2, 3, 0, 5, 6, 7, 0, 9, 10, 11, 0, 13, 14, 15, 16 );

				assert.notOk( matrixEquals4$2( a, b ), "a and b initially not equal" );

				b.copyPosition( a );
				assert.ok( matrixEquals4$2( a, b ), "a and b equal after copyPosition()" );

			} );

			QUnit.test( "makeBasis/extractBasis", ( assert ) => {

				var identityBasis = [ new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ) ];
				var a = new Matrix4().makeBasis( identityBasis[ 0 ], identityBasis[ 1 ], identityBasis[ 2 ] );
				var identity = new Matrix4();
				assert.ok( matrixEquals4$2( a, identity ), "Passed!" );

				var testBases = [[ new Vector3( 0, 1, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ) ]];
				for ( var i = 0; i < testBases.length; i ++ ) {

					var testBasis = testBases[ i ];
					var b = new Matrix4().makeBasis( testBasis[ 0 ], testBasis[ 1 ], testBasis[ 2 ] );
					var outBasis = [ new Vector3(), new Vector3(), new Vector3() ];
					b.extractBasis( outBasis[ 0 ], outBasis[ 1 ], outBasis[ 2 ] );
					// check what goes in, is what comes out.
					for ( var j = 0; j < outBasis.length; j ++ ) {

						assert.ok( outBasis[ j ].equals( testBasis[ j ] ), "Passed!" );

					}

					// get the basis out the hard war
					for ( var j = 0; j < identityBasis.length; j ++ ) {

						outBasis[ j ].copy( identityBasis[ j ] );
						outBasis[ j ].applyMatrix4( b );

					}
					// did the multiply method of basis extraction work?
					for ( var j = 0; j < outBasis.length; j ++ ) {

						assert.ok( outBasis[ j ].equals( testBasis[ j ] ), "Passed!" );

					}

				}

			} );

			QUnit.test( "makeRotationFromEuler/extractRotation", ( assert ) => {

				var testValues = [
					new Euler( 0, 0, 0, "XYZ" ),
					new Euler( 1, 0, 0, "XYZ" ),
					new Euler( 0, 1, 0, "ZYX" ),
					new Euler( 0, 0, 0.5, "YZX" ),
					new Euler( 0, 0, - 0.5, "YZX" )
				];

				for ( var i = 0; i < testValues.length; i ++ ) {

					var v = testValues[ i ];

					var m = new Matrix4().makeRotationFromEuler( v );

					var v2 = new Euler().setFromRotationMatrix( m, v.order );
					var m2 = new Matrix4().makeRotationFromEuler( v2 );

					assert.ok( matrixEquals4$2( m, m2, eps ), "makeRotationFromEuler #" + i + ": original and Euler-derived matrices are equal" );
					assert.ok( eulerEquals$1( v, v2, eps ), "makeRotationFromEuler #" + i + ": original and matrix-derived Eulers are equal" );

					var m3 = new Matrix4().extractRotation( m2 );
					var v3 = new Euler().setFromRotationMatrix( m3, v.order );

					assert.ok( matrixEquals4$2( m, m3, eps ), "extractRotation #" + i + ": original and extracted matrices are equal" );
					assert.ok( eulerEquals$1( v, v3, eps ), "extractRotation #" + i + ": original and extracted Eulers are equal" );

				}

			} );

			QUnit.test( "lookAt", ( assert ) => {

				var a = new Matrix4();
				var expected = new Matrix4().identity();
				var eye = new Vector3( 0, 0, 0 );
				var target = new Vector3( 0, 1, - 1 );
				var up = new Vector3( 0, 1, 0 );

				a.lookAt( eye, target, up );
				var rotation = new Euler().setFromRotationMatrix( a );
				assert.numEqual( rotation.x * ( 180 / Math.PI ), 45, "Check the rotation" );

				// eye and target are in the same position
				eye.copy( target );
				a.lookAt( eye, target, up );
				assert.ok( matrixEquals4$2( a, expected ), "Check the result for eye == target" );

				// up and z are parallel
				eye.set( 0, 1, 0 );
				target.set( 0, 0, 0 );
				a.lookAt( eye, target, up );
				expected.set(
					1, 0, 0, 0,
					0, 0.0001, 1, 0,
					0, - 1, 0.0001, 0,
					0, 0, 0, 1
				);
				assert.ok( matrixEquals4$2( a, expected ), "Check the result for when up and z are parallel" );

			} );

			QUnit.test( "multiply", ( assert ) => {

				var lhs = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );
				var rhs = new Matrix4().set( 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131 );

				lhs.multiply( rhs );

				assert.ok( lhs.elements[ 0 ] == 1585 );
				assert.ok( lhs.elements[ 1 ] == 5318 );
				assert.ok( lhs.elements[ 2 ] == 10514 );
				assert.ok( lhs.elements[ 3 ] == 15894 );
				assert.ok( lhs.elements[ 4 ] == 1655 );
				assert.ok( lhs.elements[ 5 ] == 5562 );
				assert.ok( lhs.elements[ 6 ] == 11006 );
				assert.ok( lhs.elements[ 7 ] == 16634 );
				assert.ok( lhs.elements[ 8 ] == 1787 );
				assert.ok( lhs.elements[ 9 ] == 5980 );
				assert.ok( lhs.elements[ 10 ] == 11840 );
				assert.ok( lhs.elements[ 11 ] == 17888 );
				assert.ok( lhs.elements[ 12 ] == 1861 );
				assert.ok( lhs.elements[ 13 ] == 6246 );
				assert.ok( lhs.elements[ 14 ] == 12378 );
				assert.ok( lhs.elements[ 15 ] == 18710 );

			} );

			QUnit.test( "premultiply", ( assert ) => {

				var lhs = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );
				var rhs = new Matrix4().set( 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131 );

				rhs.premultiply( lhs );

				assert.ok( rhs.elements[ 0 ] == 1585 );
				assert.ok( rhs.elements[ 1 ] == 5318 );
				assert.ok( rhs.elements[ 2 ] == 10514 );
				assert.ok( rhs.elements[ 3 ] == 15894 );
				assert.ok( rhs.elements[ 4 ] == 1655 );
				assert.ok( rhs.elements[ 5 ] == 5562 );
				assert.ok( rhs.elements[ 6 ] == 11006 );
				assert.ok( rhs.elements[ 7 ] == 16634 );
				assert.ok( rhs.elements[ 8 ] == 1787 );
				assert.ok( rhs.elements[ 9 ] == 5980 );
				assert.ok( rhs.elements[ 10 ] == 11840 );
				assert.ok( rhs.elements[ 11 ] == 17888 );
				assert.ok( rhs.elements[ 12 ] == 1861 );
				assert.ok( rhs.elements[ 13 ] == 6246 );
				assert.ok( rhs.elements[ 14 ] == 12378 );
				assert.ok( rhs.elements[ 15 ] == 18710 );


			} );

			QUnit.test( "multiplyMatrices", ( assert ) => {

				// Reference:
				//
				// #!/usr/bin/env python
				// from __future__ import print_function
				// import numpy as np
				// print(
				//     np.dot(
				//         np.reshape([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53], (4, 4)),
				//         np.reshape([59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131], (4, 4))
				//     )
				// )
				//
				// [[ 1585  1655  1787  1861]
				//  [ 5318  5562  5980  6246]
				//  [10514 11006 11840 12378]
				//  [15894 16634 17888 18710]]
				var lhs = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );
				var rhs = new Matrix4().set( 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131 );
				var ans = new Matrix4();

				ans.multiplyMatrices( lhs, rhs );

				assert.ok( ans.elements[ 0 ] == 1585 );
				assert.ok( ans.elements[ 1 ] == 5318 );
				assert.ok( ans.elements[ 2 ] == 10514 );
				assert.ok( ans.elements[ 3 ] == 15894 );
				assert.ok( ans.elements[ 4 ] == 1655 );
				assert.ok( ans.elements[ 5 ] == 5562 );
				assert.ok( ans.elements[ 6 ] == 11006 );
				assert.ok( ans.elements[ 7 ] == 16634 );
				assert.ok( ans.elements[ 8 ] == 1787 );
				assert.ok( ans.elements[ 9 ] == 5980 );
				assert.ok( ans.elements[ 10 ] == 11840 );
				assert.ok( ans.elements[ 11 ] == 17888 );
				assert.ok( ans.elements[ 12 ] == 1861 );
				assert.ok( ans.elements[ 13 ] == 6246 );
				assert.ok( ans.elements[ 14 ] == 12378 );
				assert.ok( ans.elements[ 15 ] == 18710 );

			} );

			QUnit.test( "multiplyScalar", ( assert ) => {

				var b = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				assert.ok( b.elements[ 0 ] == 0 );
				assert.ok( b.elements[ 1 ] == 4 );
				assert.ok( b.elements[ 2 ] == 8 );
				assert.ok( b.elements[ 3 ] == 12 );
				assert.ok( b.elements[ 4 ] == 1 );
				assert.ok( b.elements[ 5 ] == 5 );
				assert.ok( b.elements[ 6 ] == 9 );
				assert.ok( b.elements[ 7 ] == 13 );
				assert.ok( b.elements[ 8 ] == 2 );
				assert.ok( b.elements[ 9 ] == 6 );
				assert.ok( b.elements[ 10 ] == 10 );
				assert.ok( b.elements[ 11 ] == 14 );
				assert.ok( b.elements[ 12 ] == 3 );
				assert.ok( b.elements[ 13 ] == 7 );
				assert.ok( b.elements[ 14 ] == 11 );
				assert.ok( b.elements[ 15 ] == 15 );

				b.multiplyScalar( 2 );
				assert.ok( b.elements[ 0 ] == 0 * 2 );
				assert.ok( b.elements[ 1 ] == 4 * 2 );
				assert.ok( b.elements[ 2 ] == 8 * 2 );
				assert.ok( b.elements[ 3 ] == 12 * 2 );
				assert.ok( b.elements[ 4 ] == 1 * 2 );
				assert.ok( b.elements[ 5 ] == 5 * 2 );
				assert.ok( b.elements[ 6 ] == 9 * 2 );
				assert.ok( b.elements[ 7 ] == 13 * 2 );
				assert.ok( b.elements[ 8 ] == 2 * 2 );
				assert.ok( b.elements[ 9 ] == 6 * 2 );
				assert.ok( b.elements[ 10 ] == 10 * 2 );
				assert.ok( b.elements[ 11 ] == 14 * 2 );
				assert.ok( b.elements[ 12 ] == 3 * 2 );
				assert.ok( b.elements[ 13 ] == 7 * 2 );
				assert.ok( b.elements[ 14 ] == 11 * 2 );
				assert.ok( b.elements[ 15 ] == 15 * 2 );

			} );

			QUnit.test( "determinant", ( assert ) => {

				var a = new Matrix4();
				assert.ok( a.determinant() == 1, "Passed!" );

				a.elements[ 0 ] = 2;
				assert.ok( a.determinant() == 2, "Passed!" );

				a.elements[ 0 ] = 0;
				assert.ok( a.determinant() == 0, "Passed!" );

				// calculated via http://www.euclideanspace.com/maths/algebra/matrix/functions/determinant/fourD/index.htm
				a.set( 2, 3, 4, 5, - 1, - 21, - 3, - 4, 6, 7, 8, 10, - 8, - 9, - 10, - 12 );
				assert.ok( a.determinant() == 76, "Passed!" );

			} );

			QUnit.test( "transpose", ( assert ) => {

				var a = new Matrix4();
				var b = a.clone().transpose();
				assert.ok( matrixEquals4$2( a, b ), "Passed!" );

				var b = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				var c = b.clone().transpose();
				assert.ok( ! matrixEquals4$2( b, c ), "Passed!" );
				c.transpose();
				assert.ok( matrixEquals4$2( b, c ), "Passed!" );

			} );

			QUnit.test( "setPosition", ( assert ) => {

				var a = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 );
				var b = new Vector3( - 1, - 2, - 3 );
				var c = new Matrix4().set( 0, 1, 2, - 1, 4, 5, 6, - 2, 8, 9, 10, - 3, 12, 13, 14, 15 );

				a.setPosition( b );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "invert", ( assert ) => {

				var zero = new Matrix4().set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );
				var identity = new Matrix4();

				var a = new Matrix4();
				var b = new Matrix4().set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

				a.copy( b ).invert();
				assert.ok( matrixEquals4$2( a, zero ), "Passed!" );


				var testMatrices = [
					new Matrix4().makeRotationX( 0.3 ),
					new Matrix4().makeRotationX( - 0.3 ),
					new Matrix4().makeRotationY( 0.3 ),
					new Matrix4().makeRotationY( - 0.3 ),
					new Matrix4().makeRotationZ( 0.3 ),
					new Matrix4().makeRotationZ( - 0.3 ),
					new Matrix4().makeScale( 1, 2, 3 ),
					new Matrix4().makeScale( 1 / 8, 1 / 2, 1 / 3 ),
					new Matrix4().makePerspective( - 1, 1, 1, - 1, 1, 1000 ),
					new Matrix4().makePerspective( - 16, 16, 9, - 9, 0.1, 10000 ),
					new Matrix4().makeTranslation( 1, 2, 3 )
				];

				for ( var i = 0, il = testMatrices.length; i < il; i ++ ) {

					var m = testMatrices[ i ];

					var mInverse = new Matrix4().copy( m ).invert();
					var mSelfInverse = m.clone();
					mSelfInverse.copy( mSelfInverse ).invert();

					// self-inverse should the same as inverse
					assert.ok( matrixEquals4$2( mSelfInverse, mInverse ), "Passed!" );

					// the determinant of the inverse should be the reciprocal
					assert.ok( Math.abs( m.determinant() * mInverse.determinant() - 1 ) < 0.0001, "Passed!" );

					var mProduct = new Matrix4().multiplyMatrices( m, mInverse );

					// the determinant of the identity matrix is 1
					assert.ok( Math.abs( mProduct.determinant() - 1 ) < 0.0001, "Passed!" );
					assert.ok( matrixEquals4$2( mProduct, identity ), "Passed!" );

				}

			} );

			QUnit.test( "scale", ( assert ) => {

				var a = new Matrix4().set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				var b = new Vector3( 2, 3, 4 );
				var c = new Matrix4().set( 2, 6, 12, 4, 10, 18, 28, 8, 18, 30, 44, 12, 26, 42, 60, 16 );

				a.scale( b );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "getMaxScaleOnAxis", ( assert ) => {

				var a = new Matrix4().set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				var expected = Math.sqrt( 3 * 3 + 7 * 7 + 11 * 11 );

				assert.ok( Math.abs( a.getMaxScaleOnAxis() - expected ) <= eps, "Check result" );

			} );

			QUnit.test( "makeTranslation", ( assert ) => {

				var a = new Matrix4();
				var b = new Vector3( 2, 3, 4 );
				var c = new Matrix4().set( 1, 0, 0, 2, 0, 1, 0, 3, 0, 0, 1, 4, 0, 0, 0, 1 );

				a.makeTranslation( b.x, b.y, b.z );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "makeRotationX", ( assert ) => {

				var a = new Matrix4();
				var b = Math.sqrt( 3 ) / 2;
				var c = new Matrix4().set( 1, 0, 0, 0, 0, b, - 0.5, 0, 0, 0.5, b, 0, 0, 0, 0, 1 );

				a.makeRotationX( Math.PI / 6 );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "makeRotationY", ( assert ) => {


				var a = new Matrix4();
				var b = Math.sqrt( 3 ) / 2;
				var c = new Matrix4().set( b, 0, 0.5, 0, 0, 1, 0, 0, - 0.5, 0, b, 0, 0, 0, 0, 1 );

				a.makeRotationY( Math.PI / 6 );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "makeRotationZ", ( assert ) => {


				var a = new Matrix4();
				var b = Math.sqrt( 3 ) / 2;
				var c = new Matrix4().set( b, - 0.5, 0, 0, 0.5, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 );

				a.makeRotationZ( Math.PI / 6 );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "makeRotationAxis", ( assert ) => {

				var axis = new Vector3( 1.5, 0.0, 1.0 ).normalize();
				var radians = MathUtils.degToRad( 45 );
				var a = new Matrix4().makeRotationAxis( axis, radians );

				var expected = new Matrix4().set(
					0.9098790095958609, - 0.39223227027636803, 0.13518148560620882, 0,
					0.39223227027636803, 0.7071067811865476, - 0.588348405414552, 0,
					0.13518148560620882, 0.588348405414552, 0.7972277715906868, 0,
					0, 0, 0, 1
				);

				assert.ok( matrixEquals4$2( a, expected ), "Check numeric result" );

			} );

			QUnit.test( "makeScale", ( assert ) => {

				var a = new Matrix4();
				var c = new Matrix4().set( 2, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4, 0, 0, 0, 0, 1 );

				a.makeScale( 2, 3, 4 );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "makeShear", ( assert ) => {

				var a = new Matrix4();
				var c = new Matrix4().set( 1, 3, 4, 0, 2, 1, 4, 0, 2, 3, 1, 0, 0, 0, 0, 1 );

				a.makeShear( 2, 3, 4 );
				assert.ok( matrixEquals4$2( a, c ), "Passed!" );

			} );

			QUnit.test( "compose/decompose", ( assert ) => {

				var tValues = [
					new Vector3(),
					new Vector3( 3, 0, 0 ),
					new Vector3( 0, 4, 0 ),
					new Vector3( 0, 0, 5 ),
					new Vector3( - 6, 0, 0 ),
					new Vector3( 0, - 7, 0 ),
					new Vector3( 0, 0, - 8 ),
					new Vector3( - 2, 5, - 9 ),
					new Vector3( - 2, - 5, - 9 )
				];

				var sValues = [
					new Vector3( 1, 1, 1 ),
					new Vector3( 2, 2, 2 ),
					new Vector3( 1, - 1, 1 ),
					new Vector3( - 1, 1, 1 ),
					new Vector3( 1, 1, - 1 ),
					new Vector3( 2, - 2, 1 ),
					new Vector3( - 1, 2, - 2 ),
					new Vector3( - 1, - 1, - 1 ),
					new Vector3( - 2, - 2, - 2 )
				];

				var rValues = [
					new Quaternion(),
					new Quaternion().setFromEuler( new Euler( 1, 1, 0 ) ),
					new Quaternion().setFromEuler( new Euler( 1, - 1, 1 ) ),
					new Quaternion( 0, 0.9238795292366128, 0, 0.38268342717215614 )
				];

				for ( var ti = 0; ti < tValues.length; ti ++ ) {

					for ( var si = 0; si < sValues.length; si ++ ) {

						for ( var ri = 0; ri < rValues.length; ri ++ ) {

							var t = tValues[ ti ];
							var s = sValues[ si ];
							var r = rValues[ ri ];

							var m = new Matrix4().compose( t, r, s );
							var t2 = new Vector3();
							var r2 = new Quaternion();
							var s2 = new Vector3();

							m.decompose( t2, r2, s2 );

							var m2 = new Matrix4().compose( t2, r2, s2 );

							/*
							// debug code
							var matrixIsSame = matrixEquals4( m, m2 );
							if ( ! matrixIsSame ) {

								console.log( t, s, r );
								console.log( t2, s2, r2 );
								console.log( m, m2 );

							}
							*/

							assert.ok( matrixEquals4$2( m, m2 ), "Passed!" );

						}

					}

				}

			} );

			QUnit.test( "makePerspective", ( assert ) => {

				var a = new Matrix4().makePerspective( - 1, 1, - 1, 1, 1, 100 );
				var expected = new Matrix4().set(
					1, 0, 0, 0,
					0, - 1, 0, 0,
					0, 0, - 101 / 99, - 200 / 99,
					0, 0, - 1, 0
				);
				assert.ok( matrixEquals4$2( a, expected ), "Check result" );

			} );

			QUnit.test( "makeOrthographic", ( assert ) => {

				var a = new Matrix4().makeOrthographic( - 1, 1, - 1, 1, 1, 100 );
				var expected = new Matrix4().set(
					1, 0, 0, 0,
					0, - 1, 0, 0,
					0, 0, - 2 / 99, - 101 / 99,
					0, 0, 0, 1
				);

				assert.ok( matrixEquals4$2( a, expected ), "Check result" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Matrix4().set( 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				var b = new Matrix4().set( 0, - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );

				assert.notOk( a.equals( b ), "Check that a does not equal b" );
				assert.notOk( b.equals( a ), "Check that b does not equal a" );

				a.copy( b );
				assert.ok( a.equals( b ), "Check that a equals b after copy()" );
				assert.ok( b.equals( a ), "Check that b equals a after copy()" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Matrix4();
				var b = new Matrix4().set( 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16 );

				a.fromArray( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 ] );
				assert.ok( a.equals( b ), "Passed" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Matrix4().set( 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 );
				var noOffset = [ 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16 ];
				var withOffset = [ undefined, 1, 5, 9, 13, 2, 6, 10, 14, 3, 7, 11, 15, 4, 8, 12, 16 ];

				var array = a.toArray();
				assert.deepEqual( array, noOffset, "No array, no offset" );

				var array = [];
				a.toArray( array );
				assert.deepEqual( array, noOffset, "With array, no offset" );

				var array = [];
				a.toArray( array, 1 );
				assert.deepEqual( array, withOffset, "With array, with offset" );

			} );

		} );

	} );

	/* global QUnit */

	function comparePlane( a, b, threshold ) {

		threshold = threshold || 0.0001;
		return ( a.normal.distanceTo( b.normal ) < threshold &&
		Math.abs( a.constant - b.constant ) < threshold );

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Plane', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Plane();
				assert.ok( a.normal.x == 1, "Passed!" );
				assert.ok( a.normal.y == 0, "Passed!" );
				assert.ok( a.normal.z == 0, "Passed!" );
				assert.ok( a.constant == 0, "Passed!" );

				var a = new Plane( one3.clone(), 0 );
				assert.ok( a.normal.x == 1, "Passed!" );
				assert.ok( a.normal.y == 1, "Passed!" );
				assert.ok( a.normal.z == 1, "Passed!" );
				assert.ok( a.constant == 0, "Passed!" );

				var a = new Plane( one3.clone(), 1 );
				assert.ok( a.normal.x == 1, "Passed!" );
				assert.ok( a.normal.y == 1, "Passed!" );
				assert.ok( a.normal.z == 1, "Passed!" );
				assert.ok( a.constant == 1, "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "isPlane", ( assert ) => {

				var a = new Plane();
				assert.ok( a.isPlane === true, "Passed!" );

				var b = new Vector3();
				assert.ok( ! b.isPlane, "Passed!" );


			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Plane();
				assert.ok( a.normal.x == 1, "Passed!" );
				assert.ok( a.normal.y == 0, "Passed!" );
				assert.ok( a.normal.z == 0, "Passed!" );
				assert.ok( a.constant == 0, "Passed!" );

				var b = a.clone().set( new Vector3( x, y, z ), w );
				assert.ok( b.normal.x == x, "Passed!" );
				assert.ok( b.normal.y == y, "Passed!" );
				assert.ok( b.normal.z == z, "Passed!" );
				assert.ok( b.constant == w, "Passed!" );

			} );

			QUnit.test( "setComponents", ( assert ) => {

				var a = new Plane();
				assert.ok( a.normal.x == 1, "Passed!" );
				assert.ok( a.normal.y == 0, "Passed!" );
				assert.ok( a.normal.z == 0, "Passed!" );
				assert.ok( a.constant == 0, "Passed!" );

				var b = a.clone().setComponents( x, y, z, w );
				assert.ok( b.normal.x == x, "Passed!" );
				assert.ok( b.normal.y == y, "Passed!" );
				assert.ok( b.normal.z == z, "Passed!" );
				assert.ok( b.constant == w, "Passed!" );

			} );

			QUnit.test( "setFromNormalAndCoplanarPoint", ( assert ) => {

				var normal = one3.clone().normalize();
				var a = new Plane().setFromNormalAndCoplanarPoint( normal, zero3 );

				assert.ok( a.normal.equals( normal ), "Passed!" );
				assert.ok( a.constant == 0, "Passed!" );

			} );

			QUnit.test( "setFromCoplanarPoints", ( assert ) => {

				var a = new Plane();
				var v1 = new Vector3( 2.0, 0.5, 0.25 );
				var v2 = new Vector3( 2.0, - 0.5, 1.25 );
				var v3 = new Vector3( 2.0, - 3.5, 2.2 );
				var normal = new Vector3( 1, 0, 0 );
				var constant = - 2;

				a.setFromCoplanarPoints( v1, v2, v3 );

				assert.ok( a.normal.equals( normal ), "Check normal" );
				assert.strictEqual( a.constant, constant, "Check constant" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var a = new Plane( new Vector3( 2.0, 0.5, 0.25 ) );
				var b = a.clone();

				assert.ok( a.equals( b ), "clones are equal" );


			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Plane( new Vector3( x, y, z ), w );
				var b = new Plane().copy( a );
				assert.ok( b.normal.x == x, "Passed!" );
				assert.ok( b.normal.y == y, "Passed!" );
				assert.ok( b.normal.z == z, "Passed!" );
				assert.ok( b.constant == w, "Passed!" );

				// ensure that it is a true copy
				a.normal.x = 0;
				a.normal.y = - 1;
				a.normal.z = - 2;
				a.constant = - 3;
				assert.ok( b.normal.x == x, "Passed!" );
				assert.ok( b.normal.y == y, "Passed!" );
				assert.ok( b.normal.z == z, "Passed!" );
				assert.ok( b.constant == w, "Passed!" );

			} );

			QUnit.test( "normalize", ( assert ) => {

				var a = new Plane( new Vector3( 2, 0, 0 ), 2 );

				a.normalize();
				assert.ok( a.normal.length() == 1, "Passed!" );
				assert.ok( a.normal.equals( new Vector3( 1, 0, 0 ) ), "Passed!" );
				assert.ok( a.constant == 1, "Passed!" );

			} );

			QUnit.test( "negate/distanceToPoint", ( assert ) => {

				var a = new Plane( new Vector3( 2, 0, 0 ), - 2 );

				a.normalize();
				assert.ok( a.distanceToPoint( new Vector3( 4, 0, 0 ) ) === 3, "Passed!" );
				assert.ok( a.distanceToPoint( new Vector3( 1, 0, 0 ) ) === 0, "Passed!" );

				a.negate();
				assert.ok( a.distanceToPoint( new Vector3( 4, 0, 0 ) ) === - 3, "Passed!" );
				assert.ok( a.distanceToPoint( new Vector3( 1, 0, 0 ) ) === 0, "Passed!" );

			} );

			QUnit.test( "distanceToPoint", ( assert ) => {

				var a = new Plane( new Vector3( 2, 0, 0 ), - 2 );
				var point = new Vector3();

				a.normalize().projectPoint( zero3.clone(), point );
				assert.ok( a.distanceToPoint( point ) === 0, "Passed!" );
				assert.ok( a.distanceToPoint( new Vector3( 4, 0, 0 ) ) === 3, "Passed!" );

			} );

			QUnit.test( "distanceToSphere", ( assert ) => {

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );

				var b = new Sphere( new Vector3( 2, 0, 0 ), 1 );

				assert.ok( a.distanceToSphere( b ) === 1, "Passed!" );

				a.set( new Vector3( 1, 0, 0 ), 2 );
				assert.ok( a.distanceToSphere( b ) === 3, "Passed!" );
				a.set( new Vector3( 1, 0, 0 ), - 2 );
				assert.ok( a.distanceToSphere( b ) === - 1, "Passed!" );

			} );

			QUnit.test( "projectPoint", ( assert ) => {

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );
				var point = new Vector3();

				a.projectPoint( new Vector3( 10, 0, 0 ), point );
				assert.ok( point.equals( zero3 ), "Passed!" );
				a.projectPoint( new Vector3( - 10, 0, 0 ), point );
				assert.ok( point.equals( zero3 ), "Passed!" );

				var a = new Plane( new Vector3( 0, 1, 0 ), - 1 );
				a.projectPoint( new Vector3( 0, 0, 0 ), point );
				assert.ok( point.equals( new Vector3( 0, 1, 0 ) ), "Passed!" );
				a.projectPoint( new Vector3( 0, 1, 0 ), point );
				assert.ok( point.equals( new Vector3( 0, 1, 0 ) ), "Passed!" );

			} );

			QUnit.test( "isInterestionLine/intersectLine", ( assert ) => {

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );
				var point = new Vector3();

				var l1 = new Line3( new Vector3( - 10, 0, 0 ), new Vector3( 10, 0, 0 ) );
				a.intersectLine( l1, point );
				assert.ok( point.equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				var a = new Plane( new Vector3( 1, 0, 0 ), - 3 );
				a.intersectLine( l1, point );
				assert.ok( point.equals( new Vector3( 3, 0, 0 ) ), "Passed!" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var a = new Box3( zero3.clone(), one3.clone() );
				var b = new Plane( new Vector3( 0, 1, 0 ), 1 );
				var c = new Plane( new Vector3( 0, 1, 0 ), 1.25 );
				var d = new Plane( new Vector3( 0, - 1, 0 ), 1.25 );
				var e = new Plane( new Vector3( 0, 1, 0 ), 0.25 );
				var f = new Plane( new Vector3( 0, 1, 0 ), - 0.25 );
				var g = new Plane( new Vector3( 0, 1, 0 ), - 0.75 );
				var h = new Plane( new Vector3( 0, 1, 0 ), - 1 );
				var i = new Plane( new Vector3( 1, 1, 1 ).normalize(), - 1.732 );
				var j = new Plane( new Vector3( 1, 1, 1 ).normalize(), - 1.733 );

				assert.ok( ! b.intersectsBox( a ), "Passed!" );
				assert.ok( ! c.intersectsBox( a ), "Passed!" );
				assert.ok( ! d.intersectsBox( a ), "Passed!" );
				assert.ok( ! e.intersectsBox( a ), "Passed!" );
				assert.ok( f.intersectsBox( a ), "Passed!" );
				assert.ok( g.intersectsBox( a ), "Passed!" );
				assert.ok( h.intersectsBox( a ), "Passed!" );
				assert.ok( i.intersectsBox( a ), "Passed!" );
				assert.ok( ! j.intersectsBox( a ), "Passed!" );

			} );

			QUnit.test( "intersectsSphere", ( assert ) => {

				var a = new Sphere( zero3.clone(), 1 );
				var b = new Plane( new Vector3( 0, 1, 0 ), 1 );
				var c = new Plane( new Vector3( 0, 1, 0 ), 1.25 );
				var d = new Plane( new Vector3( 0, - 1, 0 ), 1.25 );

				assert.ok( b.intersectsSphere( a ), "Passed!" );
				assert.ok( ! c.intersectsSphere( a ), "Passed!" );
				assert.ok( ! d.intersectsSphere( a ), "Passed!" );

			} );

			QUnit.test( "coplanarPoint", ( assert ) => {

				var point = new Vector3();

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );
				a.coplanarPoint( point );
				assert.ok( a.distanceToPoint( point ) === 0, "Passed!" );

				var a = new Plane( new Vector3( 0, 1, 0 ), - 1 );
				a.coplanarPoint( point );
				assert.ok( a.distanceToPoint( point ) === 0, "Passed!" );

			} );

			QUnit.test( "applyMatrix4/translate", ( assert ) => {

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );

				var m = new Matrix4();
				m.makeRotationZ( Math.PI * 0.5 );

				assert.ok( comparePlane( a.clone().applyMatrix4( m ), new Plane( new Vector3( 0, 1, 0 ), 0 ) ), "Passed!" );

				var a = new Plane( new Vector3( 0, 1, 0 ), - 1 );
				assert.ok( comparePlane( a.clone().applyMatrix4( m ), new Plane( new Vector3( - 1, 0, 0 ), - 1 ) ), "Passed!" );

				m.makeTranslation( 1, 1, 1 );
				assert.ok( comparePlane( a.clone().applyMatrix4( m ), a.clone().translate( new Vector3( 1, 1, 1 ) ) ), "Passed!" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Plane( new Vector3( 1, 0, 0 ), 0 );
				var b = new Plane( new Vector3( 1, 0, 0 ), 1 );
				var c = new Plane( new Vector3( 0, 1, 0 ), 0 );

				assert.ok( a.normal.equals( b.normal ), "Normals: equal" );
				assert.notOk( a.normal.equals( c.normal ), "Normals: not equal" );

				assert.notStrictEqual( a.constant, b.constant, "Constants: not equal" );
				assert.strictEqual( a.constant, c.constant, "Constants: equal" );

				assert.notOk( a.equals( b ), "Planes: not equal" );
				assert.notOk( a.equals( c ), "Planes: not equal" );

				a.copy( b );
				assert.ok( a.normal.equals( b.normal ), "Normals after copy(): equal" );
				assert.strictEqual( a.constant, b.constant, "Constants after copy(): equal" );
				assert.ok( a.equals( b ), "Planes after copy(): equal" );

			} );

		} );

	} );

	QUnit.module( "Plane" );

	/* global QUnit */

	const orders = [ 'XYZ', 'YXZ', 'ZXY', 'ZYX', 'YZX', 'XZY' ];
	const eulerAngles = new Euler( 0.1, - 0.3, 0.25 );

	function qSub( a, b ) {

		var result = new Quaternion();
		result.copy( a );

		result.x -= b.x;
		result.y -= b.y;
		result.z -= b.z;
		result.w -= b.w;

		return result;

	}

	function doSlerpObject( aArr, bArr, t ) {

		var a = new Quaternion().fromArray( aArr ),
			b = new Quaternion().fromArray( bArr ),
			c = new Quaternion().fromArray( aArr );

		c.slerp( b, t );

		return {

			equals: function ( x, y, z, w, maxError ) {

				if ( maxError === undefined ) maxError = Number.EPSILON;

				return Math.abs( x - c.x ) <= maxError &&
					Math.abs( y - c.y ) <= maxError &&
					Math.abs( z - c.z ) <= maxError &&
					Math.abs( w - c.w ) <= maxError;

			},

			length: c.length(),

			dotA: c.dot( a ),
			dotB: c.dot( b )

		};

	}

	function doSlerpArray( a, b, t ) {

		var result = [ 0, 0, 0, 0 ];

		Quaternion.slerpFlat( result, 0, a, 0, b, 0, t );

		function arrDot( a, b ) {

			return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] +
				a[ 2 ] * b[ 2 ] + a[ 3 ] * b[ 3 ];

		}

		return {

			equals: function ( x, y, z, w, maxError ) {

				if ( maxError === undefined ) maxError = Number.EPSILON;

				return Math.abs( x - result[ 0 ] ) <= maxError &&
					Math.abs( y - result[ 1 ] ) <= maxError &&
					Math.abs( z - result[ 2 ] ) <= maxError &&
					Math.abs( w - result[ 3 ] ) <= maxError;

			},

			length: Math.sqrt( arrDot( result, result ) ),

			dotA: arrDot( result, a ),
			dotB: arrDot( result, b )

		};

	}

	function slerpTestSkeleton( doSlerp, maxError, assert ) {

		var a, b, result;

		a = [
			0.6753410084407496,
			0.4087830051091744,
			0.32856700410659473,
			0.5185120064806223
		];

		b = [
			0.6602792107657797,
			0.43647413932562285,
			0.35119011210236006,
			0.5001871596632682
		];

		function isNormal( result ) {

			var normError = Math.abs( 1 - result.length );
			return normError <= maxError;

		}

		result = doSlerp( a, b, 0 );
		assert.ok( result.equals(
			a[ 0 ], a[ 1 ], a[ 2 ], a[ 3 ], 0 ), "Exactly A @ t = 0" );

		result = doSlerp( a, b, 1 );
		assert.ok( result.equals(
			b[ 0 ], b[ 1 ], b[ 2 ], b[ 3 ], 0 ), "Exactly B @ t = 1" );

		result = doSlerp( a, b, 0.5 );
		assert.ok( Math.abs( result.dotA - result.dotB ) <= Number.EPSILON, "Symmetry at 0.5" );
		assert.ok( isNormal( result ), "Approximately normal (at 0.5)" );

		result = doSlerp( a, b, 0.25 );
		assert.ok( result.dotA > result.dotB, "Interpolating at 0.25" );
		assert.ok( isNormal( result ), "Approximately normal (at 0.25)" );

		result = doSlerp( a, b, 0.75 );
		assert.ok( result.dotA < result.dotB, "Interpolating at 0.75" );
		assert.ok( isNormal( result ), "Approximately normal (at 0.75)" );

		var D = Math.SQRT1_2;

		result = doSlerp( [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], 0.5 );
		assert.ok( result.equals( D, 0, D, 0 ), "X/Z diagonal from axes" );
		assert.ok( isNormal( result ), "Approximately normal (X/Z diagonal)" );

		result = doSlerp( [ 0, D, 0, D ], [ 0, - D, 0, D ], 0.5 );
		assert.ok( result.equals( 0, 0, 0, 1 ), "W-Unit from diagonals" );
		assert.ok( isNormal( result ), "Approximately normal (W-Unit)" );

	}

	function changeEulerOrder( euler, order ) {

		return new Euler( euler.x, euler.y, euler.z, order );

	}

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Quaternion', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Quaternion();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				var a = new Quaternion( x, y, z, w );
				assert.ok( a.x === x, "Passed!" );
				assert.ok( a.y === y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );
				assert.ok( a.w === w, "Passed!" );

			} );

			// STATIC STUFF
			QUnit.test( "slerp", ( assert ) => {

				slerpTestSkeleton( doSlerpObject, Number.EPSILON, assert );

			} );

			QUnit.test( "slerpFlat", ( assert ) => {

				slerpTestSkeleton( doSlerpArray, Number.EPSILON, assert );

			} );

			// PROPERTIES
			QUnit.test( "properties", ( assert ) => {

				assert.expect( 8 );

				var a = new Quaternion();
				a._onChange( function () {

					assert.ok( true, "onChange called" );

				} );

				a.x = x;
				a.y = y;
				a.z = z;
				a.w = w;

				assert.strictEqual( a.x, x, "Check x" );
				assert.strictEqual( a.y, y, "Check y" );
				assert.strictEqual( a.z, z, "Check z" );
				assert.strictEqual( a.w, w, "Check w" );

			} );

			QUnit.test( "x", ( assert ) => {

				var a = new Quaternion();
				assert.ok( a.x === 0, "Passed!" );

				a = new Quaternion( 1, 2, 3 );
				assert.ok( a.x === 1, "Passed!" );

				a = new Quaternion( 4, 5, 6, 1 );
				assert.ok( a.x === 4, "Passed!" );

				a = new Quaternion( 7, 8, 9 );
				a.x = 10;
				assert.ok( a.x === 10, "Passed!" );

				a = new Quaternion( 11, 12, 13 );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				assert.ok( ! b, "Passed!" );
				a.x = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.x === 14, "Passed!" );

			} );

			QUnit.test( "y", ( assert ) => {

				var a = new Quaternion();
				assert.ok( a.y === 0, "Passed!" );

				a = new Quaternion( 1, 2, 3 );
				assert.ok( a.y === 2, "Passed!" );

				a = new Quaternion( 4, 5, 6, 1 );
				assert.ok( a.y === 5, "Passed!" );

				a = new Quaternion( 7, 8, 9 );
				a.y = 10;
				assert.ok( a.y === 10, "Passed!" );

				a = new Quaternion( 11, 12, 13 );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				assert.ok( ! b, "Passed!" );
				a.y = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.y === 14, "Passed!" );

			} );

			QUnit.test( "z", ( assert ) => {


				var a = new Quaternion();
				assert.ok( a.z === 0, "Passed!" );

				a = new Quaternion( 1, 2, 3 );
				assert.ok( a.z === 3, "Passed!" );

				a = new Quaternion( 4, 5, 6, 1 );
				assert.ok( a.z === 6, "Passed!" );

				a = new Quaternion( 7, 8, 9 );
				a.z = 10;
				assert.ok( a.z === 10, "Passed!" );

				a = new Quaternion( 11, 12, 13 );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				assert.ok( ! b, "Passed!" );
				a.z = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.z === 14, "Passed!" );

			} );

			QUnit.test( "w", ( assert ) => {

				var a = new Quaternion();
				assert.ok( a.w === 1, "Passed!" );

				a = new Quaternion( 1, 2, 3 );
				assert.ok( a.w === 1, "Passed!" );

				a = new Quaternion( 4, 5, 6, 1 );
				assert.ok( a.w === 1, "Passed!" );

				a = new Quaternion( 7, 8, 9 );
				a.w = 10;
				assert.ok( a.w === 10, "Passed!" );

				a = new Quaternion( 11, 12, 13 );
				var b = false;
				a._onChange( function () {

					b = true;

				} );
				assert.ok( ! b, "Passed!" );
				a.w = 14;
				assert.ok( b, "Passed!" );
				assert.ok( a.w === 14, "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Quaternion();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				a.set( x, y, z, w );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );
				assert.ok( a.w === w, "Passed!" );

			} );

			QUnit.test( "clone", ( assert ) => {


				var a = new Quaternion().clone();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				var b = a.set( x, y, z, w ).clone();
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z === z, "Passed!" );
				assert.ok( b.w === w, "Passed!" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Quaternion( x, y, z, w );
				var b = new Quaternion().copy( a );
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z == z, "Passed!" );
				assert.ok( b.w == w, "Passed!" );

				// ensure that it is a true copy
				a.x = 0;
				a.y = - 1;
				a.z = 0;
				a.w = - 1;
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );

			} );

			QUnit.test( "setFromEuler/setFromQuaternion", ( assert ) => {

				var angles = [ new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ) ];

				// ensure euler conversion to/from Quaternion matches.
				for ( var i = 0; i < orders.length; i ++ ) {

					for ( var j = 0; j < angles.length; j ++ ) {

						var eulers2 = new Euler().setFromQuaternion( new Quaternion().setFromEuler( new Euler( angles[ j ].x, angles[ j ].y, angles[ j ].z, orders[ i ] ) ), orders[ i ] );
						var newAngle = new Vector3( eulers2.x, eulers2.y, eulers2.z );
						assert.ok( newAngle.distanceTo( angles[ j ] ) < 0.001, "Passed!" );

					}

				}

			} );

			QUnit.test( "setFromAxisAngle", ( assert ) => {

				// TODO: find cases to validate.
				// assert.ok( true, "Passed!" );

				var zero = new Quaternion();

				var a = new Quaternion().setFromAxisAngle( new Vector3( 1, 0, 0 ), 0 );
				assert.ok( a.equals( zero ), "Passed!" );
				a = new Quaternion().setFromAxisAngle( new Vector3( 0, 1, 0 ), 0 );
				assert.ok( a.equals( zero ), "Passed!" );
				a = new Quaternion().setFromAxisAngle( new Vector3( 0, 0, 1 ), 0 );
				assert.ok( a.equals( zero ), "Passed!" );

				var b1 = new Quaternion().setFromAxisAngle( new Vector3( 1, 0, 0 ), Math.PI );
				assert.ok( ! a.equals( b1 ), "Passed!" );
				var b2 = new Quaternion().setFromAxisAngle( new Vector3( 1, 0, 0 ), - Math.PI );
				assert.ok( ! a.equals( b2 ), "Passed!" );

				b1.multiply( b2 );
				assert.ok( a.equals( b1 ), "Passed!" );

			} );

			QUnit.test( "setFromEuler/setFromRotationMatrix", ( assert ) => {

				// ensure euler conversion for Quaternion matches that of Matrix4
				for ( var i = 0; i < orders.length; i ++ ) {

					var q = new Quaternion().setFromEuler( changeEulerOrder( eulerAngles, orders[ i ] ) );
					var m = new Matrix4().makeRotationFromEuler( changeEulerOrder( eulerAngles, orders[ i ] ) );
					var q2 = new Quaternion().setFromRotationMatrix( m );

					assert.ok( qSub( q, q2 ).length() < 0.001, "Passed!" );

				}

			} );

			QUnit.test( "setFromRotationMatrix", ( assert ) => {

				// contrived examples purely to please the god of code coverage...
				// match conditions in various 'else [if]' blocks

				var a = new Quaternion();
				var q = new Quaternion( - 9, - 2, 3, - 4 ).normalize();
				var m = new Matrix4().makeRotationFromQuaternion( q );
				var expected = new Vector4( 0.8581163303210332, 0.19069251784911848, - 0.2860387767736777, 0.38138503569823695 );

				a.setFromRotationMatrix( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "m11 > m22 && m11 > m33: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "m11 > m22 && m11 > m33: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "m11 > m22 && m11 > m33: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "m11 > m22 && m11 > m33: check w" );

				var q = new Quaternion( - 1, - 2, 1, - 1 ).normalize();
				m.makeRotationFromQuaternion( q );
				var expected = new Vector4( 0.37796447300922714, 0.7559289460184544, - 0.37796447300922714, 0.37796447300922714 );

				a.setFromRotationMatrix( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "m22 > m33: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "m22 > m33: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "m22 > m33: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "m22 > m33: check w" );

			} );

			QUnit.test( "setFromUnitVectors", ( assert ) => {

				var a = new Quaternion();
				var b = new Vector3( 1, 0, 0 );
				var c = new Vector3( 0, 1, 0 );
				var expected = new Quaternion( 0, 0, Math.sqrt( 2 ) / 2, Math.sqrt( 2 ) / 2 );

				a.setFromUnitVectors( b, c );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Check w" );

			} );

			QUnit.test( "angleTo", ( assert ) => {

				var a = new Quaternion();
				var b = new Quaternion().setFromEuler( new Euler( 0, Math.PI, 0 ) );
				var c = new Quaternion().setFromEuler( new Euler( 0, Math.PI * 2, 0 ) );

				assert.ok( a.angleTo( a ) === 0, "Passed!" );
				assert.ok( a.angleTo( b ) === Math.PI, "Passed!" );
				assert.ok( a.angleTo( c ) === 0, "Passed!" );

			} );

			QUnit.test( "rotateTowards", ( assert ) => {

				var a = new Quaternion();
				var b = new Quaternion().setFromEuler( new Euler( 0, Math.PI, 0 ) );
				var c = new Quaternion();

				var halfPI = Math.PI * 0.5;

				a.rotateTowards( b, 0 );
				assert.ok( a.equals( a ) === true, "Passed!" );

				a.rotateTowards( b, Math.PI * 2 ); // test overshoot
				assert.ok( a.equals( b ) === true, "Passed!" );

				a.set( 0, 0, 0, 1 );
				a.rotateTowards( b, halfPI );
				assert.ok( a.angleTo( c ) - halfPI <= eps, "Passed!" );

			} );

			QUnit.test( "identity", ( assert ) => {

				var a = new Quaternion();

				a.set( x, y, z, w );
				a.identity();

				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z === 0, "Passed!" );
				assert.ok( a.w === 1, "Passed!" );

			} );

			QUnit.test( "invert/conjugate", ( assert ) => {

				var a = new Quaternion( x, y, z, w );

				// TODO: add better validation here.

				var b = a.clone().conjugate();

				assert.ok( a.x == - b.x, "Passed!" );
				assert.ok( a.y == - b.y, "Passed!" );
				assert.ok( a.z == - b.z, "Passed!" );
				assert.ok( a.w == b.w, "Passed!" );

			} );

			QUnit.test( "dot", ( assert ) => {

				var a = new Quaternion();
				var b = new Quaternion();

				assert.ok( a.dot( b ) === 1, "Passed!" );
				a = new Quaternion( 1, 2, 3, 1 );
				b = new Quaternion( 3, 2, 1, 1 );

				assert.ok( a.dot( b ) === 11, "Passed!" );


			} );

			QUnit.test( "normalize/length/lengthSq", ( assert ) => {

				var a = new Quaternion( x, y, z, w );

				assert.ok( a.length() != 1, "Passed!" );
				assert.ok( a.lengthSq() != 1, "Passed!" );
				a.normalize();
				assert.ok( a.length() == 1, "Passed!" );
				assert.ok( a.lengthSq() == 1, "Passed!" );

				a.set( 0, 0, 0, 0 );
				assert.ok( a.lengthSq() == 0, "Passed!" );
				assert.ok( a.length() == 0, "Passed!" );
				a.normalize();
				assert.ok( a.lengthSq() == 1, "Passed!" );
				assert.ok( a.length() == 1, "Passed!" );

			} );

			QUnit.test( "multiplyQuaternions/multiply", ( assert ) => {

				var angles = [ new Euler( 1, 0, 0 ), new Euler( 0, 1, 0 ), new Euler( 0, 0, 1 ) ];

				var q1 = new Quaternion().setFromEuler( changeEulerOrder( angles[ 0 ], "XYZ" ) );
				var q2 = new Quaternion().setFromEuler( changeEulerOrder( angles[ 1 ], "XYZ" ) );
				var q3 = new Quaternion().setFromEuler( changeEulerOrder( angles[ 2 ], "XYZ" ) );

				var q = new Quaternion().multiplyQuaternions( q1, q2 ).multiply( q3 );

				var m1 = new Matrix4().makeRotationFromEuler( changeEulerOrder( angles[ 0 ], "XYZ" ) );
				var m2 = new Matrix4().makeRotationFromEuler( changeEulerOrder( angles[ 1 ], "XYZ" ) );
				var m3 = new Matrix4().makeRotationFromEuler( changeEulerOrder( angles[ 2 ], "XYZ" ) );

				var m = new Matrix4().multiplyMatrices( m1, m2 ).multiply( m3 );

				var qFromM = new Quaternion().setFromRotationMatrix( m );

				assert.ok( qSub( q, qFromM ).length() < 0.001, "Passed!" );

			} );

			QUnit.test( "premultiply", ( assert ) => {

				var a = new Quaternion( x, y, z, w );
				var b = new Quaternion( 2 * x, - y, - 2 * z, w );
				var expected = new Quaternion( 42, - 32, - 2, 58 );

				a.premultiply( b );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Check w" );

			} );

			QUnit.test( "slerp", ( assert ) => {

				var a = new Quaternion( x, y, z, w );
				var b = new Quaternion( - x, - y, - z, - w );

				var c = a.clone().slerp( b, 0 );
				var d = a.clone().slerp( b, 1 );

				assert.ok( a.equals( c ), "Passed" );
				assert.ok( b.equals( d ), "Passed" );


				var D = Math.SQRT1_2;

				var e = new Quaternion( 1, 0, 0, 0 );
				var f = new Quaternion( 0, 0, 1, 0 );
				var expected = new Quaternion( D, 0, D, 0 );
				var result = e.clone().slerp( f, 0.5 );
				assert.ok( Math.abs( result.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( result.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( result.z - expected.z ) <= eps, "Check z" );
				assert.ok( Math.abs( result.w - expected.w ) <= eps, "Check w" );


				var g = new Quaternion( 0, D, 0, D );
				var h = new Quaternion( 0, - D, 0, D );
				expected = new Quaternion( 0, 0, 0, 1 );
				result = g.clone().slerp( h, 0.5 );

				assert.ok( Math.abs( result.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( result.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( result.z - expected.z ) <= eps, "Check z" );
				assert.ok( Math.abs( result.w - expected.w ) <= eps, "Check w" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Quaternion( x, y, z, w );
				var b = new Quaternion( - x, - y, - z, - w );

				assert.ok( a.x != b.x, "Passed!" );
				assert.ok( a.y != b.y, "Passed!" );

				assert.ok( ! a.equals( b ), "Passed!" );
				assert.ok( ! b.equals( a ), "Passed!" );

				a.copy( b );
				assert.ok( a.x == b.x, "Passed!" );
				assert.ok( a.y == b.y, "Passed!" );

				assert.ok( a.equals( b ), "Passed!" );
				assert.ok( b.equals( a ), "Passed!" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Quaternion();
				a.fromArray( [ x, y, z, w ] );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );
				assert.ok( a.w === w, "Passed!" );

				a.fromArray( [ undefined, x, y, z, w, undefined ], 1 );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );
				assert.ok( a.w === w, "Passed!" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Quaternion( x, y, z, w );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], x, "No array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "No array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "No array, no offset: check z" );
				assert.strictEqual( array[ 3 ], w, "No array, no offset: check w" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], x, "With array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "With array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "With array, no offset: check z" );
				assert.strictEqual( array[ 3 ], w, "With array, no offset: check w" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], x, "With array and offset: check x" );
				assert.strictEqual( array[ 2 ], y, "With array and offset: check y" );
				assert.strictEqual( array[ 3 ], z, "With array and offset: check z" );
				assert.strictEqual( array[ 4 ], w, "With array and offset: check w" );

			} );

			QUnit.test( "fromBufferAttribute", ( assert ) => {

				var a = new Quaternion();

				var attribute = new BufferAttribute( new Float32Array( [

					0, 0, 0, 1,
					.7, 0, 0, .7,
					0, .7, 0, .7,

				] ), 4 );

				a.fromBufferAttribute( attribute, 0 );
				assert.numEqual( a.x, 0, 'index 0, component x' );
				assert.numEqual( a.y, 0, 'index 0, component y' );
				assert.numEqual( a.z, 0, 'index 0, component z' );
				assert.numEqual( a.w, 1, 'index 0, component w' );

				a.fromBufferAttribute( attribute, 1 );
				assert.numEqual( a.x, .7, 'index 1, component x' );
				assert.numEqual( a.y, 0, 'index 1, component y' );
				assert.numEqual( a.z, 0, 'index 1, component z' );
				assert.numEqual( a.w, .7, 'index 1, component w' );

				a.fromBufferAttribute( attribute, 2 );
				assert.numEqual( a.x, 0, 'index 2, component x' );
				assert.numEqual( a.y, .7, 'index 2, component y' );
				assert.numEqual( a.z, 0, 'index 2, component z' );
				assert.numEqual( a.w, .7, 'index 2, component w' );

			} );

			QUnit.test( "_onChange", ( assert ) => {

				var b = false;
				var f = function () {

					b = true;

				};

				var a = new Quaternion( 11, 12, 13, 1 );
				a._onChange( f );
				assert.ok( a._onChangeCallback === f, "Passed!" );

				a._onChangeCallback();
				assert.ok( b, "Passed!" );


			} );

			QUnit.test( "_onChangeCallback", ( assert ) => {

				var b = false;
				var a = new Quaternion( 11, 12, 13, 1 );
				var f = function () {

					b = true;
					assert.ok( a === this, "Passed!" );

				};

				a._onChangeCallback = f;
				assert.ok( a._onChangeCallback === f, "Passed!" );


				a._onChangeCallback();
				assert.ok( b, "Passed!" );

			} );

			// OTHERS
			QUnit.test( "multiplyVector3", ( assert ) => {

				var angles = [ new Euler( 1, 0, 0 ), new Euler( 0, 1, 0 ), new Euler( 0, 0, 1 ) ];

				// ensure euler conversion for Quaternion matches that of Matrix4
				for ( var i = 0; i < orders.length; i ++ ) {

					for ( var j = 0; j < angles.length; j ++ ) {

						var q = new Quaternion().setFromEuler( changeEulerOrder( angles[ j ], orders[ i ] ) );
						var m = new Matrix4().makeRotationFromEuler( changeEulerOrder( angles[ j ], orders[ i ] ) );

						var v0 = new Vector3( 1, 0, 0 );
						var qv = v0.clone().applyQuaternion( q );
						var mv = v0.clone().applyMatrix4( m );

						assert.ok( qv.distanceTo( mv ) < 0.001, "Passed!" );

					}

				}

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Ray', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Ray();
				assert.ok( a.origin.equals( zero3 ), "Passed!" );
				assert.ok( a.direction.equals( new Vector3( 0, 0, - 1 ) ), "Passed!" );

				var a = new Ray( two3.clone(), one3.clone() );
				assert.ok( a.origin.equals( two3 ), "Passed!" );
				assert.ok( a.direction.equals( one3 ), "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isRay", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Ray();

				a.set( one3, one3 );
				assert.ok( a.origin.equals( one3 ), "Passed!" );
				assert.ok( a.direction.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "recast/clone", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );

				assert.ok( a.recast( 0 ).equals( a ), "Passed!" );

				var b = a.clone();
				assert.ok( b.recast( - 1 ).equals( new Ray( new Vector3( 1, 1, 0 ), new Vector3( 0, 0, 1 ) ) ), "Passed!" );

				var c = a.clone();
				assert.ok( c.recast( 1 ).equals( new Ray( new Vector3( 1, 1, 2 ), new Vector3( 0, 0, 1 ) ) ), "Passed!" );

				var d = a.clone();
				var e = d.clone().recast( 1 );
				assert.ok( d.equals( a ), "Passed!" );
				assert.ok( ! e.equals( d ), "Passed!" );
				assert.ok( e.equals( c ), "Passed!" );

			} );

			QUnit.test( "copy/equals", ( assert ) => {

				var a = new Ray( zero3.clone(), one3.clone() );
				var b = new Ray().copy( a );
				assert.ok( b.origin.equals( zero3 ), "Passed!" );
				assert.ok( b.direction.equals( one3 ), "Passed!" );

				// ensure that it is a true copy
				a.origin = zero3;
				a.direction = one3;
				assert.ok( b.origin.equals( zero3 ), "Passed!" );
				assert.ok( b.direction.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "at", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var point = new Vector3();

				a.at( 0, point );
				assert.ok( point.equals( one3 ), "Passed!" );
				a.at( - 1, point );
				assert.ok( point.equals( new Vector3( 1, 1, 0 ) ), "Passed!" );
				a.at( 1, point );
				assert.ok( point.equals( new Vector3( 1, 1, 2 ) ), "Passed!" );

			} );

			QUnit.test( "lookAt", ( assert ) => {

				var a = new Ray( two3.clone(), one3.clone() );
				var target = one3.clone();
				var expected = target.sub( two3 ).normalize();

				a.lookAt( target );
				assert.ok( a.direction.equals( expected ), "Check if we're looking in the right direction" );

			} );

			QUnit.test( "closestPointToPoint", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var point = new Vector3();

				// behind the ray
				a.closestPointToPoint( zero3, point );
				assert.ok( point.equals( one3 ), "Passed!" );

				// front of the ray
				a.closestPointToPoint( new Vector3( 0, 0, 50 ), point );
				assert.ok( point.equals( new Vector3( 1, 1, 50 ) ), "Passed!" );

				// exactly on the ray
				a.closestPointToPoint( one3, point );
				assert.ok( point.equals( one3 ), "Passed!" );

			} );

			QUnit.test( "distanceToPoint", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );

				// behind the ray
				var b = a.distanceToPoint( zero3 );
				assert.ok( b === Math.sqrt( 3 ), "Passed!" );

				// front of the ray
				var c = a.distanceToPoint( new Vector3( 0, 0, 50 ) );
				assert.ok( c === Math.sqrt( 2 ), "Passed!" );

				// exactly on the ray
				var d = a.distanceToPoint( one3 );
				assert.ok( d === 0, "Passed!" );

			} );

			QUnit.test( "distanceSqToPoint", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );

				// behind the ray
				var b = a.distanceSqToPoint( zero3 );
				assert.ok( b === 3, "Passed!" );

				// front of the ray
				var c = a.distanceSqToPoint( new Vector3( 0, 0, 50 ) );
				assert.ok( c === 2, "Passed!" );

				// exactly on the ray
				var d = a.distanceSqToPoint( one3 );
				assert.ok( d === 0, "Passed!" );

			} );

			QUnit.test( "distanceSqToSegment", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var ptOnLine = new Vector3();
				var ptOnSegment = new Vector3();

				//segment in front of the ray
				var v0 = new Vector3( 3, 5, 50 );
				var v1 = new Vector3( 50, 50, 50 ); // just a far away point
				var distSqr = a.distanceSqToSegment( v0, v1, ptOnLine, ptOnSegment );

				assert.ok( ptOnSegment.distanceTo( v0 ) < 0.0001, "Passed!" );
				assert.ok( ptOnLine.distanceTo( new Vector3( 1, 1, 50 ) ) < 0.0001, "Passed!" );
				// ((3-1) * (3-1) + (5-1) * (5-1) = 4 + 16 = 20
				assert.ok( Math.abs( distSqr - 20 ) < 0.0001, "Passed!" );

				//segment behind the ray
				var v0 = new Vector3( - 50, - 50, - 50 ); // just a far away point
				var v1 = new Vector3( - 3, - 5, - 4 );
				var distSqr = a.distanceSqToSegment( v0, v1, ptOnLine, ptOnSegment );

				assert.ok( ptOnSegment.distanceTo( v1 ) < 0.0001, "Passed!" );
				assert.ok( ptOnLine.distanceTo( one3 ) < 0.0001, "Passed!" );
				// ((-3-1) * (-3-1) + (-5-1) * (-5-1) + (-4-1) + (-4-1) = 16 + 36 + 25 = 77
				assert.ok( Math.abs( distSqr - 77 ) < 0.0001, "Passed!" );

				//exact intersection between the ray and the segment
				var v0 = new Vector3( - 50, - 50, - 50 );
				var v1 = new Vector3( 50, 50, 50 );
				var distSqr = a.distanceSqToSegment( v0, v1, ptOnLine, ptOnSegment );

				assert.ok( ptOnSegment.distanceTo( one3 ) < 0.0001, "Passed!" );
				assert.ok( ptOnLine.distanceTo( one3 ) < 0.0001, "Passed!" );
				assert.ok( distSqr < 0.0001, "Passed!" );

			} );

			QUnit.test( "intersectSphere", ( assert ) => {

				var TOL = 0.0001;
				var point = new Vector3();

				// ray a0 origin located at ( 0, 0, 0 ) and points outward in negative-z direction
				var a0 = new Ray( zero3.clone(), new Vector3( 0, 0, - 1 ) );
				// ray a1 origin located at ( 1, 1, 1 ) and points left in negative-x direction
				var a1 = new Ray( one3.clone(), new Vector3( - 1, 0, 0 ) );

				// sphere (radius of 2) located behind ray a0, should result in null
				var b = new Sphere( new Vector3( 0, 0, 3 ), 2 );
				a0.intersectSphere( b, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// sphere (radius of 2) located in front of, but too far right of ray a0, should result in null
				var b = new Sphere( new Vector3( 3, 0, - 1 ), 2 );
				a0.intersectSphere( b, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// sphere (radius of 2) located below ray a1, should result in null
				var b = new Sphere( new Vector3( 1, - 2, 1 ), 2 );
				a1.intersectSphere( b, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// sphere (radius of 1) located to the left of ray a1, should result in intersection at 0, 1, 1
				var b = new Sphere( new Vector3( - 1, 1, 1 ), 1 );
				a1.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 1, 1 ) ) < TOL, "Passed!" );

				// sphere (radius of 1) located in front of ray a0, should result in intersection at 0, 0, -1
				var b = new Sphere( new Vector3( 0, 0, - 2 ), 1 );
				a0.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 0, - 1 ) ) < TOL, "Passed!" );

				// sphere (radius of 2) located in front & right of ray a0, should result in intersection at 0, 0, -1, or left-most edge of sphere
				var b = new Sphere( new Vector3( 2, 0, - 1 ), 2 );
				a0.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 0, - 1 ) ) < TOL, "Passed!" );

				// same situation as above, but move the sphere a fraction more to the right, and ray a0 should now just miss
				var b = new Sphere( new Vector3( 2.01, 0, - 1 ), 2 );
				a0.intersectSphere( b, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// following QUnit.tests are for situations where the ray origin is inside the sphere

				// sphere (radius of 1) center located at ray a0 origin / sphere surrounds the ray origin, so the first intersect point 0, 0, 1,
				// is behind ray a0.  Therefore, second exit point on back of sphere will be returned: 0, 0, -1
				// thus keeping the intersection point always in front of the ray.
				var b = new Sphere( zero3.clone(), 1 );
				a0.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 0, - 1 ) ) < TOL, "Passed!" );

				// sphere (radius of 4) center located behind ray a0 origin / sphere surrounds the ray origin, so the first intersect point 0, 0, 5,
				// is behind ray a0.  Therefore, second exit point on back of sphere will be returned: 0, 0, -3
				// thus keeping the intersection point always in front of the ray.
				var b = new Sphere( new Vector3( 0, 0, 1 ), 4 );
				a0.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 0, - 3 ) ) < TOL, "Passed!" );

				// sphere (radius of 4) center located in front of ray a0 origin / sphere surrounds the ray origin, so the first intersect point 0, 0, 3,
				// is behind ray a0.  Therefore, second exit point on back of sphere will be returned: 0, 0, -5
				// thus keeping the intersection point always in front of the ray.
				var b = new Sphere( new Vector3( 0, 0, - 1 ), 4 );
				a0.intersectSphere( b, point );
				assert.ok( point.distanceTo( new Vector3( 0, 0, - 5 ) ) < TOL, "Passed!" );

			} );

			QUnit.test( "intersectsSphere", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var b = new Sphere( zero3, 0.5 );
				var c = new Sphere( zero3, 1.5 );
				var d = new Sphere( one3, 0.1 );
				var e = new Sphere( two3, 0.1 );
				var f = new Sphere( two3, 1 );

				assert.ok( ! a.intersectsSphere( b ), "Passed!" );
				assert.ok( ! a.intersectsSphere( c ), "Passed!" );
				assert.ok( a.intersectsSphere( d ), "Passed!" );
				assert.ok( ! a.intersectsSphere( e ), "Passed!" );
				assert.ok( ! a.intersectsSphere( f ), "Passed!" );

			} );

			QUnit.todo( "distanceToPlane", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "intersectPlane", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var point = new Vector3();

				// parallel plane behind
				var b = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), new Vector3( 1, 1, - 1 ) );
				a.intersectPlane( b, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// parallel plane coincident with origin
				var c = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), new Vector3( 1, 1, 0 ) );
				a.intersectPlane( c, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				// parallel plane infront
				var d = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), new Vector3( 1, 1, 1 ) );
				a.intersectPlane( d, point.copy( posInf3 ) );
				assert.ok( point.equals( a.origin ), "Passed!" );

				// perpendical ray that overlaps exactly
				var e = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 1, 0, 0 ), one3 );
				a.intersectPlane( e, point.copy( posInf3 ) );
				assert.ok( point.equals( a.origin ), "Passed!" );

				// perpendical ray that doesn't overlap
				var f = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 1, 0, 0 ), zero3 );
				a.intersectPlane( f, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

			} );

			QUnit.test( "intersectsPlane", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );

				// parallel plane in front of the ray
				var b = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), one3.clone().sub( new Vector3( 0, 0, - 1 ) ) );
				assert.ok( a.intersectsPlane( b ), "Passed!" );

				// parallel plane coincident with origin
				var c = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), one3.clone().sub( new Vector3( 0, 0, 0 ) ) );
				assert.ok( a.intersectsPlane( c ), "Passed!" );

				// parallel plane behind the ray
				var d = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 0, 0, 1 ), one3.clone().sub( new Vector3( 0, 0, 1 ) ) );
				assert.ok( ! a.intersectsPlane( d ), "Passed!" );

				// perpendical ray that overlaps exactly
				var e = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 1, 0, 0 ), one3 );
				assert.ok( a.intersectsPlane( e ), "Passed!" );

				// perpendical ray that doesn't overlap
				var f = new Plane().setFromNormalAndCoplanarPoint( new Vector3( 1, 0, 0 ), zero3 );
				assert.ok( ! a.intersectsPlane( f ), "Passed!" );

			} );

			QUnit.test( "intersectBox", ( assert ) => {

				var TOL = 0.0001;

				var box = new Box3( new Vector3( - 1, - 1, - 1 ), new Vector3( 1, 1, 1 ) );
				var point = new Vector3();

				var a = new Ray( new Vector3( - 2, 0, 0 ), new Vector3( 1, 0, 0 ) );
				//ray should intersect box at -1,0,0
				assert.ok( a.intersectsBox( box ) === true, "Passed!" );
				a.intersectBox( box, point );
				assert.ok( point.distanceTo( new Vector3( - 1, 0, 0 ) ) < TOL, "Passed!" );

				var b = new Ray( new Vector3( - 2, 0, 0 ), new Vector3( - 1, 0, 0 ) );
				//ray is point away from box, it should not intersect
				assert.ok( b.intersectsBox( box ) === false, "Passed!" );
				b.intersectBox( box, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

				var c = new Ray( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ) );
				// ray is inside box, should return exit point
				assert.ok( c.intersectsBox( box ) === true, "Passed!" );
				c.intersectBox( box, point );
				assert.ok( point.distanceTo( new Vector3( 1, 0, 0 ) ) < TOL, "Passed!" );

				var d = new Ray( new Vector3( 0, 2, 1 ), new Vector3( 0, - 1, - 1 ).normalize() );
				//tilted ray should intersect box at 0,1,0
				assert.ok( d.intersectsBox( box ) === true, "Passed!" );
				d.intersectBox( box, point );
				assert.ok( point.distanceTo( new Vector3( 0, 1, 0 ) ) < TOL, "Passed!" );

				var e = new Ray( new Vector3( 1, - 2, 1 ), new Vector3( 0, 1, 0 ).normalize() );
				//handle case where ray is coplanar with one of the boxes side - box in front of ray
				assert.ok( e.intersectsBox( box ) === true, "Passed!" );
				e.intersectBox( box, point );
				assert.ok( point.distanceTo( new Vector3( 1, - 1, 1 ) ) < TOL, "Passed!" );

				var f = new Ray( new Vector3( 1, - 2, 0 ), new Vector3( 0, - 1, 0 ).normalize() );
				//handle case where ray is coplanar with one of the boxes side - box behind ray
				assert.ok( f.intersectsBox( box ) === false, "Passed!" );
				f.intersectBox( box, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "Passed!" );

			} );

			QUnit.todo( "intersectsBox", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "intersectTriangle", ( assert ) => {

				var ray = new Ray();
				var a = new Vector3( 1, 1, 0 );
				var b = new Vector3( 0, 1, 1 );
				var c = new Vector3( 1, 0, 1 );
				var point = new Vector3();

				// DdN == 0
				ray.set( ray.origin, zero3.clone() );
				ray.intersectTriangle( a, b, c, false, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection if direction == zero" );

				// DdN > 0, backfaceCulling = true
				ray.set( ray.origin, one3.clone() );
				ray.intersectTriangle( a, b, c, true, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection with backside faces if backfaceCulling is true" );

				// DdN > 0
				ray.set( ray.origin, one3.clone() );
				ray.intersectTriangle( a, b, c, false, point );
				assert.ok( Math.abs( point.x - 2 / 3 ) <= eps, "Successful intersection: check x" );
				assert.ok( Math.abs( point.y - 2 / 3 ) <= eps, "Successful intersection: check y" );
				assert.ok( Math.abs( point.z - 2 / 3 ) <= eps, "Successful intersection: check z" );

				// DdN > 0, DdQxE2 < 0
				b.multiplyScalar( - 1 );
				ray.intersectTriangle( a, b, c, false, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection" );

				// DdN > 0, DdE1xQ < 0
				a.multiplyScalar( - 1 );
				ray.intersectTriangle( a, b, c, false, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection" );

				// DdN > 0, DdQxE2 + DdE1xQ > DdN
				b.multiplyScalar( - 1 );
				ray.intersectTriangle( a, b, c, false, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection" );

				// DdN < 0, QdN < 0
				a.multiplyScalar( - 1 );
				b.multiplyScalar( - 1 );
				ray.direction.multiplyScalar( - 1 );
				ray.intersectTriangle( a, b, c, false, point.copy( posInf3 ) );
				assert.ok( point.equals( posInf3 ), "No intersection when looking in the wrong direction" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Ray( one3.clone(), new Vector3( 0, 0, 1 ) );
				var m = new Matrix4();

				assert.ok( a.clone().applyMatrix4( m ).equals( a ), "Passed!" );

				var a = new Ray( zero3.clone(), new Vector3( 0, 0, 1 ) );
				m.makeRotationZ( Math.PI );
				assert.ok( a.clone().applyMatrix4( m ).equals( a ), "Passed!" );

				m.makeRotationX( Math.PI );
				var b = a.clone();
				b.direction.negate();
				var a2 = a.clone().applyMatrix4( m );
				assert.ok( a2.origin.distanceTo( b.origin ) < 0.0001, "Passed!" );
				assert.ok( a2.direction.distanceTo( b.direction ) < 0.0001, "Passed!" );

				a.origin = new Vector3( 0, 0, 1 );
				b.origin = new Vector3( 0, 0, - 1 );
				var a2 = a.clone().applyMatrix4( m );
				assert.ok( a2.origin.distanceTo( b.origin ) < 0.0001, "Passed!" );
				assert.ok( a2.direction.distanceTo( b.direction ) < 0.0001, "Passed!" );

			} );

			QUnit.todo( "equals", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Sphere', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Sphere();
				assert.ok( a.center.equals( zero3 ), "Passed!" );
				assert.ok( a.radius == - 1, "Passed!" );

				var a = new Sphere( one3.clone(), 1 );
				assert.ok( a.center.equals( one3 ), "Passed!" );
				assert.ok( a.radius == 1, "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSphere", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Sphere();
				assert.ok( a.center.equals( zero3 ), "Passed!" );
				assert.ok( a.radius == - 1, "Passed!" );

				a.set( one3, 1 );
				assert.ok( a.center.equals( one3 ), "Passed!" );
				assert.ok( a.radius == 1, "Passed!" );

			} );

			QUnit.test( "setFromPoints", ( assert ) => {

				var a = new Sphere();
				var expectedCenter = new Vector3( 0.9330126941204071, 0, 0 );
				var expectedRadius = 1.3676668773461689;
				var optionalCenter = new Vector3( 1, 1, 1 );
				var points = [
					new Vector3( 1, 1, 0 ), new Vector3( 1, 1, 0 ),
					new Vector3( 1, 1, 0 ), new Vector3( 1, 1, 0 ),
					new Vector3( 1, 1, 0 ), new Vector3( 0.8660253882408142, 0.5, 0 ),
					new Vector3( - 0, 0.5, 0.8660253882408142 ), new Vector3( 1.8660253882408142, 0.5, 0 ),
					new Vector3( 0, 0.5, - 0.8660253882408142 ), new Vector3( 0.8660253882408142, 0.5, - 0 ),
					new Vector3( 0.8660253882408142, - 0.5, 0 ), new Vector3( - 0, - 0.5, 0.8660253882408142 ),
					new Vector3( 1.8660253882408142, - 0.5, 0 ), new Vector3( 0, - 0.5, - 0.8660253882408142 ),
					new Vector3( 0.8660253882408142, - 0.5, - 0 ), new Vector3( - 0, - 1, 0 ),
					new Vector3( - 0, - 1, 0 ), new Vector3( 0, - 1, 0 ),
					new Vector3( 0, - 1, - 0 ), new Vector3( - 0, - 1, - 0 ),
				];

				a.setFromPoints( points );
				assert.ok( Math.abs( a.center.x - expectedCenter.x ) <= eps, "Default center: check center.x" );
				assert.ok( Math.abs( a.center.y - expectedCenter.y ) <= eps, "Default center: check center.y" );
				assert.ok( Math.abs( a.center.z - expectedCenter.z ) <= eps, "Default center: check center.z" );
				assert.ok( Math.abs( a.radius - expectedRadius ) <= eps, "Default center: check radius" );

				var expectedRadius = 2.5946195770400102;
				a.setFromPoints( points, optionalCenter );
				assert.ok( Math.abs( a.center.x - optionalCenter.x ) <= eps, "Optional center: check center.x" );
				assert.ok( Math.abs( a.center.y - optionalCenter.y ) <= eps, "Optional center: check center.y" );
				assert.ok( Math.abs( a.center.z - optionalCenter.z ) <= eps, "Optional center: check center.z" );
				assert.ok( Math.abs( a.radius - expectedRadius ) <= eps, "Optional center: check radius" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );
				var b = new Sphere().copy( a );

				assert.ok( b.center.equals( one3 ), "Passed!" );
				assert.ok( b.radius == 1, "Passed!" );

				// ensure that it is a true copy
				a.center = zero3;
				a.radius = 0;
				assert.ok( b.center.equals( one3 ), "Passed!" );
				assert.ok( b.radius == 1, "Passed!" );

			} );

			QUnit.test( "isEmpty", ( assert ) => {

				var a = new Sphere();
				assert.ok( a.isEmpty(), "Passed!" );

				a.set( one3, 1 );
				assert.ok( ! a.isEmpty(), "Passed!" );

				// Negative radius contains no points
				a.set( one3, -1 );
				assert.ok( a.isEmpty(), "Passed!" );

				// Zero radius contains only the center point
				a.set( one3, 0 );
				assert.ok( ! a.isEmpty(), "Passed!" );

			} );

			QUnit.test( "makeEmpty", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );

				assert.ok( ! a.isEmpty(), "Passed!" );

				a.makeEmpty();
				assert.ok( a.isEmpty(), "Passed!" );
				assert.ok( a.center.equals( zero3 ), "Passed!" );

			} );

			QUnit.test( "containsPoint", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );

				assert.ok( ! a.containsPoint( zero3 ), "Passed!" );
				assert.ok( a.containsPoint( one3 ), "Passed!" );

				a.set( zero3, 0 );
				assert.ok( a.containsPoint( a.center ), "Passed!" );

			} );

			QUnit.test( "distanceToPoint", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );

				assert.ok( ( a.distanceToPoint( zero3 ) - 0.7320 ) < 0.001, "Passed!" );
				assert.ok( a.distanceToPoint( one3 ) === - 1, "Passed!" );

			} );

			QUnit.test( "intersectsSphere", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );
				var b = new Sphere( zero3.clone(), 1 );
				var c = new Sphere( zero3.clone(), 0.25 );

				assert.ok( a.intersectsSphere( b ), "Passed!" );
				assert.ok( ! a.intersectsSphere( c ), "Passed!" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var a = new Sphere( zero3, 1 );
				var b = new Sphere( new Vector3( - 5, - 5, - 5 ), 1 );
				var box = new Box3( zero3, one3 );

				assert.strictEqual( a.intersectsBox( box ), true, "Check unit sphere" );
				assert.strictEqual( b.intersectsBox( box ), false, "Check shifted sphere" );

			} );

			QUnit.test( "intersectsPlane", ( assert ) => {

				var a = new Sphere( zero3.clone(), 1 );
				var b = new Plane( new Vector3( 0, 1, 0 ), 1 );
				var c = new Plane( new Vector3( 0, 1, 0 ), 1.25 );
				var d = new Plane( new Vector3( 0, - 1, 0 ), 1.25 );

				assert.ok( a.intersectsPlane( b ), "Passed!" );
				assert.ok( ! a.intersectsPlane( c ), "Passed!" );
				assert.ok( ! a.intersectsPlane( d ), "Passed!" );

			} );

			QUnit.test( "clampPoint", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );
				var point = new Vector3();

				a.clampPoint( new Vector3( 1, 1, 3 ), point );
				assert.ok( point.equals( new Vector3( 1, 1, 2 ) ), "Passed!" );
				a.clampPoint( new Vector3( 1, 1, - 3 ), point );
				assert.ok( point.equals( new Vector3( 1, 1, 0 ) ), "Passed!" );

			} );

			QUnit.test( "getBoundingBox", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );
				var aabb = new Box3();

				a.getBoundingBox( aabb );
				assert.ok( aabb.equals( new Box3( zero3, two3 ) ), "Passed!" );

				a.set( zero3, 0 );
				a.getBoundingBox( aabb );
				assert.ok( aabb.equals( new Box3( zero3, zero3 ) ), "Passed!" );

				// Empty sphere produces empty bounding box
				a.makeEmpty();
				a.getBoundingBox( aabb );
				assert.ok( aabb.isEmpty(), "Passed!" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );
				var m = new Matrix4().makeTranslation( 1, - 2, 1 );
				var aabb1 = new Box3();
				var aabb2 = new Box3();

				a.clone().applyMatrix4( m ).getBoundingBox( aabb1 );
				a.getBoundingBox( aabb2 );

				assert.ok( aabb1.equals( aabb2.applyMatrix4( m ) ), "Passed!" );

			} );

			QUnit.test( "translate", ( assert ) => {

				var a = new Sphere( one3.clone(), 1 );

				a.translate( one3.clone().negate() );
				assert.ok( a.center.equals( zero3 ), "Passed!" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Sphere();
				var b = new Sphere( new Vector3( 1, 0, 0 ) );
				var c = new Sphere( new Vector3( 1, 0, 0 ), 1.0 );

				assert.strictEqual( a.equals( b ), false, "a does not equal b" );
				assert.strictEqual( a.equals( c ), false, "a does not equal c" );
				assert.strictEqual( b.equals( c ), false, "b does not equal c" );

				a.copy( b );
				assert.strictEqual( a.equals( b ), true, "a equals b after copy()" );

			} );

		} );

	} );

	/**
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	class Spherical {

		constructor( radius = 1, phi = 0, theta = 0 ) {

			this.radius = radius;
			this.phi = phi; // polar angle
			this.theta = theta; // azimuthal angle

			return this;

		}

		set( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		}

		copy( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		}

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe() {

			const EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		}

		setFromVector3( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		}

		setFromCartesianCoords( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

		clone() {

			return new this.constructor().copy( this );

		}

	}

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Spherical', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Spherical();
				var radius = 10.0;
				var phi = Math.acos( - 0.5 );
				var theta = Math.sqrt( Math.PI ) * phi;

				assert.strictEqual( a.radius, 1.0, "Default values: check radius" );
				assert.strictEqual( a.phi, 0, "Default values: check phi" );
				assert.strictEqual( a.theta, 0, "Default values: check theta" );

				var a = new Spherical( radius, phi, theta );
				assert.strictEqual( a.radius, radius, "Custom values: check radius" );
				assert.strictEqual( a.phi, phi, "Custom values: check phi" );
				assert.strictEqual( a.theta, theta, "Custom values: check theta" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSpherical", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Spherical();
				var radius = 10.0;
				var phi = Math.acos( - 0.5 );
				var theta = Math.sqrt( Math.PI ) * phi;

				a.set( radius, phi, theta );
				assert.strictEqual( a.radius, radius, "Check radius" );
				assert.strictEqual( a.phi, phi, "Check phi" );
				assert.strictEqual( a.theta, theta, "Check theta" );

			} );

			QUnit.test( "clone", ( assert ) => {

				var radius = 10.0;
				var phi = Math.acos( - 0.5 );
				var theta = Math.sqrt( Math.PI ) * phi;
				var a = new Spherical( radius, phi, theta );
				var b = a.clone();

				assert.propEqual( a, b, "Check a and b are equal after clone()" );

				a.radius = 2.0;
				assert.notPropEqual( a, b, "Check a and b are not equal after modification" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var radius = 10.0;
				var phi = Math.acos( - 0.5 );
				var theta = Math.sqrt( Math.PI ) * phi;
				var a = new Spherical( radius, phi, theta );
				var b = new Spherical().copy( a );

				assert.propEqual( a, b, "Check a and b are equal after copy()" );

				a.radius = 2.0;
				assert.notPropEqual( a, b, "Check a and b are not equal after modification" );

			} );

			QUnit.test( "makeSafe", ( assert ) => {

				var EPS = 0.000001; // from source
				var tooLow = 0.0;
				var tooHigh = Math.PI;
				var justRight = 1.5;
				var a = new Spherical( 1, tooLow, 0 );

				a.makeSafe();
				assert.strictEqual( a.phi, EPS, "Check if small values are set to EPS" );

				a.set( 1, tooHigh, 0 );
				a.makeSafe();
				assert.strictEqual( a.phi, Math.PI - EPS, "Check if high values are set to (Math.PI - EPS)" );

				a.set( 1, justRight, 0 );
				a.makeSafe();
				assert.strictEqual( a.phi, justRight, "Check that valid values don't get changed" );

			} );

			QUnit.test( "setFromVector3", ( assert ) => {

				var a = new Spherical( 1, 1, 1 );
				var b = new Vector3( 0, 0, 0 );
				var c = new Vector3( Math.PI, 1, - Math.PI );
				var expected = new Spherical( 4.554032147688322, 1.3494066171539107, 2.356194490192345 );

				a.setFromVector3( b );
				assert.strictEqual( a.radius, 0, "Zero-length vector: check radius" );
				assert.strictEqual( a.phi, 0, "Zero-length vector: check phi" );
				assert.strictEqual( a.theta, 0, "Zero-length vector: check theta" );

				a.setFromVector3( c );
				assert.ok( Math.abs( a.radius - expected.radius ) <= eps, "Normal vector: check radius" );
				assert.ok( Math.abs( a.phi - expected.phi ) <= eps, "Normal vector: check phi" );
				assert.ok( Math.abs( a.theta - expected.theta ) <= eps, "Normal vector: check theta" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Triangle', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Triangle();
				assert.ok( a.a.equals( zero3 ), "Passed!" );
				assert.ok( a.b.equals( zero3 ), "Passed!" );
				assert.ok( a.c.equals( zero3 ), "Passed!" );

				var a = new Triangle( one3.clone().negate(), one3.clone(), two3.clone() );
				assert.ok( a.a.equals( one3.clone().negate() ), "Passed!" );
				assert.ok( a.b.equals( one3 ), "Passed!" );
				assert.ok( a.c.equals( two3 ), "Passed!" );

			} );

			// STATIC STUFF
			QUnit.todo( "getNormal", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getBarycoord", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "containsPoint", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.test( "set", ( assert ) => {

				var a = new Triangle();

				a.set( one3.clone().negate(), one3, two3 );
				assert.ok( a.a.equals( one3.clone().negate() ), "Passed!" );
				assert.ok( a.b.equals( one3 ), "Passed!" );
				assert.ok( a.c.equals( two3 ), "Passed!" );

			} );

			QUnit.test( "setFromPointsAndIndices", ( assert ) => {

				var a = new Triangle();

				var points = [ one3, one3.clone().negate(), two3 ];
				a.setFromPointsAndIndices( points, 1, 0, 2 );
				assert.ok( a.a.equals( one3.clone().negate() ), "Passed!" );
				assert.ok( a.b.equals( one3 ), "Passed!" );
				assert.ok( a.c.equals( two3 ), "Passed!" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Triangle( one3.clone().negate(), one3.clone(), two3.clone() );
				var b = new Triangle().copy( a );
				assert.ok( b.a.equals( one3.clone().negate() ), "Passed!" );
				assert.ok( b.b.equals( one3 ), "Passed!" );
				assert.ok( b.c.equals( two3 ), "Passed!" );

				// ensure that it is a true copy
				a.a = one3;
				a.b = zero3;
				a.c = zero3;
				assert.ok( b.a.equals( one3.clone().negate() ), "Passed!" );
				assert.ok( b.b.equals( one3 ), "Passed!" );
				assert.ok( b.c.equals( two3 ), "Passed!" );

			} );

			QUnit.test( "getArea", ( assert ) => {

				var a = new Triangle();

				assert.ok( a.getArea() == 0, "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				assert.ok( a.getArea() == 0.5, "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				assert.ok( a.getArea() == 2, "Passed!" );

				// colinear triangle.
				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 3, 0, 0 ) );
				assert.ok( a.getArea() == 0, "Passed!" );

			} );

			QUnit.test( "getMidpoint", ( assert ) => {

				var a = new Triangle();
				var midpoint = new Vector3();

				assert.ok( a.getMidpoint( midpoint ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				assert.ok( a.getMidpoint( midpoint ).equals( new Vector3( 1 / 3, 1 / 3, 0 ) ), "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				assert.ok( a.getMidpoint( midpoint ).equals( new Vector3( 2 / 3, 0, 2 / 3 ) ), "Passed!" );

			} );

			QUnit.test( "getNormal", ( assert ) => {

				var a = new Triangle();
				var normal = new Vector3();

				assert.ok( a.getNormal( normal ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				assert.ok( a.getNormal( normal ).equals( new Vector3( 0, 0, 1 ) ), "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				assert.ok( a.getNormal( normal ).equals( new Vector3( 0, 1, 0 ) ), "Passed!" );

			} );

			QUnit.test( "getPlane", ( assert ) => {

				var a = new Triangle();
				var plane = new Plane();
				var normal = new Vector3();

				a.getPlane( plane );
				assert.notOk( isNaN( plane.distanceToPoint( a.a ) ), "Passed!" );
				assert.notOk( isNaN( plane.distanceToPoint( a.b ) ), "Passed!" );
				assert.notOk( isNaN( plane.distanceToPoint( a.c ) ), "Passed!" );
				assert.notPropEqual( plane.normal, {
					x: NaN,
					y: NaN,
					z: NaN
				}, "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				a.getPlane( plane );
				a.getNormal( normal );
				assert.ok( plane.distanceToPoint( a.a ) == 0, "Passed!" );
				assert.ok( plane.distanceToPoint( a.b ) == 0, "Passed!" );
				assert.ok( plane.distanceToPoint( a.c ) == 0, "Passed!" );
				assert.ok( plane.normal.equals( normal ), "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				a.getPlane( plane );
				a.getNormal( normal );
				assert.ok( plane.distanceToPoint( a.a ) == 0, "Passed!" );
				assert.ok( plane.distanceToPoint( a.b ) == 0, "Passed!" );
				assert.ok( plane.distanceToPoint( a.c ) == 0, "Passed!" );
				assert.ok( plane.normal.clone().normalize().equals( normal ), "Passed!" );

			} );

			QUnit.test( "getBarycoord", ( assert ) => {

				var a = new Triangle();

				var bad = new Vector3( - 2, - 1, - 1 );
				var barycoord = new Vector3();
				var midpoint = new Vector3();

				a.getBarycoord( a.a, barycoord );
				assert.ok( barycoord.equals( bad ), "Passed!" );
				a.getBarycoord( a.b, barycoord );
				assert.ok( barycoord.equals( bad ), "Passed!" );
				a.getBarycoord( a.c, barycoord );
				assert.ok( barycoord.equals( bad ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				a.getMidpoint( midpoint );

				a.getBarycoord( a.a, barycoord );
				assert.ok( barycoord.equals( new Vector3( 1, 0, 0 ) ), "Passed!" );
				a.getBarycoord( a.b, barycoord );
				assert.ok( barycoord.equals( new Vector3( 0, 1, 0 ) ), "Passed!" );
				a.getBarycoord( a.c, barycoord );
				assert.ok( barycoord.equals( new Vector3( 0, 0, 1 ) ), "Passed!" );
				a.getBarycoord( midpoint, barycoord );
				assert.ok( barycoord.distanceTo( new Vector3( 1 / 3, 1 / 3, 1 / 3 ) ) < 0.0001, "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				a.getMidpoint( midpoint );

				a.getBarycoord( a.a, barycoord );
				assert.ok( barycoord.equals( new Vector3( 1, 0, 0 ) ), "Passed!" );
				a.getBarycoord( a.b, barycoord );
				assert.ok( barycoord.equals( new Vector3( 0, 1, 0 ) ), "Passed!" );
				a.getBarycoord( a.c, barycoord );
				assert.ok( barycoord.equals( new Vector3( 0, 0, 1 ) ), "Passed!" );
				a.getBarycoord( midpoint, barycoord );
				assert.ok( barycoord.distanceTo( new Vector3( 1 / 3, 1 / 3, 1 / 3 ) ) < 0.0001, "Passed!" );

			} );

			QUnit.test( "containsPoint", ( assert ) => {

				var a = new Triangle();
				var midpoint = new Vector3();

				assert.ok( ! a.containsPoint( a.a ), "Passed!" );
				assert.ok( ! a.containsPoint( a.b ), "Passed!" );
				assert.ok( ! a.containsPoint( a.c ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				a.getMidpoint( midpoint );
				assert.ok( a.containsPoint( a.a ), "Passed!" );
				assert.ok( a.containsPoint( a.b ), "Passed!" );
				assert.ok( a.containsPoint( a.c ), "Passed!" );
				assert.ok( a.containsPoint( midpoint ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 1, - 1, - 1 ) ), "Passed!" );

				var a = new Triangle( new Vector3( 2, 0, 0 ), new Vector3( 0, 0, 0 ), new Vector3( 0, 0, 2 ) );
				a.getMidpoint( midpoint );
				assert.ok( a.containsPoint( a.a ), "Passed!" );
				assert.ok( a.containsPoint( a.b ), "Passed!" );
				assert.ok( a.containsPoint( a.c ), "Passed!" );
				assert.ok( a.containsPoint( midpoint ), "Passed!" );
				assert.ok( ! a.containsPoint( new Vector3( - 1, - 1, - 1 ) ), "Passed!" );

			} );

			QUnit.test( "intersectsBox", ( assert ) => {

				var a = new Box3( one3.clone(), two3.clone() );
				var b = new Triangle( new Vector3( 1.5, 1.5, 2.5 ), new Vector3( 2.5, 1.5, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var c = new Triangle( new Vector3( 1.5, 1.5, 3.5 ), new Vector3( 3.5, 1.5, 1.5 ), new Vector3( 1.5, 1.5, 1.5 ) );
				var d = new Triangle( new Vector3( 1.5, 1.75, 3 ), new Vector3( 3, 1.75, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var e = new Triangle( new Vector3( 1.5, 1.8, 3 ), new Vector3( 3, 1.8, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );
				var f = new Triangle( new Vector3( 1.5, 2.5, 3 ), new Vector3( 3, 2.5, 1.5 ), new Vector3( 1.5, 2.5, 1.5 ) );

				assert.ok( b.intersectsBox( a ), "Passed!" );
				assert.ok( c.intersectsBox( a ), "Passed!" );
				assert.ok( d.intersectsBox( a ), "Passed!" );
				assert.ok( ! e.intersectsBox( a ), "Passed!" );
				assert.ok( ! f.intersectsBox( a ), "Passed!" );

			} );

			QUnit.test( "closestPointToPoint", ( assert ) => {

				var a = new Triangle( new Vector3( - 1, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				var point = new Vector3();

				// point lies inside the triangle
				a.closestPointToPoint( new Vector3( 0, 0.5, 0 ), point );
				assert.ok( point.equals( new Vector3( 0, 0.5, 0 ) ), "Passed!" );

				// point lies on a vertex
				a.closestPointToPoint( a.a, point );
				assert.ok( point.equals( a.a ), "Passed!" );

				a.closestPointToPoint( a.b, point );
				assert.ok( point.equals( a.b ), "Passed!" );

				a.closestPointToPoint( a.c, point );
				assert.ok( point.equals( a.c ), "Passed!" );

				// point lies on an edge
				a.closestPointToPoint( zero3.clone(), point );
				assert.ok( point.equals( zero3.clone() ), "Passed!" );

				// point lies outside the triangle
				a.closestPointToPoint( new Vector3( - 2, 0, 0 ), point );
				assert.ok( point.equals( new Vector3( - 1, 0, 0 ) ), "Passed!" );

				a.closestPointToPoint( new Vector3( 2, 0, 0 ), point );
				assert.ok( point.equals( new Vector3( 1, 0, 0 ) ), "Passed!" );

				a.closestPointToPoint( new Vector3( 0, 2, 0 ), point );
				assert.ok( point.equals( new Vector3( 0, 1, 0 ) ), "Passed!" );

				a.closestPointToPoint( new Vector3( 0, - 2, 0 ), point );
				assert.ok( point.equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

			} );

			QUnit.test( "isFrontFacing", ( assert ) => {

				var a = new Triangle();
				var dir = new Vector3();
				assert.ok( ! a.isFrontFacing( dir ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ) );
				var dir = new Vector3( 0, 0, - 1 );
				assert.ok( a.isFrontFacing( dir ), "Passed!" );

				var a = new Triangle( new Vector3( 0, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 1, 0, 0 ) );
				assert.ok( ! a.isFrontFacing( dir ), "Passed!" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Triangle(
					new Vector3( 1, 0, 0 ),
					new Vector3( 0, 1, 0 ),
					new Vector3( 0, 0, 1 )
				);
				var b = new Triangle(
					new Vector3( 0, 0, 1 ),
					new Vector3( 0, 1, 0 ),
					new Vector3( 1, 0, 0 )
				);
				var c = new Triangle(
					new Vector3( - 1, 0, 0 ),
					new Vector3( 0, 1, 0 ),
					new Vector3( 0, 0, 1 )
				);

				assert.ok( a.equals( a ), "a equals a" );
				assert.notOk( a.equals( b ), "a does not equal b" );
				assert.notOk( a.equals( c ), "a does not equal c" );
				assert.notOk( b.equals( c ), "b does not equal c" );

				a.copy( b );
				assert.ok( a.equals( a ), "a equals b after copy()" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Vector2', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Vector2();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );

				var a = new Vector2( x, y );
				assert.ok( a.x === x, "Passed!" );
				assert.ok( a.y === y, "Passed!" );

			} );

			// PROPERTIES // ( [Itee] WHAT ??? o_O )
			QUnit.test( "properties", ( assert ) => {

				var a = new Vector2( 0, 0 );
				var width = 100;
				var height = 200;

				assert.ok( a.width = width, "Set width" );
				assert.ok( a.height = height, "Set height" );

				a.set( width, height );
				assert.strictEqual( a.width, width, "Get width" );
				assert.strictEqual( a.height, height, "Get height" );

			} );

			QUnit.todo( "width", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "height", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isVector2", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Vector2();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );

				a.set( x, y );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );

			} );

			QUnit.todo( "setScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setX", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2().copy( a );
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );

				// ensure that it is a true copy
				a.x = 0;
				a.y = - 1;
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );

			} );

			QUnit.test( "add", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( - x, - y );

				a.add( b );
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );

				var c = new Vector2().addVectors( b, b );
				assert.ok( c.x == - 2 * x, "Passed!" );
				assert.ok( c.y == - 2 * y, "Passed!" );

			} );

			QUnit.todo( "addScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "addVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "addScaledVector", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( 2, 3 );
				var s = 3;

				a.addScaledVector( b, s );
				assert.strictEqual( a.x, x + b.x * s, "Check x" );
				assert.strictEqual( a.y, y + b.y * s, "Check y" );

			} );

			QUnit.test( "sub", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( - x, - y );

				a.sub( b );
				assert.ok( a.x == 2 * x, "Passed!" );
				assert.ok( a.y == 2 * y, "Passed!" );

				var c = new Vector2().subVectors( a, a );
				assert.ok( c.x == 0, "Passed!" );
				assert.ok( c.y == 0, "Passed!" );

			} );

			QUnit.todo( "subScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "subVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "multiply", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "multiplyScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "divide", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "divideScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "applyMatrix3", ( assert ) => {

				var a = new Vector2( x, y );
				var m = new Matrix3().set( 2, 3, 5, 7, 11, 13, 17, 19, 23 );

				a.applyMatrix3( m );
				assert.strictEqual( a.x, 18, "Check x" );
				assert.strictEqual( a.y, 60, "Check y" );

			} );

			QUnit.todo( "min", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "max", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clamp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clampScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clampLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "floor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "ceil", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "round", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "roundToZero", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "negate", ( assert ) => {

				var a = new Vector2( x, y );

				a.negate();
				assert.ok( a.x == - x, "Passed!" );
				assert.ok( a.y == - y, "Passed!" );

			} );

			QUnit.test( "dot", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( - x, - y );
				var c = new Vector2();

				var result = a.dot( b );
				assert.ok( result == ( - x * x - y * y ), "Passed!" );

				var result = a.dot( c );
				assert.ok( result == 0, "Passed!" );

			} );

			QUnit.test( "cross", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( 2 * x, - y );
				var answer = - 18;
				var crossed = a.cross( b );

				assert.ok( Math.abs( answer - crossed ) <= eps, "Check cross" );

			} );

			QUnit.todo( "lengthSq", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "length", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "manhattanLength", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );
				var c = new Vector2();

				assert.strictEqual( a.manhattanLength(), x, "Positive component" );
				assert.strictEqual( b.manhattanLength(), y, "Negative component" );
				assert.strictEqual( c.manhattanLength(), 0, "Empty component" );

				a.set( x, y );
				assert.strictEqual( a.manhattanLength(), Math.abs( x ) + Math.abs( y ), "Two components" );

			} );

			QUnit.test( "normalize", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );

				a.normalize();
				assert.ok( a.length() == 1, "Passed!" );
				assert.ok( a.x == 1, "Passed!" );

				b.normalize();
				assert.ok( b.length() == 1, "Passed!" );
				assert.ok( b.y == - 1, "Passed!" );

			} );

			QUnit.todo( "angle", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "distanceTo", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "distanceToSquared", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "manhattanDistanceTo", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setLength", ( assert ) => {

				var a = new Vector2( x, 0 );

				assert.ok( a.length() == x, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == y, "Passed!" );

				var a = new Vector2( 0, 0 );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength();
				assert.ok( isNaN( a.length() ), "Passed!" );

			} );

			QUnit.todo( "lerp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "lerpVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );

				assert.ok( a.x != b.x, "Passed!" );
				assert.ok( a.y != b.y, "Passed!" );

				assert.ok( ! a.equals( b ), "Passed!" );
				assert.ok( ! b.equals( a ), "Passed!" );

				a.copy( b );
				assert.ok( a.x == b.x, "Passed!" );
				assert.ok( a.y == b.y, "Passed!" );

				assert.ok( a.equals( b ), "Passed!" );
				assert.ok( b.equals( a ), "Passed!" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Vector2();
				var array = [ 1, 2, 3, 4 ];

				a.fromArray( array );
				assert.strictEqual( a.x, 1, "No offset: check x" );
				assert.strictEqual( a.y, 2, "No offset: check y" );

				a.fromArray( array, 2 );
				assert.strictEqual( a.x, 3, "With offset: check x" );
				assert.strictEqual( a.y, 4, "With offset: check y" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Vector2( x, y );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], x, "No array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "No array, no offset: check y" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], x, "With array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "With array, no offset: check y" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], x, "With array and offset: check x" );
				assert.strictEqual( array[ 2 ], y, "With array and offset: check y" );

			} );

			QUnit.test( "fromBufferAttribute", ( assert ) => {

				var a = new Vector2();
				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4 ] ), 2 );

				a.fromBufferAttribute( attr, 0 );
				assert.strictEqual( a.x, 1, "Offset 0: check x" );
				assert.strictEqual( a.y, 2, "Offset 0: check y" );

				a.fromBufferAttribute( attr, 1 );
				assert.strictEqual( a.x, 3, "Offset 1: check x" );
				assert.strictEqual( a.y, 4, "Offset 1: check y" );

			} );

			QUnit.todo( "rotateAround", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


			// TODO (Itee) refactor/split
			QUnit.test( "setX,setY", ( assert ) => {

				var a = new Vector2();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );

				a.setX( x );
				a.setY( y );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );

			} );
			QUnit.test( "setComponent,getComponent", ( assert ) => {

				var a = new Vector2();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );

				a.setComponent( 0, 1 );
				a.setComponent( 1, 2 );
				assert.ok( a.getComponent( 0 ) == 1, "Passed!" );
				assert.ok( a.getComponent( 1 ) == 2, "Passed!" );

			} );
			QUnit.test( "multiply/divide", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( - x, - y );

				a.multiplyScalar( - 2 );
				assert.ok( a.x == x * - 2, "Passed!" );
				assert.ok( a.y == y * - 2, "Passed!" );

				b.multiplyScalar( - 2 );
				assert.ok( b.x == 2 * x, "Passed!" );
				assert.ok( b.y == 2 * y, "Passed!" );

				a.divideScalar( - 2 );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );

				b.divideScalar( - 2 );
				assert.ok( b.x == - x, "Passed!" );
				assert.ok( b.y == - y, "Passed!" );

			} );
			QUnit.test( "min/max/clamp", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( - x, - y );
				var c = new Vector2();

				c.copy( a ).min( b );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == - y, "Passed!" );

				c.copy( a ).max( b );
				assert.ok( c.x == x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );

				c.set( - 2 * x, 2 * y );
				c.clamp( b, a );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );

				c.set( - 2 * x, 2 * x );
				c.clampScalar( - x, x );
				assert.equal( c.x, - x, "scalar clamp x" );
				assert.equal( c.y, x, "scalar clamp y" );

			} );
			QUnit.test( "rounding", ( assert ) => {

				assert.deepEqual( new Vector2( - 0.1, 0.1 ).floor(), new Vector2( - 1, 0 ), "floor .1" );
				assert.deepEqual( new Vector2( - 0.5, 0.5 ).floor(), new Vector2( - 1, 0 ), "floor .5" );
				assert.deepEqual( new Vector2( - 0.9, 0.9 ).floor(), new Vector2( - 1, 0 ), "floor .9" );

				assert.deepEqual( new Vector2( - 0.1, 0.1 ).ceil(), new Vector2( 0, 1 ), "ceil .1" );
				assert.deepEqual( new Vector2( - 0.5, 0.5 ).ceil(), new Vector2( 0, 1 ), "ceil .5" );
				assert.deepEqual( new Vector2( - 0.9, 0.9 ).ceil(), new Vector2( 0, 1 ), "ceil .9" );

				assert.deepEqual( new Vector2( - 0.1, 0.1 ).round(), new Vector2( 0, 0 ), "round .1" );
				assert.deepEqual( new Vector2( - 0.5, 0.5 ).round(), new Vector2( 0, 1 ), "round .5" );
				assert.deepEqual( new Vector2( - 0.9, 0.9 ).round(), new Vector2( - 1, 1 ), "round .9" );

				assert.deepEqual( new Vector2( - 0.1, 0.1 ).roundToZero(), new Vector2( 0, 0 ), "roundToZero .1" );
				assert.deepEqual( new Vector2( - 0.5, 0.5 ).roundToZero(), new Vector2( 0, 0 ), "roundToZero .5" );
				assert.deepEqual( new Vector2( - 0.9, 0.9 ).roundToZero(), new Vector2( 0, 0 ), "roundToZero .9" );
				assert.deepEqual( new Vector2( - 1.1, 1.1 ).roundToZero(), new Vector2( - 1, 1 ), "roundToZero 1.1" );
				assert.deepEqual( new Vector2( - 1.5, 1.5 ).roundToZero(), new Vector2( - 1, 1 ), "roundToZero 1.5" );
				assert.deepEqual( new Vector2( - 1.9, 1.9 ).roundToZero(), new Vector2( - 1, 1 ), "roundToZero 1.9" );

			} );
			QUnit.test( "length/lengthSq", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );
				var c = new Vector2();

				assert.ok( a.length() == x, "Passed!" );
				assert.ok( a.lengthSq() == x * x, "Passed!" );
				assert.ok( b.length() == y, "Passed!" );
				assert.ok( b.lengthSq() == y * y, "Passed!" );
				assert.ok( c.length() == 0, "Passed!" );
				assert.ok( c.lengthSq() == 0, "Passed!" );

				a.set( x, y );
				assert.ok( a.length() == Math.sqrt( x * x + y * y ), "Passed!" );
				assert.ok( a.lengthSq() == ( x * x + y * y ), "Passed!" );

			} );
			QUnit.test( "distanceTo/distanceToSquared", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );
				var c = new Vector2();

				assert.ok( a.distanceTo( c ) == x, "Passed!" );
				assert.ok( a.distanceToSquared( c ) == x * x, "Passed!" );

				assert.ok( b.distanceTo( c ) == y, "Passed!" );
				assert.ok( b.distanceToSquared( c ) == y * y, "Passed!" );

			} );
			QUnit.test( "lerp/clone", ( assert ) => {

				var a = new Vector2( x, 0 );
				var b = new Vector2( 0, - y );

				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 0.5 ) ), "Passed!" );
				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 1 ) ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0 ).equals( a ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0.5 ).x == x * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).y == - y * 0.5, "Passed!" );

				assert.ok( a.clone().lerp( b, 1 ).equals( b ), "Passed!" );

			} );
			QUnit.test( "setComponent/getComponent exceptions", ( assert ) => {

				var a = new Vector2( 0, 0 );

				assert.throws(
					function () {

						a.setComponent( 2, 0 );

					},
					/index is out of range/,
					"setComponent with an out of range index throws Error"
				);
				assert.throws(
					function () {

						a.getComponent( 2 );

					},
					/index is out of range/,
					"getComponent with an out of range index throws Error"
				);

			} );
			QUnit.test( "setScalar/addScalar/subScalar", ( assert ) => {

				var a = new Vector2( 1, 1 );
				var s = 3;

				a.setScalar( s );
				assert.strictEqual( a.x, s, "setScalar: check x" );
				assert.strictEqual( a.y, s, "setScalar: check y" );

				a.addScalar( s );
				assert.strictEqual( a.x, 2 * s, "addScalar: check x" );
				assert.strictEqual( a.y, 2 * s, "addScalar: check y" );

				a.subScalar( 2 * s );
				assert.strictEqual( a.x, 0, "subScalar: check x" );
				assert.strictEqual( a.y, 0, "subScalar: check y" );

			} );
			QUnit.test( "multiply/divide", ( assert ) => {

				var a = new Vector2( x, y );
				var b = new Vector2( 2 * x, 2 * y );
				var c = new Vector2( 4 * x, 4 * y );

				a.multiply( b );
				assert.strictEqual( a.x, x * b.x, "multiply: check x" );
				assert.strictEqual( a.y, y * b.y, "multiply: check y" );

				b.divide( c );
				assert.strictEqual( b.x, 0.5, "divide: check x" );
				assert.strictEqual( b.y, 0.5, "divide: check y" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Vector3', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Vector3();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );

				var a = new Vector3( x, y, z );
				assert.ok( a.x === x, "Passed!" );
				assert.ok( a.y === y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isVector3", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Vector3();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );

				a.set( x, y, z );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );

			} );

			QUnit.todo( "setScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setX", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setZ", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3().copy( a );
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z == z, "Passed!" );

				// ensure that it is a true copy
				a.x = 0;
				a.y = - 1;
				a.z = - 2;
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z == z, "Passed!" );

			} );

			QUnit.test( "add", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( - x, - y, - z );

				a.add( b );
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );

				var c = new Vector3().addVectors( b, b );
				assert.ok( c.x == - 2 * x, "Passed!" );
				assert.ok( c.y == - 2 * y, "Passed!" );
				assert.ok( c.z == - 2 * z, "Passed!" );

			} );

			QUnit.todo( "addScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "addVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "addScaledVector", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( 2, 3, 4 );
				var s = 3;

				a.addScaledVector( b, s );
				assert.strictEqual( a.x, x + b.x * s, "Check x" );
				assert.strictEqual( a.y, y + b.y * s, "Check y" );
				assert.strictEqual( a.z, z + b.z * s, "Check z" );

			} );

			QUnit.test( "sub", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( - x, - y, - z );

				a.sub( b );
				assert.ok( a.x == 2 * x, "Passed!" );
				assert.ok( a.y == 2 * y, "Passed!" );
				assert.ok( a.z == 2 * z, "Passed!" );

				var c = new Vector3().subVectors( a, a );
				assert.ok( c.x == 0, "Passed!" );
				assert.ok( c.y == 0, "Passed!" );
				assert.ok( c.z == 0, "Passed!" );

			} );

			QUnit.todo( "subScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "subVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "multiply", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "multiplyScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "multiplyVectors", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( 2, 3, - 5 );

				var c = new Vector3().multiplyVectors( a, b );
				assert.strictEqual( c.x, x * 2, "Check x" );
				assert.strictEqual( c.y, y * 3, "Check y" );
				assert.strictEqual( c.z, z * - 5, "Check z" );

			} );

			QUnit.test( "applyEuler", ( assert ) => {

				var a = new Vector3( x, y, z );
				var euler = new Euler( 90, - 45, 0 );
				var expected = new Vector3( - 2.352970120501014, - 4.7441750936226645, 0.9779234597246458 );

				a.applyEuler( euler );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );

			} );

			QUnit.test( "applyAxisAngle", ( assert ) => {

				var a = new Vector3( x, y, z );
				var axis = new Vector3( 0, 1, 0 );
				var angle = Math.PI / 4.0;
				var expected = new Vector3( 3 * Math.sqrt( 2 ), 3, Math.sqrt( 2 ) );

				a.applyAxisAngle( axis, angle );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );

			} );

			QUnit.test( "applyMatrix3", ( assert ) => {

				var a = new Vector3( x, y, z );
				var m = new Matrix3().set( 2, 3, 5, 7, 11, 13, 17, 19, 23 );

				a.applyMatrix3( m );
				assert.strictEqual( a.x, 33, "Check x" );
				assert.strictEqual( a.y, 99, "Check y" );
				assert.strictEqual( a.z, 183, "Check z" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {


				var a = new Vector3( x, y, z );
				var b = new Vector4( x, y, z, 1 );

				var m = new Matrix4().makeRotationX( Math.PI );
				a.applyMatrix4( m );
				b.applyMatrix4( m );
				assert.ok( a.x == b.x / b.w, "Passed!" );
				assert.ok( a.y == b.y / b.w, "Passed!" );
				assert.ok( a.z == b.z / b.w, "Passed!" );

				var m = new Matrix4().makeTranslation( 3, 2, 1 );
				a.applyMatrix4( m );
				b.applyMatrix4( m );
				assert.ok( a.x == b.x / b.w, "Passed!" );
				assert.ok( a.y == b.y / b.w, "Passed!" );
				assert.ok( a.z == b.z / b.w, "Passed!" );

				var m = new Matrix4().set(
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 1, 0
				);
				a.applyMatrix4( m );
				b.applyMatrix4( m );
				assert.ok( a.x == b.x / b.w, "Passed!" );
				assert.ok( a.y == b.y / b.w, "Passed!" );
				assert.ok( a.z == b.z / b.w, "Passed!" );

			} );

			QUnit.test( "applyQuaternion", ( assert ) => {

				var a = new Vector3( x, y, z );

				a.applyQuaternion( new Quaternion() );
				assert.strictEqual( a.x, x, "Identity rotation: check x" );
				assert.strictEqual( a.y, y, "Identity rotation: check y" );
				assert.strictEqual( a.z, z, "Identity rotation: check z" );

				a.applyQuaternion( new Quaternion( x, y, z, w ) );
				assert.strictEqual( a.x, 108, "Normal rotation: check x" );
				assert.strictEqual( a.y, 162, "Normal rotation: check y" );
				assert.strictEqual( a.z, 216, "Normal rotation: check z" );

			} );

			QUnit.todo( "project", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "unproject", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "transformDirection", ( assert ) => {

				var a = new Vector3( x, y, z );
				var m = new Matrix4();
				var transformed = new Vector3( 0.3713906763541037, 0.5570860145311556, 0.7427813527082074 );

				a.transformDirection( m );
				assert.ok( Math.abs( a.x - transformed.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - transformed.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - transformed.z ) <= eps, "Check z" );

			} );

			QUnit.todo( "divide", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "divideScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "min", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "max", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clamp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "clampScalar", ( assert ) => {

				var a = new Vector3( - 0.01, 0.5, 1.5 );
				var clamped = new Vector3( 0.1, 0.5, 1.0 );

				a.clampScalar( 0.1, 1.0 );
				assert.ok( Math.abs( a.x - clamped.x ) <= 0.001, "Check x" );
				assert.ok( Math.abs( a.y - clamped.y ) <= 0.001, "Check y" );
				assert.ok( Math.abs( a.z - clamped.z ) <= 0.001, "Check z" );

			} );

			QUnit.todo( "clampLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "floor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "ceil", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "round", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "roundToZero", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "negate", ( assert ) => {

				var a = new Vector3( x, y, z );

				a.negate();
				assert.ok( a.x == - x, "Passed!" );
				assert.ok( a.y == - y, "Passed!" );
				assert.ok( a.z == - z, "Passed!" );

			} );

			QUnit.test( "dot", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( - x, - y, - z );
				var c = new Vector3();

				var result = a.dot( b );
				assert.ok( result == ( - x * x - y * y - z * z ), "Passed!" );

				var result = a.dot( c );
				assert.ok( result == 0, "Passed!" );

			} );

			QUnit.todo( "lengthSq", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "length", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "manhattanLength", ( assert ) => {

				var a = new Vector3( x, 0, 0 );
				var b = new Vector3( 0, - y, 0 );
				var c = new Vector3( 0, 0, z );
				var d = new Vector3();

				assert.ok( a.manhattanLength() == x, "Positive x" );
				assert.ok( b.manhattanLength() == y, "Negative y" );
				assert.ok( c.manhattanLength() == z, "Positive z" );
				assert.ok( d.manhattanLength() == 0, "Empty initialization" );

				a.set( x, y, z );
				assert.ok( a.manhattanLength() == Math.abs( x ) + Math.abs( y ) + Math.abs( z ), "All components" );

			} );

			QUnit.test( "normalize", ( assert ) => {

				var a = new Vector3( x, 0, 0 );
				var b = new Vector3( 0, - y, 0 );
				var c = new Vector3( 0, 0, z );

				a.normalize();
				assert.ok( a.length() == 1, "Passed!" );
				assert.ok( a.x == 1, "Passed!" );

				b.normalize();
				assert.ok( b.length() == 1, "Passed!" );
				assert.ok( b.y == - 1, "Passed!" );

				c.normalize();
				assert.ok( c.length() == 1, "Passed!" );
				assert.ok( c.z == 1, "Passed!" );

			} );

			QUnit.test( "setLength", ( assert ) => {

				var a = new Vector3( x, 0, 0 );

				assert.ok( a.length() == x, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == y, "Passed!" );

				var a = new Vector3( 0, 0, 0 );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength();
				assert.ok( isNaN( a.length() ), "Passed!" );

			} );

			QUnit.todo( "lerp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "lerpVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "cross", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( 2 * x, - y, 0.5 * z );
				var crossed = new Vector3( 18, 12, - 18 );

				a.cross( b );
				assert.ok( Math.abs( a.x - crossed.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - crossed.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - crossed.z ) <= eps, "Check z" );

			} );

			QUnit.test( "crossVectors", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( x, - y, z );
				var c = new Vector3();
				var crossed = new Vector3( 24, 0, - 12 );

				c.crossVectors( a, b );
				assert.ok( Math.abs( c.x - crossed.x ) <= eps, "Check x" );
				assert.ok( Math.abs( c.y - crossed.y ) <= eps, "Check y" );
				assert.ok( Math.abs( c.z - crossed.z ) <= eps, "Check z" );

			} );

			QUnit.test( "projectOnVector", ( assert ) => {

				var a = new Vector3( 1, 0, 0 );
				var b = new Vector3();
				var normal = new Vector3( 10, 0, 0 );

				assert.ok( b.copy( a ).projectOnVector( normal ).equals( new Vector3( 1, 0, 0 ) ), "Passed!" );

				a.set( 0, 1, 0 );
				assert.ok( b.copy( a ).projectOnVector( normal ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				a.set( 0, 0, - 1 );
				assert.ok( b.copy( a ).projectOnVector( normal ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				a.set( - 1, 0, 0 );
				assert.ok( b.copy( a ).projectOnVector( normal ).equals( new Vector3( - 1, 0, 0 ) ), "Passed!" );

			} );

			QUnit.test( "projectOnPlane", ( assert ) => {

				var a = new Vector3( 1, 0, 0 );
				var b = new Vector3();
				var normal = new Vector3( 1, 0, 0 );

				assert.ok( b.copy( a ).projectOnPlane( normal ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

				a.set( 0, 1, 0 );
				assert.ok( b.copy( a ).projectOnPlane( normal ).equals( new Vector3( 0, 1, 0 ) ), "Passed!" );

				a.set( 0, 0, - 1 );
				assert.ok( b.copy( a ).projectOnPlane( normal ).equals( new Vector3( 0, 0, - 1 ) ), "Passed!" );

				a.set( - 1, 0, 0 );
				assert.ok( b.copy( a ).projectOnPlane( normal ).equals( new Vector3( 0, 0, 0 ) ), "Passed!" );

			} );

			QUnit.test( "reflect", ( assert ) => {

				var a = new Vector3();
				var normal = new Vector3( 0, 1, 0 );
				var b = new Vector3();

				a.set( 0, - 1, 0 );
				assert.ok( b.copy( a ).reflect( normal ).equals( new Vector3( 0, 1, 0 ) ), "Passed!" );

				a.set( 1, - 1, 0 );
				assert.ok( b.copy( a ).reflect( normal ).equals( new Vector3( 1, 1, 0 ) ), "Passed!" );

				a.set( 1, - 1, 0 );
				normal.set( 0, - 1, 0 );
				assert.ok( b.copy( a ).reflect( normal ).equals( new Vector3( 1, 1, 0 ) ), "Passed!" );

			} );

			QUnit.test( "angleTo", ( assert ) => {

				var a = new Vector3( 0, - 0.18851655680720186, 0.9820700116639124 );
				var b = new Vector3( 0, 0.18851655680720186, - 0.9820700116639124 );

				assert.equal( a.angleTo( a ), 0 );
				assert.equal( a.angleTo( b ), Math.PI );

				var x = new Vector3( 1, 0, 0 );
				var y = new Vector3( 0, 1, 0 );
				var z = new Vector3( 0, 0, 1 );

				assert.equal( x.angleTo( y ), Math.PI / 2 );
				assert.equal( x.angleTo( z ), Math.PI / 2 );
				assert.equal( z.angleTo( x ), Math.PI / 2 );

				assert.ok( Math.abs( x.angleTo( new Vector3( 1, 1, 0 ) ) - ( Math.PI / 4 ) ) < 0.0000001 );

			} );

			QUnit.todo( "distanceTo", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "distanceToSquared", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "manhattanDistanceTo", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "setFromSpherical", ( assert ) => {

				var a = new Vector3();
				var phi = Math.acos( - 0.5 );
				var theta = Math.sqrt( Math.PI ) * phi;
				var sph = new Spherical( 10, phi, theta );
				var expected = new Vector3( - 4.677914006701843, - 5, - 7.288149322420796 );

				a.setFromSpherical( sph );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );

			} );

			QUnit.test( "setFromCylindrical", ( assert ) => {

				var a = new Vector3();
				var cyl = new Cylindrical( 10, Math.PI * 0.125, 20 );
				var expected = new Vector3( 3.826834323650898, 20, 9.238795325112868 );

				a.setFromCylindrical( cyl );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );

			} );

			QUnit.test( "setFromMatrixPosition", ( assert ) => {

				var a = new Vector3();
				var m = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );

				a.setFromMatrixPosition( m );
				assert.strictEqual( a.x, 7, "Check x" );
				assert.strictEqual( a.y, 19, "Check y" );
				assert.strictEqual( a.z, 37, "Check z" );

			} );

			QUnit.test( "setFromMatrixScale", ( assert ) => {

				var a = new Vector3();
				var m = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );
				var expected = new Vector3( 25.573423705088842, 31.921779399024736, 35.70714214271425 );

				a.setFromMatrixScale( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Check z" );

			} );

			QUnit.test( "setFromMatrixColumn", ( assert ) => {

				var a = new Vector3();
				var m = new Matrix4().set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );

				a.setFromMatrixColumn( m, 0 );
				assert.strictEqual( a.x, 2, "Index 0: check x" );
				assert.strictEqual( a.y, 11, "Index 0: check y" );
				assert.strictEqual( a.z, 23, "Index 0: check z" );

				a.setFromMatrixColumn( m, 2 );
				assert.strictEqual( a.x, 5, "Index 2: check x" );
				assert.strictEqual( a.y, 17, "Index 2: check y" );
				assert.strictEqual( a.z, 31, "Index 2: check z" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Vector3( x, 0, z );
				var b = new Vector3( 0, - y, 0 );

				assert.ok( a.x != b.x, "Passed!" );
				assert.ok( a.y != b.y, "Passed!" );
				assert.ok( a.z != b.z, "Passed!" );

				assert.ok( ! a.equals( b ), "Passed!" );
				assert.ok( ! b.equals( a ), "Passed!" );

				a.copy( b );
				assert.ok( a.x == b.x, "Passed!" );
				assert.ok( a.y == b.y, "Passed!" );
				assert.ok( a.z == b.z, "Passed!" );

				assert.ok( a.equals( b ), "Passed!" );
				assert.ok( b.equals( a ), "Passed!" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Vector3();
				var array = [ 1, 2, 3, 4, 5, 6 ];

				a.fromArray( array );
				assert.strictEqual( a.x, 1, "No offset: check x" );
				assert.strictEqual( a.y, 2, "No offset: check y" );
				assert.strictEqual( a.z, 3, "No offset: check z" );

				a.fromArray( array, 3 );
				assert.strictEqual( a.x, 4, "With offset: check x" );
				assert.strictEqual( a.y, 5, "With offset: check y" );
				assert.strictEqual( a.z, 6, "With offset: check z" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Vector3( x, y, z );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], x, "No array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "No array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "No array, no offset: check z" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], x, "With array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "With array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "With array, no offset: check z" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], x, "With array and offset: check x" );
				assert.strictEqual( array[ 2 ], y, "With array and offset: check y" );
				assert.strictEqual( array[ 3 ], z, "With array and offset: check z" );

			} );

			QUnit.test( "fromBufferAttribute", ( assert ) => {

				var a = new Vector3();
				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6 ] ), 3 );

				a.fromBufferAttribute( attr, 0 );
				assert.strictEqual( a.x, 1, "Offset 0: check x" );
				assert.strictEqual( a.y, 2, "Offset 0: check y" );
				assert.strictEqual( a.z, 3, "Offset 0: check z" );

				a.fromBufferAttribute( attr, 1 );
				assert.strictEqual( a.x, 4, "Offset 1: check x" );
				assert.strictEqual( a.y, 5, "Offset 1: check y" );
				assert.strictEqual( a.z, 6, "Offset 1: check z" );

			} );

			// TODO (Itee) refactor/split
			QUnit.test( "setX,setY,setZ", ( assert ) => {

				var a = new Vector3();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );

				a.setX( x );
				a.setY( y );
				a.setZ( z );

				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );

			} );
			QUnit.test( "setComponent,getComponent", ( assert ) => {

				var a = new Vector3();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );

				a.setComponent( 0, 1 );
				a.setComponent( 1, 2 );
				a.setComponent( 2, 3 );
				assert.ok( a.getComponent( 0 ) == 1, "Passed!" );
				assert.ok( a.getComponent( 1 ) == 2, "Passed!" );
				assert.ok( a.getComponent( 2 ) == 3, "Passed!" );

			} );
			QUnit.test( "setComponent/getComponent exceptions", ( assert ) => {

				var a = new Vector3();

				assert.throws(
					function () {

						a.setComponent( 3, 0 );

					},
					/index is out of range/,
					"setComponent with an out of range index throws Error"
				);
				assert.throws(
					function () {

						a.getComponent( 3 );

					},
					/index is out of range/,
					"getComponent with an out of range index throws Error"
				);

			} );
			QUnit.test( "min/max/clamp", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( - x, - y, - z );
				var c = new Vector3();

				c.copy( a ).min( b );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == - y, "Passed!" );
				assert.ok( c.z == - z, "Passed!" );

				c.copy( a ).max( b );
				assert.ok( c.x == x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );
				assert.ok( c.z == z, "Passed!" );

				c.set( - 2 * x, 2 * y, - 2 * z );
				c.clamp( b, a );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );
				assert.ok( c.z == - z, "Passed!" );

			} );
			QUnit.test( "distanceTo/distanceToSquared", ( assert ) => {

				var a = new Vector3( x, 0, 0 );
				var b = new Vector3( 0, - y, 0 );
				var c = new Vector3( 0, 0, z );
				var d = new Vector3();

				assert.ok( a.distanceTo( d ) == x, "Passed!" );
				assert.ok( a.distanceToSquared( d ) == x * x, "Passed!" );

				assert.ok( b.distanceTo( d ) == y, "Passed!" );
				assert.ok( b.distanceToSquared( d ) == y * y, "Passed!" );

				assert.ok( c.distanceTo( d ) == z, "Passed!" );
				assert.ok( c.distanceToSquared( d ) == z * z, "Passed!" );

			} );
			QUnit.test( "setScalar/addScalar/subScalar", ( assert ) => {

				var a = new Vector3();
				var s = 3;

				a.setScalar( s );
				assert.strictEqual( a.x, s, "setScalar: check x" );
				assert.strictEqual( a.y, s, "setScalar: check y" );
				assert.strictEqual( a.z, s, "setScalar: check z" );

				a.addScalar( s );
				assert.strictEqual( a.x, 2 * s, "addScalar: check x" );
				assert.strictEqual( a.y, 2 * s, "addScalar: check y" );
				assert.strictEqual( a.z, 2 * s, "addScalar: check z" );

				a.subScalar( 2 * s );
				assert.strictEqual( a.x, 0, "subScalar: check x" );
				assert.strictEqual( a.y, 0, "subScalar: check y" );
				assert.strictEqual( a.z, 0, "subScalar: check z" );

			} );
			QUnit.test( "multiply/divide", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( 2 * x, 2 * y, 2 * z );
				var c = new Vector3( 4 * x, 4 * y, 4 * z );

				a.multiply( b );
				assert.strictEqual( a.x, x * b.x, "multiply: check x" );
				assert.strictEqual( a.y, y * b.y, "multiply: check y" );
				assert.strictEqual( a.z, z * b.z, "multiply: check z" );

				b.divide( c );
				assert.ok( Math.abs( b.x - 0.5 ) <= eps, "divide: check z" );
				assert.ok( Math.abs( b.y - 0.5 ) <= eps, "divide: check z" );
				assert.ok( Math.abs( b.z - 0.5 ) <= eps, "divide: check z" );

			} );
			QUnit.test( "multiply/divide", ( assert ) => {

				var a = new Vector3( x, y, z );
				var b = new Vector3( - x, - y, - z );

				a.multiplyScalar( - 2 );
				assert.ok( a.x == x * - 2, "Passed!" );
				assert.ok( a.y == y * - 2, "Passed!" );
				assert.ok( a.z == z * - 2, "Passed!" );

				b.multiplyScalar( - 2 );
				assert.ok( b.x == 2 * x, "Passed!" );
				assert.ok( b.y == 2 * y, "Passed!" );
				assert.ok( b.z == 2 * z, "Passed!" );

				a.divideScalar( - 2 );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );

				b.divideScalar( - 2 );
				assert.ok( b.x == - x, "Passed!" );
				assert.ok( b.y == - y, "Passed!" );
				assert.ok( b.z == - z, "Passed!" );

			} );
			QUnit.test( "project/unproject", ( assert ) => {

				var a = new Vector3( x, y, z );
				var camera = new PerspectiveCamera( 75, 16 / 9, 0.1, 300.0 );
				var projected = new Vector3( - 0.36653213611158914, - 0.9774190296309043, 1.0506835611870624 );

				a.project( camera );
				assert.ok( Math.abs( a.x - projected.x ) <= eps, "project: check x" );
				assert.ok( Math.abs( a.y - projected.y ) <= eps, "project: check y" );
				assert.ok( Math.abs( a.z - projected.z ) <= eps, "project: check z" );

				a.unproject( camera );
				assert.ok( Math.abs( a.x - x ) <= eps, "unproject: check x" );
				assert.ok( Math.abs( a.y - y ) <= eps, "unproject: check y" );
				assert.ok( Math.abs( a.z - z ) <= eps, "unproject: check z" );

			} );
			QUnit.test( "length/lengthSq", ( assert ) => {

				var a = new Vector3( x, 0, 0 );
				var b = new Vector3( 0, - y, 0 );
				var c = new Vector3( 0, 0, z );
				var d = new Vector3();

				assert.ok( a.length() == x, "Passed!" );
				assert.ok( a.lengthSq() == x * x, "Passed!" );
				assert.ok( b.length() == y, "Passed!" );
				assert.ok( b.lengthSq() == y * y, "Passed!" );
				assert.ok( c.length() == z, "Passed!" );
				assert.ok( c.lengthSq() == z * z, "Passed!" );
				assert.ok( d.length() == 0, "Passed!" );
				assert.ok( d.lengthSq() == 0, "Passed!" );

				a.set( x, y, z );
				assert.ok( a.length() == Math.sqrt( x * x + y * y + z * z ), "Passed!" );
				assert.ok( a.lengthSq() == ( x * x + y * y + z * z ), "Passed!" );

			} );
			QUnit.test( "lerp/clone", ( assert ) => {

				var a = new Vector3( x, 0, z );
				var b = new Vector3( 0, - y, 0 );

				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 0.5 ) ), "Passed!" );
				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 1 ) ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0 ).equals( a ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0.5 ).x == x * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).y == - y * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).z == z * 0.5, "Passed!" );

				assert.ok( a.clone().lerp( b, 1 ).equals( b ), "Passed!" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Vector4', () => {

			// INSTANCING
			QUnit.test( "Instancing", ( assert ) => {

				var a = new Vector4();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				var a = new Vector4( x, y, z, w );
				assert.ok( a.x === x, "Passed!" );
				assert.ok( a.y === y, "Passed!" );
				assert.ok( a.z === z, "Passed!" );
				assert.ok( a.w === w, "Passed!" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isVector4", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "set", ( assert ) => {

				var a = new Vector4();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				a.set( x, y, z, w );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );
				assert.ok( a.w == w, "Passed!" );

			} );

			QUnit.todo( "setScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setX", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setY", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setZ", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setW", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "getComponent", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "copy", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4().copy( a );
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z == z, "Passed!" );
				assert.ok( b.w == w, "Passed!" );

				// ensure that it is a true copy
				a.x = 0;
				a.y = - 1;
				a.z = - 2;
				a.w = - 3;
				assert.ok( b.x == x, "Passed!" );
				assert.ok( b.y == y, "Passed!" );
				assert.ok( b.z == z, "Passed!" );
				assert.ok( b.w == w, "Passed!" );

			} );

			QUnit.test( "add", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( - x, - y, - z, - w );

				a.add( b );
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 0, "Passed!" );

				var c = new Vector4().addVectors( b, b );
				assert.ok( c.x == - 2 * x, "Passed!" );
				assert.ok( c.y == - 2 * y, "Passed!" );
				assert.ok( c.z == - 2 * z, "Passed!" );
				assert.ok( c.w == - 2 * w, "Passed!" );

			} );

			QUnit.todo( "addScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "addVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "addScaledVector", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( 6, 7, 8, 9 );
				var s = 3;

				a.addScaledVector( b, s );
				assert.strictEqual( a.x, x + b.x * s, "Check x" );
				assert.strictEqual( a.y, y + b.y * s, "Check y" );
				assert.strictEqual( a.z, z + b.z * s, "Check z" );
				assert.strictEqual( a.w, w + b.w * s, "Check w" );

			} );

			QUnit.test( "sub", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( - x, - y, - z, - w );

				a.sub( b );
				assert.ok( a.x == 2 * x, "Passed!" );
				assert.ok( a.y == 2 * y, "Passed!" );
				assert.ok( a.z == 2 * z, "Passed!" );
				assert.ok( a.w == 2 * w, "Passed!" );

				var c = new Vector4().subVectors( a, a );
				assert.ok( c.x == 0, "Passed!" );
				assert.ok( c.y == 0, "Passed!" );
				assert.ok( c.z == 0, "Passed!" );
				assert.ok( c.w == 0, "Passed!" );

			} );

			QUnit.todo( "subScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "subVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "multiplyScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "applyMatrix4", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var m = new Matrix4().makeRotationX( Math.PI );
				var expected = new Vector4( 2, - 3, - 4, 5 );

				a.applyMatrix4( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Rotation matrix: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Rotation matrix: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Rotation matrix: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Rotation matrix: check w" );

				a.set( x, y, z, w );
				m.makeTranslation( 5, 7, 11 );
				expected.set( 27, 38, 59, 5 );

				a.applyMatrix4( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Translation matrix: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Translation matrix: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Translation matrix: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Translation matrix: check w" );

				a.set( x, y, z, w );
				m.set( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0 );
				expected.set( 2, 3, 4, 4 );

				a.applyMatrix4( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Custom matrix: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Custom matrix: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Custom matrix: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Custom matrix: check w" );

				a.set( x, y, z, w );
				m.set( 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53 );
				expected.set( 68, 224, 442, 664 );

				a.applyMatrix4( m );
				assert.ok( Math.abs( a.x - expected.x ) <= eps, "Bogus matrix: check x" );
				assert.ok( Math.abs( a.y - expected.y ) <= eps, "Bogus matrix: check y" );
				assert.ok( Math.abs( a.z - expected.z ) <= eps, "Bogus matrix: check z" );
				assert.ok( Math.abs( a.w - expected.w ) <= eps, "Bogus matrix: check w" );

			} );

			QUnit.todo( "divideScalar", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setAxisAngleFromQuaternion", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setAxisAngleFromRotationMatrix", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "min", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "max", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clamp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "clampScalar", ( assert ) => {

				var a = new Vector4( - 0.1, 0.01, 0.5, 1.5 );
				var clamped = new Vector4( 0.1, 0.1, 0.5, 1.0 );

				a.clampScalar( 0.1, 1.0 );
				assert.ok( Math.abs( a.x - clamped.x ) <= eps, "Check x" );
				assert.ok( Math.abs( a.y - clamped.y ) <= eps, "Check y" );
				assert.ok( Math.abs( a.z - clamped.z ) <= eps, "Check z" );
				assert.ok( Math.abs( a.w - clamped.w ) <= eps, "Check w" );

			} );

			QUnit.todo( "clampLength", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "floor", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "ceil", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "round", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "roundToZero", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "negate", ( assert ) => {

				var a = new Vector4( x, y, z, w );

				a.negate();
				assert.ok( a.x == - x, "Passed!" );
				assert.ok( a.y == - y, "Passed!" );
				assert.ok( a.z == - z, "Passed!" );
				assert.ok( a.w == - w, "Passed!" );

			} );

			QUnit.test( "dot", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( - x, - y, - z, - w );
				var c = new Vector4( 0, 0, 0, 0 );

				var result = a.dot( b );
				assert.ok( result == ( - x * x - y * y - z * z - w * w ), "Passed!" );

				var result = a.dot( c );
				assert.ok( result == 0, "Passed!" );

			} );

			QUnit.todo( "lengthSq", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "length", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "manhattanLength", ( assert ) => {

				var a = new Vector4( x, 0, 0, 0 );
				var b = new Vector4( 0, - y, 0, 0 );
				var c = new Vector4( 0, 0, z, 0 );
				var d = new Vector4( 0, 0, 0, w );
				var e = new Vector4( 0, 0, 0, 0 );

				assert.ok( a.manhattanLength() == x, "Positive x" );
				assert.ok( b.manhattanLength() == y, "Negative y" );
				assert.ok( c.manhattanLength() == z, "Positive z" );
				assert.ok( d.manhattanLength() == w, "Positive w" );
				assert.ok( e.manhattanLength() == 0, "Empty initialization" );

				a.set( x, y, z, w );
				assert.ok(
					a.manhattanLength() == Math.abs( x ) + Math.abs( y ) + Math.abs( z ) + Math.abs( w ),
					"All components"
				);

			} );

			QUnit.test( "normalize", ( assert ) => {

				var a = new Vector4( x, 0, 0, 0 );
				var b = new Vector4( 0, - y, 0, 0 );
				var c = new Vector4( 0, 0, z, 0 );
				var d = new Vector4( 0, 0, 0, - w );

				a.normalize();
				assert.ok( a.length() == 1, "Passed!" );
				assert.ok( a.x == 1, "Passed!" );

				b.normalize();
				assert.ok( b.length() == 1, "Passed!" );
				assert.ok( b.y == - 1, "Passed!" );

				c.normalize();
				assert.ok( c.length() == 1, "Passed!" );
				assert.ok( c.z == 1, "Passed!" );

				d.normalize();
				assert.ok( d.length() == 1, "Passed!" );
				assert.ok( d.w == - 1, "Passed!" );

			} );

			QUnit.test( "setLength", ( assert ) => {

				var a = new Vector4( x, 0, 0, 0 );

				assert.ok( a.length() == x, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == y, "Passed!" );

				var a = new Vector4( 0, 0, 0, 0 );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength( y );
				assert.ok( a.length() == 0, "Passed!" );
				a.setLength();
				assert.ok( isNaN( a.length() ), "Passed!" );

			} );

			QUnit.todo( "lerp", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "lerpVectors", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.test( "equals", ( assert ) => {

				var a = new Vector4( x, 0, z, 0 );
				var b = new Vector4( 0, - y, 0, - w );

				assert.ok( a.x != b.x, "Passed!" );
				assert.ok( a.y != b.y, "Passed!" );
				assert.ok( a.z != b.z, "Passed!" );
				assert.ok( a.w != b.w, "Passed!" );

				assert.ok( ! a.equals( b ), "Passed!" );
				assert.ok( ! b.equals( a ), "Passed!" );

				a.copy( b );
				assert.ok( a.x == b.x, "Passed!" );
				assert.ok( a.y == b.y, "Passed!" );
				assert.ok( a.z == b.z, "Passed!" );
				assert.ok( a.w == b.w, "Passed!" );

				assert.ok( a.equals( b ), "Passed!" );
				assert.ok( b.equals( a ), "Passed!" );

			} );

			QUnit.test( "fromArray", ( assert ) => {

				var a = new Vector4();
				var array = [ 1, 2, 3, 4, 5, 6, 7, 8 ];

				a.fromArray( array );
				assert.strictEqual( a.x, 1, "No offset: check x" );
				assert.strictEqual( a.y, 2, "No offset: check y" );
				assert.strictEqual( a.z, 3, "No offset: check z" );
				assert.strictEqual( a.w, 4, "No offset: check w" );

				a.fromArray( array, 4 );
				assert.strictEqual( a.x, 5, "With offset: check x" );
				assert.strictEqual( a.y, 6, "With offset: check y" );
				assert.strictEqual( a.z, 7, "With offset: check z" );
				assert.strictEqual( a.w, 8, "With offset: check w" );

			} );

			QUnit.test( "toArray", ( assert ) => {

				var a = new Vector4( x, y, z, w );

				var array = a.toArray();
				assert.strictEqual( array[ 0 ], x, "No array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "No array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "No array, no offset: check z" );
				assert.strictEqual( array[ 3 ], w, "No array, no offset: check w" );

				var array = [];
				a.toArray( array );
				assert.strictEqual( array[ 0 ], x, "With array, no offset: check x" );
				assert.strictEqual( array[ 1 ], y, "With array, no offset: check y" );
				assert.strictEqual( array[ 2 ], z, "With array, no offset: check z" );
				assert.strictEqual( array[ 3 ], w, "With array, no offset: check w" );

				var array = [];
				a.toArray( array, 1 );
				assert.strictEqual( array[ 0 ], undefined, "With array and offset: check [0]" );
				assert.strictEqual( array[ 1 ], x, "With array and offset: check x" );
				assert.strictEqual( array[ 2 ], y, "With array and offset: check y" );
				assert.strictEqual( array[ 3 ], z, "With array and offset: check z" );
				assert.strictEqual( array[ 4 ], w, "With array and offset: check w" );

			} );

			QUnit.test( "fromBufferAttribute", ( assert ) => {

				var a = new Vector4();
				var attr = new BufferAttribute( new Float32Array( [ 1, 2, 3, 4, 5, 6, 7, 8 ] ), 4 );

				a.fromBufferAttribute( attr, 0 );
				assert.strictEqual( a.x, 1, "Offset 0: check x" );
				assert.strictEqual( a.y, 2, "Offset 0: check y" );
				assert.strictEqual( a.z, 3, "Offset 0: check z" );
				assert.strictEqual( a.w, 4, "Offset 0: check w" );

				a.fromBufferAttribute( attr, 1 );
				assert.strictEqual( a.x, 5, "Offset 1: check x" );
				assert.strictEqual( a.y, 6, "Offset 1: check y" );
				assert.strictEqual( a.z, 7, "Offset 1: check z" );
				assert.strictEqual( a.w, 8, "Offset 1: check w" );

			} );

			// TODO (Itee) refactor/split
			QUnit.test( "setX,setY,setZ,setW", ( assert ) => {

				var a = new Vector4();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				a.setX( x );
				a.setY( y );
				a.setZ( z );
				a.setW( w );

				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );
				assert.ok( a.w == w, "Passed!" );

			} );
			QUnit.test( "setComponent,getComponent", ( assert ) => {

				var a = new Vector4();
				assert.ok( a.x == 0, "Passed!" );
				assert.ok( a.y == 0, "Passed!" );
				assert.ok( a.z == 0, "Passed!" );
				assert.ok( a.w == 1, "Passed!" );

				a.setComponent( 0, 1 );
				a.setComponent( 1, 2 );
				a.setComponent( 2, 3 );
				a.setComponent( 3, 4 );
				assert.ok( a.getComponent( 0 ) == 1, "Passed!" );
				assert.ok( a.getComponent( 1 ) == 2, "Passed!" );
				assert.ok( a.getComponent( 2 ) == 3, "Passed!" );
				assert.ok( a.getComponent( 3 ) == 4, "Passed!" );

			} );
			QUnit.test( "setComponent/getComponent exceptions", ( assert ) => {

				var a = new Vector4();

				assert.throws(
					function () {

						a.setComponent( 4, 0 );

					},
					/index is out of range/,
					"setComponent with an out of range index throws Error"
				);
				assert.throws(
					function () {

						a.getComponent( 4 );

					},
					/index is out of range/,
					"getComponent with an out of range index throws Error"
				);

			} );
			QUnit.test( "setScalar/addScalar/subScalar", ( assert ) => {

				var a = new Vector4();
				var s = 3;

				a.setScalar( s );
				assert.strictEqual( a.x, s, "setScalar: check x" );
				assert.strictEqual( a.y, s, "setScalar: check y" );
				assert.strictEqual( a.z, s, "setScalar: check z" );
				assert.strictEqual( a.w, s, "setScalar: check w" );

				a.addScalar( s );
				assert.strictEqual( a.x, 2 * s, "addScalar: check x" );
				assert.strictEqual( a.y, 2 * s, "addScalar: check y" );
				assert.strictEqual( a.z, 2 * s, "addScalar: check z" );
				assert.strictEqual( a.w, 2 * s, "addScalar: check w" );

				a.subScalar( 2 * s );
				assert.strictEqual( a.x, 0, "subScalar: check x" );
				assert.strictEqual( a.y, 0, "subScalar: check y" );
				assert.strictEqual( a.z, 0, "subScalar: check z" );
				assert.strictEqual( a.w, 0, "subScalar: check w" );

			} );
			QUnit.test( "multiply/divide", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( - x, - y, - z, - w );

				a.multiplyScalar( - 2 );
				assert.ok( a.x == x * - 2, "Passed!" );
				assert.ok( a.y == y * - 2, "Passed!" );
				assert.ok( a.z == z * - 2, "Passed!" );
				assert.ok( a.w == w * - 2, "Passed!" );

				b.multiplyScalar( - 2 );
				assert.ok( b.x == 2 * x, "Passed!" );
				assert.ok( b.y == 2 * y, "Passed!" );
				assert.ok( b.z == 2 * z, "Passed!" );
				assert.ok( b.w == 2 * w, "Passed!" );

				a.divideScalar( - 2 );
				assert.ok( a.x == x, "Passed!" );
				assert.ok( a.y == y, "Passed!" );
				assert.ok( a.z == z, "Passed!" );
				assert.ok( a.w == w, "Passed!" );

				b.divideScalar( - 2 );
				assert.ok( b.x == - x, "Passed!" );
				assert.ok( b.y == - y, "Passed!" );
				assert.ok( b.z == - z, "Passed!" );
				assert.ok( b.w == - w, "Passed!" );

			} );
			QUnit.test( "min/max/clamp", ( assert ) => {

				var a = new Vector4( x, y, z, w );
				var b = new Vector4( - x, - y, - z, - w );
				var c = new Vector4();

				c.copy( a ).min( b );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == - y, "Passed!" );
				assert.ok( c.z == - z, "Passed!" );
				assert.ok( c.w == - w, "Passed!" );

				c.copy( a ).max( b );
				assert.ok( c.x == x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );
				assert.ok( c.z == z, "Passed!" );
				assert.ok( c.w == w, "Passed!" );

				c.set( - 2 * x, 2 * y, - 2 * z, 2 * w );
				c.clamp( b, a );
				assert.ok( c.x == - x, "Passed!" );
				assert.ok( c.y == y, "Passed!" );
				assert.ok( c.z == - z, "Passed!" );
				assert.ok( c.w == w, "Passed!" );

			} );
			QUnit.test( "length/lengthSq", ( assert ) => {

				var a = new Vector4( x, 0, 0, 0 );
				var b = new Vector4( 0, - y, 0, 0 );
				var c = new Vector4( 0, 0, z, 0 );
				var d = new Vector4( 0, 0, 0, w );
				var e = new Vector4( 0, 0, 0, 0 );

				assert.ok( a.length() == x, "Passed!" );
				assert.ok( a.lengthSq() == x * x, "Passed!" );
				assert.ok( b.length() == y, "Passed!" );
				assert.ok( b.lengthSq() == y * y, "Passed!" );
				assert.ok( c.length() == z, "Passed!" );
				assert.ok( c.lengthSq() == z * z, "Passed!" );
				assert.ok( d.length() == w, "Passed!" );
				assert.ok( d.lengthSq() == w * w, "Passed!" );
				assert.ok( e.length() == 0, "Passed!" );
				assert.ok( e.lengthSq() == 0, "Passed!" );

				a.set( x, y, z, w );
				assert.ok( a.length() == Math.sqrt( x * x + y * y + z * z + w * w ), "Passed!" );
				assert.ok( a.lengthSq() == ( x * x + y * y + z * z + w * w ), "Passed!" );

			} );
			QUnit.test( "lerp/clone", ( assert ) => {

				var a = new Vector4( x, 0, z, 0 );
				var b = new Vector4( 0, - y, 0, - w );

				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 0.5 ) ), "Passed!" );
				assert.ok( a.lerp( a, 0 ).equals( a.lerp( a, 1 ) ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0 ).equals( a ), "Passed!" );

				assert.ok( a.clone().lerp( b, 0.5 ).x == x * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).y == - y * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).z == z * 0.5, "Passed!" );
				assert.ok( a.clone().lerp( b, 0.5 ).w == - w * 0.5, "Passed!" );

				assert.ok( a.clone().lerp( b, 1 ).equals( b ), "Passed!" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Interpolants', () => {

			QUnit.module( 'CubicInterpolant', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Interpolants', () => {

			QUnit.module( 'DiscreteInterpolant', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Interpolants', () => {

			QUnit.module( 'LinearInterpolant', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Maths', () => {

		QUnit.module( 'Interpolants', () => {

			QUnit.module( 'QuaternionLinearInterpolant', () => {

				// INHERITANCE
				QUnit.todo( "Extending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Bone', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isBone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Group', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Line', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLine", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "raycast", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'LineLoop', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLineLoop", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'LineSegments', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isLineSegments", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'LOD', () => {

			// INHERITANCE
			QUnit.test( "Extending", ( assert ) => {

				var lod = new LOD();

				assert.strictEqual( ( lod instanceof Object3D ), true, "LOD extends from Object3D" );

			} );

			// PROPERTIES
			QUnit.test( "levels", ( assert ) => {

				var lod = new LOD();
				var levels = lod.levels;

				assert.strictEqual( Array.isArray( levels ), true, "LOD.levels is of type array." );
				assert.strictEqual( levels.length, 0, "LOD.levels is empty by default." );

			} );

			QUnit.test( "autoUpdate", ( assert ) => {

				var lod = new LOD();

				assert.strictEqual( lod.autoUpdate, true, "LOD.autoUpdate is of type boolean and true by default." );

			} );

			// PUBLIC STUFF
			QUnit.test( "isLOD", ( assert ) => {

				var lod = new LOD();

				assert.strictEqual( lod.isLOD, true, ".isLOD property is defined." );

			} );
			QUnit.test( "copy", ( assert ) => {

				var lod1 = new LOD();
				var lod2 = new LOD();

				var high = new Object3D();
				var mid = new Object3D();
				var low = new Object3D();

				lod1.addLevel( high, 5 );
				lod1.addLevel( mid, 25 );
				lod1.addLevel( low, 50 );

				lod1.autoUpdate = false;

				lod2.copy( lod1 );

				assert.strictEqual( lod2.autoUpdate, false, "LOD.autoUpdate is correctly copied." );
				assert.strictEqual( lod2.levels.length, 3, "LOD.levels has the correct length after the copy." );

			} );
			QUnit.test( "addLevel", ( assert ) => {

				var lod = new LOD();

				var high = new Object3D();
				var mid = new Object3D();
				var low = new Object3D();

				lod.addLevel( high, 5 );
				lod.addLevel( mid, 25 );
				lod.addLevel( low, 50 );

				assert.strictEqual( lod.levels.length, 3, "LOD.levels has the correct length." );
				assert.deepEqual( lod.levels[ 0 ], { distance: 5, object: high }, "First entry correct." );
				assert.deepEqual( lod.levels[ 1 ], { distance: 25, object: mid }, "Second entry correct." );
				assert.deepEqual( lod.levels[ 2 ], { distance: 50, object: low }, "Third entry correct." );

			} );
			QUnit.test( "getObjectForDistance", ( assert ) => {

				var lod = new LOD();

				var high = new Object3D();
				var mid = new Object3D();
				var low = new Object3D();

				assert.strictEqual( lod.getObjectForDistance( 5 ), null, "Returns null if no LOD levels are defined." );

				lod.addLevel( high, 5 );

				assert.strictEqual( lod.getObjectForDistance( 0 ), high, "Returns always the same object if only one LOD level is defined." );
				assert.strictEqual( lod.getObjectForDistance( 10 ), high, "Returns always the same object if only one LOD level is defined." );

				lod.addLevel( mid, 25 );
				lod.addLevel( low, 50 );

				assert.strictEqual( lod.getObjectForDistance( 0 ), high, "Returns the high resolution object." );
				assert.strictEqual( lod.getObjectForDistance( 10 ), high, "Returns the high resolution object." );
				assert.strictEqual( lod.getObjectForDistance( 25 ), mid, "Returns the mid resolution object." );
				assert.strictEqual( lod.getObjectForDistance( 50 ), low, "Returns the low resolution object." );
				assert.strictEqual( lod.getObjectForDistance( 60 ), low, "Returns the low resolution object." );

			} );
			QUnit.test( "raycast", ( assert ) => {

				var lod = new LOD();
				var raycaster = new Raycaster();
				var intersections = [];

				lod.raycast( raycaster, intersections );

				assert.strictEqual( intersections.length, 0, "Does not fail if raycasting is used with a LOD object without levels." );

			} );
			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Mesh', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isMesh", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "updateMorphTargets", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "raycast", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );


		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Points', () => {

			// INHERITANCE
			QUnit.todo( "isPoints", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "raycast", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Skeleton', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "calculateInverses", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "pose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "update", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'SkinnedMesh', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSkinnedMesh", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "initBones", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "bind", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "pose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "normalizeSkinWeights", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "updateMatrixWorld", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );
			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Objects', () => {

		QUnit.module( 'Sprite', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isSprite", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "raycast", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGLRenderer-webonly', () => {

			QUnit.test( "Instancing", ( assert ) => {

				assert.ok( new WebGLRenderer(), "Can instantiate a renderer." );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGLRenderTarget', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isWebGLRenderTarget", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "setSize", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGLCubeRenderTarget', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isWebGLCubeRenderTarget", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'Shaders', () => {

			QUnit.module( 'ShaderChunk', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'Shaders', () => {

			QUnit.module( 'ShaderLib', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'Shaders', () => {

			QUnit.module( 'UniformsLib', () => {

				// PUBLIC STUFF
				QUnit.todo( "merge", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "clone", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'Shaders', () => {

			QUnit.module( 'UniformsUtils', () => {

				QUnit.todo( 'write me !', ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLAttributes', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "get", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "remove", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "update", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLBackground', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getClearColor", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setClearColor", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getClearAlpha", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setClearAlpha", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "render", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLBufferRenderer', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "setMode", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "render", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "renderInstances", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLCapabilities', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getMaxAnisotropy", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getMaxPrecision", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "precision", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "logarithmicDepthBuffer", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxTextures", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxVertexTextures", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxTextureSize", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxCubemapSize", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxAttributes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxVertexUniforms", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxVaryings", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "maxFragmentUniforms", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "vertexTextures", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "floatFragmentTextures", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "floatVertexTextures", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLClipping', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "init", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "beginShadows", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "endShadows", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setState", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLExtensions', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "get", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLGeometries', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "get", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "update", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getWireframeAttribute", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLIndexedBufferRenderer', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "setMode", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setIndex", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "render", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "renderInstances", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLLights', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "setup", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "state", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLMorphtargets', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "update", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLObjects', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "update", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "clear", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLProgram', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PROPERTIES
				QUnit.todo( "uniforms", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "attributes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getUniforms", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getAttributes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "destroy", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLPrograms', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "getParameters", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getProgramCode", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "acquireProgram", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "releaseProgram", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "programs", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLProperties', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "get", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "remove", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "clear", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLRenderLists', () => {

				// PUBLIC STUFF
				QUnit.test( "get", ( assert ) => {

					var properties = new WebGLProperties();

					var renderLists = new WebGLRenderLists( properties );
					var sceneA = new Scene();
					var sceneB = new Scene();

					var listA = renderLists.get( sceneA );
					var listB = renderLists.get( sceneB );

					assert.propEqual( listA, new WebGLRenderList( properties ), "listA is type of WebGLRenderList." );
					assert.propEqual( listB, new WebGLRenderList( properties ), "listB is type of WebGLRenderList." );
					assert.ok( listA !== listB, "Render lists are different." );


				} );

			} );


			QUnit.module( 'WebGLRenderList', () => {

				QUnit.test( 'init', ( assert ) => {

					var properties = new WebGLProperties();
					var list = new WebGLRenderList( properties );

					assert.ok( list.transparent.length === 0, 'Transparent list defaults to length 0.' );
					assert.ok( list.opaque.length === 0, 'Opaque list defaults to length 0.' );

					list.push( {}, {}, { transparent: true }, 0, 0, {} );
					list.push( {}, {}, { transparent: false }, 0, 0, {} );

					assert.ok( list.transparent.length === 1, 'Transparent list is length 1 after adding transparent item.' );
					assert.ok( list.opaque.length === 1, 'Opaque list list is length 1 after adding opaque item.' );

					list.init();

					assert.ok( list.transparent.length === 0, 'Transparent list is length 0 after calling init.' );
					assert.ok( list.opaque.length === 0, 'Opaque list list is length 0 after calling init.' );

				} );

				QUnit.test( 'push', ( assert ) => {

					var properties = new WebGLProperties();

					var list = new WebGLRenderList( properties );
					var objA = { id: 'A', renderOrder: 0 };
					var matA = { transparent: true };
					var proA = { id: 1 };
					var geoA = {};

					var objB = { id: 'B', renderOrder: 0 };
					var matB = { transparent: true };
					var proB = { id: 2 };
					var geoB = {};

					var objC = { id: 'C', renderOrder: 0 };
					var matC = { transparent: false };
					var proC = { id: 3 };
					var geoC = {};

					var objD = { id: 'D', renderOrder: 0 };
					var matD = { transparent: false };
					var proD = { id: 4 };
					var geoD = {};

					var materialProperties = properties.get( matA );
					materialProperties.program = proA;
					materialProperties = properties.get( matB );
					materialProperties.program = proB;
					materialProperties = properties.get( matC );
					materialProperties.program = proC;
					materialProperties = properties.get( matD );
					materialProperties.program = proD;

					list.push( objA, geoA, matA, 0, 0.5, {} );
					assert.ok( list.transparent.length === 1, 'Transparent list is length 1 after adding transparent item.' );
					assert.ok( list.opaque.length === 0, 'Opaque list list is length 0 after adding transparent item.' );
					assert.deepEqual(
						list.transparent[ 0 ],
						{
							id: 'A',
							object: objA,
							geometry: geoA,
							material: matA,
							program: proA,
							groupOrder: 0,
							renderOrder: 0,
							z: 0.5,
							group: {}
						},
						'The first transparent render list item is structured correctly.'
					);

					list.push( objB, geoB, matB, 1, 1.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding second transparent item.' );
					assert.ok( list.opaque.length === 0, 'Opaque list list is length 0 after adding second transparent item.' );
					assert.deepEqual(
						list.transparent[ 1 ],
						{
							id: 'B',
							object: objB,
							geometry: geoB,
							material: matB,
							program: proB,
							groupOrder: 1,
							renderOrder: 0,
							z: 1.5,
							group: {}
						},
						'The second transparent render list item is structured correctly.'
					);

					list.push( objC, geoC, matC, 2, 2.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding first opaque item.' );
					assert.ok( list.opaque.length === 1, 'Opaque list list is length 1 after adding first opaque item.' );
					assert.deepEqual(
						list.opaque[ 0 ],
						{
							id: 'C',
							object: objC,
							geometry: geoC,
							material: matC,
							program: proC,
							groupOrder: 2,
							renderOrder: 0,
							z: 2.5,
							group: {}
						},
						'The first opaque render list item is structured correctly.'
					);

					list.push( objD, geoD, matD, 3, 3.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding second opaque item.' );
					assert.ok( list.opaque.length === 2, 'Opaque list list is length 2 after adding second opaque item.' );
					assert.deepEqual(
						list.opaque[ 1 ],
						{
							id: 'D',
							object: objD,
							geometry: geoD,
							material: matD,
							program: proD,
							groupOrder: 3,
							renderOrder: 0,
							z: 3.5,
							group: {}
						},
						'The second opaque render list item is structured correctly.'
					);

				} );

				QUnit.test( 'unshift', ( assert ) => {

					var properties = new WebGLProperties();
					var list = new WebGLRenderList( properties );
					var objA = { id: 'A', renderOrder: 0 };
					var matA = { transparent: true };
					var proA = { id: 1 };
					var geoA = {};

					var objB = { id: 'B', renderOrder: 0 };
					var matB = { transparent: true };
					var proB = { id: 2 };
					var geoB = {};

					var objC = { id: 'C', renderOrder: 0 };
					var matC = { transparent: false };
					var proC = { id: 3 };
					var geoC = {};

					var objD = { id: 'D', renderOrder: 0 };
					var matD = { transparent: false };
					var proD = { id: 4 };
					var geoD = {};

					var materialProperties = properties.get( matA );
					materialProperties.program = proA;
					materialProperties = properties.get( matB );
					materialProperties.program = proB;
					materialProperties = properties.get( matC );
					materialProperties.program = proC;
					materialProperties = properties.get( matD );
					materialProperties.program = proD;

					list.unshift( objA, geoA, matA, 0, 0.5, {} );
					assert.ok( list.transparent.length === 1, 'Transparent list is length 1 after adding transparent item.' );
					assert.ok( list.opaque.length === 0, 'Opaque list list is length 0 after adding transparent item.' );
					assert.deepEqual(
						list.transparent[ 0 ],
						{
							id: 'A',
							object: objA,
							geometry: geoA,
							material: matA,
							program: proA,
							groupOrder: 0,
							renderOrder: 0,
							z: 0.5,
							group: {}
						},
						'The first transparent render list item is structured correctly.'
					);

					list.unshift( objB, geoB, matB, 1, 1.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding second transparent item.' );
					assert.ok( list.opaque.length === 0, 'Opaque list list is length 0 after adding second transparent item.' );
					assert.deepEqual(
						list.transparent[ 0 ],
						{
							id: 'B',
							object: objB,
							geometry: geoB,
							material: matB,
							program: proB,
							groupOrder: 1,
							renderOrder: 0,
							z: 1.5,
							group: {}
						},
						'The second transparent render list item is structured correctly.'
					);

					list.unshift( objC, geoC, matC, 2, 2.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding first opaque item.' );
					assert.ok( list.opaque.length === 1, 'Opaque list list is length 1 after adding first opaque item.' );
					assert.deepEqual(
						list.opaque[ 0 ],
						{
							id: 'C',
							object: objC,
							geometry: geoC,
							material: matC,
							program: proC,
							groupOrder: 2,
							renderOrder: 0,
							z: 2.5,
							group: {}
						},
						'The first opaque render list item is structured correctly.'
					);

					list.unshift( objD, geoD, matD, 3, 3.5, {} );
					assert.ok( list.transparent.length === 2, 'Transparent list is length 2 after adding second opaque item.' );
					assert.ok( list.opaque.length === 2, 'Opaque list list is length 2 after adding second opaque item.' );
					assert.deepEqual(
						list.opaque[ 0 ],
						{
							id: 'D',
							object: objD,
							geometry: geoD,
							material: matD,
							program: proD,
							groupOrder: 3,
							renderOrder: 0,
							z: 3.5,
							group: {}
						},
						'The second opaque render list item is structured correctly.'
					);

				} );

				QUnit.test( 'sort', ( assert ) => {

					var properties = new WebGLProperties();
					var list = new WebGLRenderList( properties );
					var items = [ { id: 4 }, { id: 5 }, { id: 2 }, { id: 3 } ];

					items.forEach( item => {

						list.push( item, {}, { transparent: true }, 0, 0, {} );
						list.push( item, {}, { transparent: false }, 0, 0, {} );

					} );

					list.sort( ( a, b ) => a.id - b.id, ( a, b ) => b.id - a.id );

					assert.deepEqual(
						list.opaque.map( item => item.id ),
						[ 2, 3, 4, 5 ],
						'The opaque sort is applied to the opaque items list.'
					);

					assert.deepEqual(
						list.transparent.map( item => item.id ),
						[ 5, 4, 3, 2 ],
						'The transparent sort is applied to the transparent items list.'
					);

				} );

				// QUnit.test( 'finish', ( assert ) => {

				// 	var list = new WebGLRenderList( properties );
				// 	var obj = { id: 'A', renderOrder: 0 };
				// 	var mat = { transparent: false, program: { id: 0 } };
				// 	var geom = {};

				// 	assert.ok( list.renderItems.length === 0, 'Render items length defaults to 0.' );

				// 	list.push( obj, geom, mat, 0, 0, {} );
				// 	list.push( obj, geom, mat, 0, 0, {} );
				// 	list.push( obj, geom, mat, 0, 0, {} );
				// 	assert.ok( list.renderItems.length === 3, 'Render items length expands as items are added.' );

				// 	list.finish();
				// 	assert.deepEqual(
				// 		list.renderItems.map( item => item.object ),
				// 		[ obj, obj, obj ],
				// 		'Render items are not cleaned if they are being used.'
				// 	);
				// 	assert.deepEqual(
				// 		list.renderItems[ 1 ],
				// 		{
				// 			id: 'A',
				// 			object: obj,
				// 			geometry: geom,
				// 			material: mat,
				// 			program: mat.program,
				// 			groupOrder: 0,
				// 			renderOrder: 0,
				// 			z: 0,
				// 			group: {}
				// 		},
				// 		'Unused render item is structured correctly before clearing.'
				// 	);

				// 	list.init();
				// 	list.push( obj, geom, mat, 0, 0, {} );
				// 	assert.ok( list.renderItems.length === 3, 'Render items length does not shrink.' );

				// 	list.finish();
				// 	assert.deepEqual(
				// 		list.renderItems.map( item => item.object ),
				// 		[ obj, null, null ],
				// 		'Render items are cleaned if they are not being used.'
				// 	);

				// 	assert.deepEqual(
				// 		list.renderItems[ 1 ],
				// 		{
				// 			id: null,
				// 			object: null,
				// 			geometry: null,
				// 			material: null,
				// 			program: null,
				// 			groupOrder: 0,
				// 			renderOrder: 0,
				// 			z: 0,
				// 			group: null
				// 		},
				// 		'Unused render item is structured correctly before clearing.'
				// 	);

				// } );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLShader', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLShadowMap', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "render", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLState', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "buffers", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "initAttributes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "enableAttribute", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "enableAttributeAndDivisor", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "disableUnusedAttributes", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "enable", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "disable", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "getCompressedTextureFormats", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "useProgram", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setBlending", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setMaterial", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setFlipSided", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setCullFace", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setLineWidth", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setPolygonOffset", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setScissorTest", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "activeTexture", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "bindTexture", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "compressedTexImage2D", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "texImage2D", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "scissor", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "viewport", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "reset", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLTextures', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "setTexture2D", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );
				QUnit.todo( "setTextureCube", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );
				QUnit.todo( "setTextureCubeDynamic", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );
				QUnit.todo( "setupRenderTarget", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );
				QUnit.todo( "updateRenderTargetMipmap", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLUniforms', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "setValue", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "setOptional", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "upload", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				QUnit.todo( "seqWithValue", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Renderers', () => {

		QUnit.module( 'WebGL', () => {

			QUnit.module( 'WebGLUtils', () => {

				// INSTANCING
				QUnit.todo( "Instancing", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

				// PUBLIC STUFF
				QUnit.todo( "convert", ( assert ) => {

					assert.ok( false, "everything's gonna be alright" );

				} );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Fog', () => {

		QUnit.module( 'Scene', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isFog", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'FoxExp2', () => {

		QUnit.module( 'Scene', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isFogExp2", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Scenes', () => {

		QUnit.module( 'Scene', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isScene", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'CanvasTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isCanvasTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'CompressedTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isCompressedTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'CubeTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.todo( "images", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isCubeTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'DataTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isDataTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'DepthTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isDepthTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'Texture', () => {

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PROPERTIES
			QUnit.todo( "needsUpdate", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "clone", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "copy", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "toJSON", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "dispose", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			QUnit.todo( "transformUv", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	/* global QUnit */

	QUnit.module( 'Textures', () => {

		QUnit.module( 'VideoTexture', () => {

			// INHERITANCE
			QUnit.todo( "Extending", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// INSTANCING
			QUnit.todo( "Instancing", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

			// PUBLIC STUFF
			QUnit.todo( "isVideoTexture", ( assert ) => {

				assert.ok( false, "everything's gonna be alright" );

			} );

		} );

	} );

	} );

})));
